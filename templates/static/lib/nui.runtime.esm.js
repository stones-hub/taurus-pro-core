/*!
  * Nui.js v1.9.75
  * (c) 2020-2025 Evan You
  * Released under the MIT License.
  */
import Vue from 'vue';
import 'path';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var _global = createCommonjsModule(function (module) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
_core.version;

var _isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function (it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

var document$2 = _global.document;
// typeof document.createElement is 'object' in old IE
var is$1 = _isObject(document$2) && _isObject(document$2.createElement);
var _domCreate = function (it) {
  return is$1 ? document$2.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function (it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP$4 = Object.defineProperty;

var f$8 = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP$4(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
	f: f$8
};

var _propertyDesc = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty$d = {}.hasOwnProperty;
var _has = function (it, key) {
  return hasOwnProperty$d.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _library = false;

var _shared = createCommonjsModule(function (module) {
var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: _core.version,
  mode: 'global',
  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});
});

var _functionToString = _shared('native-function-to-string', Function.toString);

var _redefine = createCommonjsModule(function (module) {
var SRC = _uid('src');

var TO_STRING = 'toString';
var TPL = ('' + _functionToString).split(TO_STRING);

_core.inspectSource = function (it) {
  return _functionToString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === _global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    _hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    _hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
});
});

var _aFunction = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function (fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE$2 = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE$2];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE$2] || (exports[PROTOTYPE$2] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var toString$2 = {}.toString;

var _cof = function (it) {
  return toString$2.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function (it) {
  return _iobject(_defined(it));
};

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor$1 = Math.floor;
var _toInteger = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor$1 : ceil)(it);
};

// 7.1.15 ToLength

var min$2 = Math.min;
var _toLength = function (it) {
  return it > 0 ? min$2(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max$1 = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function (index, length) {
  index = _toInteger(index);
  return index < 0 ? max$1(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes



var _arrayIncludes = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

var shared = _shared('keys');

var _sharedKey = function (key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$2 = _sharedKey('IE_PROTO');

var _objectKeysInternal = function (object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO$2) _has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (_has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)

var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

var f$7 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return _objectKeysInternal(O, hiddenKeys);
};

var _objectGopn = {
	f: f$7
};

var f$6 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$6
};

// all object keys, includes non-enumerable and symbols



var Reflect = _global.Reflect;
var _ownKeys = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = _objectGopn.f(_anObject(it));
  var getSymbols = _objectGops.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

var f$5 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$5
};

var gOPD$2 = Object.getOwnPropertyDescriptor;

var f$4 = _descriptors ? gOPD$2 : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD$2(O, P);
  } catch (e) { /* empty */ }
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
	f: f$4
};

var _createProperty = function (object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
  else object[index] = value;
};

// https://github.com/tc39/proposal-object-getownpropertydescriptors






_export(_export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = _toIobject(object);
    var getDesc = _objectGopd.f;
    var keys = _ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) _createProperty(result, key, desc);
    }
    return result;
  }
});

var _meta = createCommonjsModule(function (module) {
var META = _uid('meta');


var setDesc = _objectDp.f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !_fails(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!_has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!_has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};
});
_meta.KEY;
_meta.NEED;
_meta.fastKey;
_meta.getWeak;
_meta.onFreeze;

var _wks = createCommonjsModule(function (module) {
var store = _shared('wks');

var Symbol = _global.Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
};

$exports.store = store;
});

var def = _objectDp.f;

var TAG$1 = _wks('toStringTag');

var _setToStringTag = function (it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
};

var f$3 = _wks;

var _wksExt = {
	f: f$3
};

var defineProperty$3 = _objectDp.f;
var _wksDefine = function (name) {
  var $Symbol = _core.Symbol || (_core.Symbol = _global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$3($Symbol, name, { value: _wksExt.f(name) });
};

// 19.1.2.14 / 15.2.3.14 Object.keys(O)



var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

// all enumerable object keys, includes symbols



var _enumKeys = function (it) {
  var result = _objectKeys(it);
  var getSymbols = _objectGops.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = _objectPie.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

// 7.1.13 ToObject(argument)

var _toObject = function (it) {
  return Object(_defined(it));
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
  return O;
};

var document$1 = _global.document;
var _html = document$1 && document$1.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])



var IE_PROTO$1 = _sharedKey('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
  return createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO$1] = O;
  } else result = createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window

var gOPN$3 = _objectGopn.f;
var toString$1 = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN$3(it);
  } catch (e) {
    return windowNames.slice();
  }
};

var f$2 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN$3(_toIobject(it));
};

var _objectGopnExt = {
	f: f$2
};

// ECMAScript 6 symbols shim





var META = _meta.KEY;





















var gOPD$1 = _objectGopd.f;
var dP$3 = _objectDp.f;
var gOPN$2 = _objectGopnExt.f;
var $Symbol = _global.Symbol;
var $JSON = _global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = _wks('_hidden');
var TO_PRIMITIVE = _wks('toPrimitive');
var isEnum$1 = {}.propertyIsEnumerable;
var SymbolRegistry = _shared('symbol-registry');
var AllSymbols = _shared('symbols');
var OPSymbols = _shared('op-symbols');
var ObjectProto$1 = Object[PROTOTYPE];
var USE_NATIVE$1 = typeof $Symbol == 'function' && !!_objectGops.f;
var QObject = _global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = _descriptors && _fails(function () {
  return _objectCreate(dP$3({}, 'a', {
    get: function () { return dP$3(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD$1(ObjectProto$1, key);
  if (protoDesc) delete ObjectProto$1[key];
  dP$3(it, key, D);
  if (protoDesc && it !== ObjectProto$1) dP$3(ObjectProto$1, key, protoDesc);
} : dP$3;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol$1 = USE_NATIVE$1 && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
  _anObject(it);
  key = _toPrimitive(key, true);
  _anObject(D);
  if (_has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!_has(it, HIDDEN)) dP$3(it, HIDDEN, _propertyDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP$3(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  _anObject(it);
  var keys = _enumKeys(P = _toIobject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum$1.call(this, key = _toPrimitive(key, true));
  if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = _toIobject(it);
  key = _toPrimitive(key, true);
  if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
  var D = gOPD$1(it, key);
  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN$2(_toIobject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto$1;
  var names = gOPN$2(IS_OP ? OPSymbols : _toIobject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE$1) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto$1) $set.call(OPSymbols, value);
      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, _propertyDesc(1, value));
    };
    if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  _redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  _objectGopd.f = $getOwnPropertyDescriptor;
  _objectDp.f = $defineProperty;
  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
  _objectPie.f = $propertyIsEnumerable;
  _objectGops.f = $getOwnPropertySymbols;

  if (_descriptors && !_library) {
    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  _wksExt.f = function (name) {
    return wrap(_wks(name));
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j$2 = 0; es6Symbols.length > j$2;)_wks(es6Symbols[j$2++]);

for (var wellKnownSymbols = _objectKeys(_wks.store), k$1 = 0; wellKnownSymbols.length > k$1;) _wksDefine(wellKnownSymbols[k$1++]);

_export(_export.S + _export.F * !USE_NATIVE$1, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return _has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol$1(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

_export(_export.S + _export.F * !USE_NATIVE$1, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = _fails(function () { _objectGops.f(1); });

_export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return _objectGops.f(_toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && _export(_export.S + _export.F * (!USE_NATIVE$1 || _fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!_isObject(replacer) && it === undefined || isSymbol$1(it)) return; // IE8 returns string on undefined
    if (!_isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol$1(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
_setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
_setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
_setToStringTag(_global.JSON, 'JSON', true);

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function (TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _iterators = {};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () { return this; });

var _iterCreate = function (Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

var ITERATOR$4 = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR$4] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (typeof IteratorPrototype[ITERATOR$4] != 'function') _hide(IteratorPrototype, ITERATOR$4, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((BUGGY || VALUES_BUG || !proto[ITERATOR$4])) {
    _hide(proto, ITERATOR$4, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// call something on iterator step with safe closing on error

var _iterCall = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$3 = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function (it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$3] === it);
};

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

var _classof = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? _cof(O)
    // ES3 arguments fallback
    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

var ITERATOR$2 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$2]
    || it['@@iterator']
    || _iterators[_classof(it)];
};

var ITERATOR$1 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$1]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

var _iterDetect = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$1]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR$1] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

var _iterStep = function (done, value) {
  return { value: value, done: !!done };
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var ITERATOR = _wks('iterator');
var TO_STRING_TAG = _wks('toStringTag');
var ArrayValues = _iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = _objectKeys(DOMIterables), i$4 = 0; i$4 < collections.length; i$4++) {
  var NAME = collections[i$4];
  var explicit = DOMIterables[NAME];
  var Collection = _global[NAME];
  var proto$2 = Collection && Collection.prototype;
  var key$1;
  if (proto$2) {
    if (!proto$2[ITERATOR]) _hide(proto$2, ITERATOR, ArrayValues);
    if (!proto$2[TO_STRING_TAG]) _hide(proto$2, TO_STRING_TAG, NAME);
    _iterators[NAME] = ArrayValues;
    if (explicit) for (key$1 in es6_array_iterator) if (!proto$2[key$1]) _redefine(proto$2, key$1, es6_array_iterator[key$1], true);
  }
}

// 19.1.3.6 Object.prototype.toString()

var test$1 = {};
test$1[_wks('toStringTag')] = 'z';
if (test$1 + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + _classof(this) + ']';
  }, true);
}

// most Object methods by ES6 should accept primitives



var _objectSap = function (KEY, exec) {
  var fn = (_core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
};

// 19.1.2.14 Object.keys(O)



_objectSap('keys', function () {
  return function keys(it) {
    return _objectKeys(_toObject(it));
  };
});

// 19.1.2.1 Object.assign(target, source, ...)






var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

// 19.1.3.1 Object.assign(target, source)


_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose$1;

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var objectWithoutProperties = _objectWithoutProperties$1;

function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty$2 = _defineProperty$4;

var nprogress = createCommonjsModule(function (module, exports) {
(function(root, factory) {

  {
    module.exports = factory();
  }

})(commonjsGlobal, function() {
  var NProgress = {};

  NProgress.version = '0.2.0';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;

    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;

      $promise.always(function() {
        current--;
        if (current === 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });

      return this;
    };

  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});
});

/**
 * SSR Window 2.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: May 12, 2020
 */
/* eslint-disable no-param-reassign */
function isObject$5(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend$2(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject$5(src[key]) &&
            isObject$5(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend$2(target[key], src[key]);
        }
    });
}

var doc = typeof document !== 'undefined' ? document : {};
var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
extend$2(doc, ssrDocument);

var win = typeof window !== 'undefined' ? window : {};
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
};
extend$2(win, ssrWindow);

/**
 * Dom7 2.1.5
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2020, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: May 15, 2020
 */

class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $$1(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = doc.createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [doc.getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || doc).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === win || selector === doc) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$$1.fn = Dom7.prototype;
$$1.Class = Dom7;
$$1.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}

// Classes and attributes
function addClass$1(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass$1(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass$2(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass$1(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
function data$1(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition$1(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on$2(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($$1(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $$1(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($$1(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off$1(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new win.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = doc.createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd$1(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset$1() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = doc.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === win ? win.scrollY : el.scrollTop;
    const scrollLeft = el === win ? win.scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function styles() {
  if (this[0]) return win.getComputedStyle(this[0], null);
  return {};
}
function css$1(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $$1(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === doc) return el === doc;
  else if (selector === win) return el === win;

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function index$2() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq$1(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = doc.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($$1(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($$1(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $$1(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($$1(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $$1(unique(parents));
}
function closest$1(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find$2(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $$1(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove$1() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function add$1(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $$1(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}

/**
 * Swiper 5.4.5
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 16, 2020
 */

const Methods = {
  addClass: addClass$1,
  removeClass: removeClass$1,
  hasClass: hasClass$2,
  toggleClass: toggleClass$1,
  attr,
  removeAttr,
  data: data$1,
  transform,
  transition: transition$1,
  on: on$2,
  off: off$1,
  trigger,
  transitionEnd: transitionEnd$1,
  outerWidth,
  outerHeight,
  offset: offset$1,
  css: css$1,
  each,
  html,
  text,
  is,
  index: index$2,
  eq: eq$1,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest: closest$1,
  find: find$2,
  children,
  filter,
  remove: remove$1,
  add: add$1,
  styles,
};

Object.keys(Methods).forEach((methodName) => {
  $$1.fn[methodName] = $$1.fn[methodName] || Methods[methodName];
});

const Utils = {
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  now() {
    return Date.now();
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = win.getComputedStyle(el, null);

    if (win.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map((a) => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || win.location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter((paramsPart) => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  extend(...args) {
    const to = Object(args[0]);
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Support = (function Support() {
  return {
    touch: !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch)),

    pointerEvents: !!win.PointerEvent && ('maxTouchPoints' in win.navigator) && win.navigator.maxTouchPoints >= 0,

    observer: (function checkObserver() {
      return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        win.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in win;
    }()),
  };
}());

class SwiperClass {
  constructor(params = {}) {
    const self = this;
    self.params = params;

    // Events
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
      handler.apply(self, args);
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }

  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }

  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach((m) => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  function slidesForMargin(slideIndex) {
    if (!params.cssMode) return true;
    if (slideIndex === slides.length - 1) {
      return false;
    }
    return true;
  }

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        const columnsInGroup = groupIndex === 0
          ? params.slidesPerGroup
          : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;

        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide.css(
        `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
        (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
      );
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = win.getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal()
          ? slide.outerWidth(true)
          : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        if (swiper.isHorizontal()) {
          const width = parseFloat(slideStyles.getPropertyValue('width'));
          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
          }
        } else {
          const height = parseFloat(slideStyles.getPropertyValue('height'));
          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = height + marginTop + marginBottom;
          } else {
            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
          }
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });
      else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });
    } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each((index, slide) => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length) break;
        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress = (
      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
    ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                || (slideAfter > 1 && slideAfter <= swiper.size)
                || (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = $$1(swiper.visibleSlides);
}

function updateProgress (translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = $$1(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = $$1(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update$2 = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

function translateTo (translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;

  const {
    params,
    wrapperEl,
  } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
  else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
  else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: -newTranslate,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo,
};

function setTransition (duration, byController) {
  const swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex, params } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    let t = -translate;
    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        wrapperEl.scrollTo({
          [isH ? 'left' : 'top']: t,
          behavior: 'smooth',
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }
    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  slidesGrid.map((val) => normalize(val));

  snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach((snap) => {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }
  let prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if ((translate - prevSnap) <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $$1(doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = $$1(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append($$1(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend($$1(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;

  swiper.emit('beforeLoopFix');

  const {
    activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();

  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  swiper.emit('loopFix');
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide (index, slides) {
  const swiper = this;
  const { $wrapperEl, params, activeIndex } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides,
};

const Device = (function Device() {
  const platform = win.navigator.platform;
  const ua = win.navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!(win.cordova || win.phonegap),
    phonegap: !!(win.cordova || win.phonegap),
    electron: false,
  };

  const screenWidth = win.screen.width;
  const screenHeight = win.screen.height;

  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
  const edge = ua.indexOf('Edge/') >= 0;
  const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
  const windows = platform === 'Win32';
  const electron = ua.toLowerCase().indexOf('electron') >= 0;
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  if (!ipad
    && macos
    && Support.touch
    && (
      (screenWidth === 1024 && screenHeight === 1366) // Pro 12.9
      || (screenWidth === 834 && screenHeight === 1194) // Pro 11
      || (screenWidth === 834 && screenHeight === 1112) // Pro 10.5
      || (screenWidth === 768 && screenHeight === 1024) // other
    )
  ) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    macos = false;
  }

  device.ie = ie;
  device.edge = edge;
  device.firefox = firefox;

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.ipod = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Webview
  device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
    || (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
  device.webview = device.webView;
  device.standalone = device.webView;

  // Desktop
  device.desktop = !(device.ios || device.android) || electron;
  if (device.desktop) {
    device.electron = electron;
    device.macos = macos;
    device.windows = windows;
    if (device.macos) {
      device.os = 'macos';
    }
    if (device.windows) {
      device.os = 'windows';
    }
  }

  // Pixel Ratio
  device.pixelRatio = win.devicePixelRatio || 1;

  // Export object
  return device;
}());

function onTouchStart$1 (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const $targetEl = $$1(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (
    edgeSwipeDetection
    && ((startX <= edgeSwipeThreshold)
    || (startX >= win.screen.width - edgeSwipeThreshold))
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if ($targetEl.is(data.formElements)) preventDefault = false;
    if (
      doc.activeElement
      && $$1(doc.activeElement).is(data.formElements)
      && doc.activeElement !== $targetEl[0]
    ) {
      doc.activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type !== 'touchmove') return;
  const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && doc.activeElement) {
    if (e.target === doc.activeElement && $$1(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd$1 (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
    const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  swiper.updateSlidesClasses();
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick$1 (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll () {
  const swiper = this;
  const { wrapperEl, rtlTranslate } = swiper;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === -0) swiper.translate = 0;

  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();

  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}

let dummyEventAttached = false;
function dummyEventListener() {}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  swiper.onTouchStart = onTouchStart$1.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd$1.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick$1.bind(swiper);

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
      if (!dummyEventAttached) {
        doc.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      doc.addEventListener('mousemove', swiper.onTouchMove, capture);
      doc.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const capture = !!params.nested;

  // Touch Events
  if (!Support.touch && Support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (Support.touch) {
      const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }
    if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
      doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
}

var events$1 = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params, $el,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach((param) => {
        const paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;
        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = params.slidesPerColumn > 1;
    const isMultiRow = breakpointParams.slidesPerColumn > 1;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(`${params.containerModifierClass}multirow`);
      if (breakpointParams.slidesPerColumnFill === 'column') {
        $el.addClass(`${params.containerModifierClass}multirow-column`);
      }
    }

    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    Utils.extend(swiper.params, breakpointParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}

function getBreakpoint (breakpoints) {
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;

  const points = Object.keys(breakpoints).map((point) => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = win.innerHeight * minRatio;
      return { value, point };
    }
    return { value: point, point };
  });

  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const { point, value } = points[i];
    if (value <= win.innerWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = { setBreakpoint, getBreakpoint };

function addClasses$1 () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push('initialized');
  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
    if (params.slidesPerColumnFill === 'column') {
      suffixes.push('multirow-column');
    }
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }

  if (params.cssMode) {
    suffixes.push('css-mode');
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses$1 () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes$1 = { addClasses: addClasses$1, removeClasses: removeClasses$1 };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  const isPicture = $$1(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new win.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const params = swiper.params;
  const wasLocked = swiper.isLocked;
  const lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults$2 = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  //
  preventInteractionOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

/* eslint no-param-reassign: "off" */

const prototypes = {
  update: update$2,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  manipulation,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes: classes$1,
  images,
};

const extendedDefaults = {};

class Swiper extends SwiperClass {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper.prototype[protoMethod]) {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object'
          && !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults$2);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = $$1;

    // Find el
    const $el = $$1(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    let $wrapperEl;
    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
      $wrapperEl = $$1(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));
      // Children needs to return slot items
      $wrapperEl.children = (options) => $el.children(options);
    } else {
      $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
    }
    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: $$1(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video, label',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }

  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
      return swiper;
    }

    swiper.$el
      .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)
      .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

    swiper.params.direction = newDirection;

    swiper.slides.each((slideIndex, slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });

    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();

    return swiper;
  }

  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }

  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults$2;
  }

  static get Class() {
    return SwiperClass;
  }

  static get $() {
    return $$1;
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

const Browser = (function Browser() {
  function isSafari() {
    const ua = win.navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isEdge: !!win.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
  };
}());

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      win.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      win.removeEventListener('resize', swiper.resize.resizeHandler);
      win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer$1 = {
  func: win.MutationObserver || win.WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer$1.func;
    const observer = new ObserverFunc((mutations) => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (win.requestAnimationFrame) {
        win.requestAnimationFrame(observerUpdate);
      } else {
        win.setTimeout(observerUpdate, 0);
      }
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer$1.init.bind(swiper),
        attach: Observer$1.attach.bind(swiper),
        destroy: Observer$1.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
      slidesBefore = slidesPerGroup + addSlidesAfter;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? $$1(params.renderSlide.call(swiper, slide, index))
      : $$1(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slides) {
    const swiper = this;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    swiper.virtual.update(true);
  },
  prependSlide(slides) {
    const swiper = this;
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
        if (cachedElIndex) {
          $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide(slidesIndexes) {
    const swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides() {
    const swiper = this;
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      addSlidesBefore: 0,
      addSlidesAfter: 0,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        removeSlide: Virtual.removeSlide.bind(swiper),
        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    const { rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowWidth = win.innerWidth;
      const windowHeight = win.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= 0 && point[0] <= windowWidth
          && point[1] >= 0 && point[1] <= windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) swiper.slideNext();
      if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    $$1(doc).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    $$1(doc).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in doc;

  if (!isSupported) {
    const element = doc.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported
    && doc.implementation
    && doc.implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && doc.implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  lastEventBeforeSnap: undefined,
  recentWheelEvents: [],
  event() {
    if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  },
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handleMouseEnter() {
    const swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave() {
    const swiper = this;
    swiper.mouseEntered = false;
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;

    if (swiper.params.cssMode) {
      e.preventDefault();
    }

    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $$1(swiper.params.mousewheel.eventsTarged);
    }
    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;

    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;

    const data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: Utils.now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event,
      };

      // Keep the most recent events
      const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
      const { lastEventBeforeSnap } = swiper.mousewheel;
      const ignoreWheelEvents = lastEventBeforeSnap
        && newEvent.time < lastEventBeforeSnap.time + 500
        && newEvent.delta <= lastEventBeforeSnap.delta
        && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = undefined;

        if (swiper.params.loop) {
          swiper.loopFix();
        }
        let position = swiper.getTranslate() + (delta * params.sensitivity);
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;

        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();

        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
          swiper.updateSlidesClasses();
        }

        if (swiper.params.freeModeSticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = undefined;
          const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15
              && newEvent.time - firstEvent.time < 500
              && firstEvent.delta - newEvent.delta >= 1
              && newEvent.delta <= 6
          ) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }
          if (!swiper.mousewheel.timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            swiper.mousewheel.timeout = Utils.nextTick(() => {
              const snapToThreshold = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) swiper.emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  animateSlider(newEvent) {
    const swiper = this;
    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
    // Return false as a default
    return false;
  },
  releaseScroll(newEvent) {
    const swiper = this;
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  },
  enable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $$1(swiper.params.mousewheel.eventsTarged);
    }
    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    const event = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
      return true;
    }
    if (!event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = $$1(swiper.params.mousewheel.eventsTarged);
    }
    target.off(event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
        animateSlider: Mousewheel.animateSlider.bind(swiper),
        releaseScroll: Mousewheel.releaseScroll.bind(swiper),
        lastScrollTime: Utils.now(),
        lastEventBeforeSnap: undefined,
        recentWheelEvents: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
        swiper.mousewheel.disable();
      }
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.params.cssMode) {
        swiper.mousewheel.enable();
      }
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = $$1(params.nextEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.nextEl === 'string'
        && $nextEl.length > 1
        && swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = $$1(params.prevEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.prevEl === 'string'
        && $prevEl.length > 1
        && swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
        onNextClick: Navigation.onNextClick.bind(swiper),
        onPrevClick: Navigation.onPrevClick.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick
        && !$$1(e.target).is($prevEl)
        && !$$1(e.target).is($nextEl)
      ) {
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          swiper.emit('navigationShow', swiper);
        } else {
          swiper.emit('navigationHide', swiper);
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = $$1(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }
              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              $firstDisplayedBullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
              $lastDisplayedBullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          } else {
            $firstDisplayedBullet
              .prev()
              .addClass(`${params.bulletActiveClass}-prev`)
              .prev()
              .addClass(`${params.bulletActiveClass}-prev-prev`);
            $lastDisplayedBullet
              .next()
              .addClass(`${params.bulletActiveClass}-next`)
              .next()
              .addClass(`${params.bulletActiveClass}-next-next`);
          }
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>`
        + ' / '
        + `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = $$1(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements
      && typeof params.el === 'string'
      && $el.length > 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = $$1(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el
        && swiper.params.pagination.hideOnClick
        && swiper.pagination.$el.length > 0
        && !$$1(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          swiper.emit('paginationShow', swiper);
        } else {
          swiper.emit('paginationHide', swiper);
        }
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  getPointerPosition(e) {
    const swiper = this;
    if (swiper.isHorizontal()) {
      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
    }
    return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const {
      $el,
      dragSize,
      trackSize,
      dragStartPos,
    } = scrollbar;

    let positionRatio;
    positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
      - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
      ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', 'none');
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css('scroll-snap-type', '');
      $wrapperEl.transition('');
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = $$1(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = $$1(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = $$1(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      $$1(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
      .each((index, parallaxEl) => {
        const $parallaxEl = $$1(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = $$1(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal()
        && (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } if (
        !swiper.isHorizontal()
        && (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      }
      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform('translate3d(0,0,0)');
      }

      zoom.scale = 1;
      zoom.currentScale = 1;

      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
    const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    const slideSelector = `.${swiper.params.slideClass}`;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
      }
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };

    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });

    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }
        scale = value;
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = $$1(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');
      const $pictureEl = $imageEl.parent('picture');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if ($pictureEl.length) {
            $pictureEl.children('source').each((sourceIndex, sourceEl) => {
              const $source = $$1(sourceEl);

              if ($source.attr('data-srcset')) {
                $source.attr('srcset', $source.attr('data-srcset'));
                $source.removeAttr('data-srcset');
              }
            });
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }

    function slideIndex(slideEl) {
      if (isVirtual) {
        return $$1(slideEl).attr('data-swiper-slide-index');
      }
      return $$1(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? $$1(slideEl).attr('data-swiper-slide-index') : $$1(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy.load.bind(swiper),
        loadInSlide: Lazy.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.cssMode) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2âx1) Ã (y3ây1)) Ã· (x3âx1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop
        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          Utils.nextTick(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  makeElNotFocusable($el) {
    $el.attr('tabIndex', '-1');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = $$1(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop || !swiper.navigation) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
        swiper.a11y.makeElNotFocusable($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
        swiper.a11y.makeElFocusable($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
        swiper.a11y.makeElNotFocusable($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
        swiper.a11y.makeElFocusable($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = $$1(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: $$1(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const History = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!win.history || !win.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      win.addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      win.removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = win.location.pathname.slice(1).split('/').filter((part) => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index);
    let value = History.slugify(slide.attr('data-history'));
    if (!win.location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = win.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      win.history.replaceState({ value }, null, value);
    } else {
      win.history.pushState({ value }, null, value);
    }
  },
  slugify(text) {
    return text.toString()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$1 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History.init.bind(swiper),
        setHistory: History.setHistory.bind(swiper),
        setHistoryPopState: History.setHistoryPopState.bind(swiper),
        scrollToSlide: History.scrollToSlide.bind(swiper),
        destroy: History.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.history.initialized && swiper.params.cssMode) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    swiper.emit('hashChange');
    const newHash = doc.location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
      win.history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
      swiper.emit('hashSet');
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      doc.location.hash = hash || '';
      swiper.emit('hashSet');
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = doc.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      $$1(win).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      $$1(win).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
    slideChange() {
      const swiper = this;
      if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

/* eslint no-underscore-dangle: "off" */

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onVisibilityChange() {
          if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
            swiper.autoplay.pause();
          }
          if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
          }
        },
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd() {
      const swiper = this;
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade
        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $$1('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = $$1('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = $$1(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = $$1(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = ((parseFloat(params.stretch) / 100) * slideSize);
      }
      let translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
      let translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;

      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = $$1(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Support.pointerEvents || Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

const Thumbs = {
  init() {
    const swiper = this;
    const { thumbs: thumbsParams } = swiper.params;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Utils.extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
      Utils.extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
    } else if (Utils.isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      }));
      swiper.thumbs.swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
  },
  onThumbClick() {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && $$1(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt($$1(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
      else slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  },
  update(initial) {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
      ? thumbsSwiper.slidesPerViewDynamic()
      : thumbsSwiper.params.slidesPerView;

    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          // eslint-disable-next-line
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        // Find actual thumbs index to slide to
        const prevThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        const nextThumbsIndex = thumbsSwiper.slides
          .eq(currentThumbsIndex)
          .nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
          .index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
        else newThumbsIndex = prevThumbsIndex;
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }

      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }

    thumbsToActivate = Math.floor(thumbsToActivate);

    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  },
};
var Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      thumbs: {
        swiper: null,
        init: Thumbs.init.bind(swiper),
        update: Thumbs.update.bind(swiper),
        onThumbClick: Thumbs.onThumbClick.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      const { thumbs } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition(duration) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    },
  },
};

// Swiper Class

const components = [
  Device$1,
  Support$1,
  Browser$1,
  Resize,
  Observer$1$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$1,
  Controller$1,
  A11y,
  History$1,
  HashNavigation$1,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
  Thumbs$1
];

if (typeof Swiper.use === 'undefined') {
  Swiper.use = Swiper.Class.use;
  Swiper.installModule = Swiper.Class.installModule;
}

Swiper.use(components);

var swiper_esm_bundle = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': Swiper
});

var require$$0$1 = getCjsExportFromNamespace(swiper_esm_bundle);

var vueAwesomeSwiper = createCommonjsModule(function (module, exports) {
/*!
 * vue-awesome-swiper v4.1.1
 * Copyright (c) Surmon. All rights reserved.
 * Released under the MIT License.
 * Surmon <https://github.com/surmon-china>
 */

(function(g,f){f(exports,require$$0$1,Vue);}(commonjsGlobal,(function(exports, SwiperClass, Vue){SwiperClass=SwiperClass&&Object.prototype.hasOwnProperty.call(SwiperClass,'default')?SwiperClass['default']:SwiperClass;Vue=Vue&&Object.prototype.hasOwnProperty.call(Vue,'default')?Vue['default']:Vue;/**
 * @file vue-awesome-swiper
 * @module constants
 * @author Surmon <https://github.com/surmon-china>
 */
var CoreNames;
(function (CoreNames) {
    CoreNames["SwiperComponent"] = "Swiper";
    CoreNames["SwiperSlideComponent"] = "SwiperSlide";
    CoreNames["SwiperDirective"] = "swiper";
    CoreNames["SwiperInstance"] = "$swiper";
})(CoreNames || (CoreNames = {}));
var DEFAULT_CLASSES = Object.freeze({
    containerClass: 'swiper-container',
    wrapperClass: 'swiper-wrapper',
    slideClass: 'swiper-slide'
});
var ComponentEvents;
(function (ComponentEvents) {
    ComponentEvents["Ready"] = "ready";
    ComponentEvents["ClickSlide"] = "clickSlide";
})(ComponentEvents || (ComponentEvents = {}));
var ComponentPropNames;
(function (ComponentPropNames) {
    ComponentPropNames["AutoUpdate"] = "autoUpdate";
    ComponentPropNames["AutoDestroy"] = "autoDestroy";
    ComponentPropNames["DeleteInstanceOnDestroy"] = "deleteInstanceOnDestroy";
    ComponentPropNames["CleanupStylesOnDestroy"] = "cleanupStylesOnDestroy";
})(ComponentPropNames || (ComponentPropNames = {}));
// https://swiperjs.com/api/#events
var SWIPER_EVENTS = [
    'init',
    'beforeDestroy',
    'slideChange',
    'slideChangeTransitionStart',
    'slideChangeTransitionEnd',
    'slideNextTransitionStart',
    'slideNextTransitionEnd',
    'slidePrevTransitionStart',
    'slidePrevTransitionEnd',
    'transitionStart',
    'transitionEnd',
    'touchStart',
    'touchMove',
    'touchMoveOpposite',
    'sliderMove',
    'touchEnd',
    'click',
    'tap',
    'doubleTap',
    'imagesReady',
    'progress',
    'reachBeginning',
    'reachEnd',
    'fromEdge',
    'setTranslate',
    'setTransition',
    'resize',
    'observerUpdate',
    'beforeLoopFix',
    'loopFix'
];/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}/**
 * @file vue-awesome-swiper
 * @module utils
 * @author Surmon <https://github.com/surmon-china>
 */
var kebabcase = function (string) {
    return string
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .replace(/\s+/g, '-')
        .toLowerCase();
};/**
 * @file vue-awesome-swiper
 * @module event
 * @author Surmon <https://github.com/surmon-china>
 */
var handleClickSlideEvent = function (swiper, event, emit) {
    var _a, _b, _c;
    if (swiper && !(swiper.destroyed)) {
        var eventPath = ((_a = event.composedPath) === null || _a === void 0 ? void 0 : _a.call(event)) || event.path;
        if ((event === null || event === void 0 ? void 0 : event.target) && eventPath) {
            var slides_1 = Array.from(swiper.slides);
            var paths = Array.from(eventPath);
            // Click slide || slide[children]
            if (slides_1.includes(event.target) || paths.some(function (item) { return slides_1.includes(item); })) {
                var clickedIndex = swiper.clickedIndex;
                var reallyIndex = Number((_c = (_b = swiper.clickedSlide) === null || _b === void 0 ? void 0 : _b.dataset) === null || _c === void 0 ? void 0 : _c.swiperSlideIndex);
                var reallyIndexValue = Number.isInteger(reallyIndex) ? reallyIndex : null;
                emit(ComponentEvents.ClickSlide, clickedIndex, reallyIndexValue);
                emit(kebabcase(ComponentEvents.ClickSlide), clickedIndex, reallyIndexValue);
            }
        }
    }
};
var bindSwiperEvents = function (swiper, emit) {
    SWIPER_EVENTS.forEach(function (eventName) {
        swiper.on(eventName, function () {
            var arguments$1 = arguments;

            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments$1[_i];
            }
            emit.apply(void 0, __spreadArrays([eventName], args));
            var kebabcaseName = kebabcase(eventName);
            if (kebabcaseName !== eventName) {
                emit.apply(void 0, __spreadArrays([kebabcaseName], args));
            }
        });
    });
};/**
 * @file vue-awesome-swiper
 * @module directive
 * @author Surmon <https://github.com/surmon-china>
 */
var INSTANCE_NAME_KEY = 'instanceName';
function getDirective(SwiperClass, globalOptions) {
    var getStandardisedOptionByAttrs = function (vnode, key) {
        var _a, _b, _c, _d;
        var value = (_b = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[key];
        return value !== undefined
            ? value
            : (_d = (_c = vnode.data) === null || _c === void 0 ? void 0 : _c.attrs) === null || _d === void 0 ? void 0 : _d[kebabcase(key)];
    };
    // Get swiper instace name in directive
    var getSwiperInstanceName = function (element, binding, vnode) {
        return (binding.arg ||
            getStandardisedOptionByAttrs(vnode, INSTANCE_NAME_KEY) ||
            element.id ||
            CoreNames.SwiperInstance);
    };
    var getSwiperInstance = function (element, binding, vnode) {
        var instanceName = getSwiperInstanceName(element, binding, vnode);
        return vnode.context[instanceName] || null;
    };
    var getSwipeOptions = function (binding) {
        return binding.value || globalOptions;
    };
    var getBooleanValueByInput = function (input) {
        return [true, undefined, null, ''].includes(input);
    };
    // Emit event in Vue directive
    var getEventEmiter = function (vnode) {
        var _a, _b;
        var handlers = ((_a = vnode.data) === null || _a === void 0 ? void 0 : _a.on) || ((_b = vnode.componentOptions) === null || _b === void 0 ? void 0 : _b.listeners);
        return function (name) {
            var arguments$1 = arguments;

            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments$1[_i];
            }
            var _a;
            var handle = (_a = handlers) === null || _a === void 0 ? void 0 : _a[name];
            if (handle) {
                handle.fns.apply(handle, args);
            }
        };
    };
    return {
        // Init
        bind: function (element, binding, vnode) {
            // auto class name
            if (element.className.indexOf(DEFAULT_CLASSES.containerClass) === -1) {
                element.className += ((element.className ? ' ' : '') + DEFAULT_CLASSES.containerClass);
            }
            // bind click event
            element.addEventListener('click', function (event) {
                var emitEvent = getEventEmiter(vnode);
                var swiper = getSwiperInstance(element, binding, vnode);
                handleClickSlideEvent(swiper, event, emitEvent);
            });
        },
        // DOM inserted
        inserted: function (element, binding, vnode) {
            var context = vnode.context;
            var swiperOptions = getSwipeOptions(binding);
            var instanceName = getSwiperInstanceName(element, binding, vnode);
            var emitEvent = getEventEmiter(vnode);
            var vueContext = context;
            var swiper = vueContext === null || vueContext === void 0 ? void 0 : vueContext[instanceName];
            // Swiper will destroy but not delete instance, when used <keep-alive>
            if (!swiper || swiper.destroyed) {
                swiper = new SwiperClass(element, swiperOptions);
                vueContext[instanceName] = swiper;
                bindSwiperEvents(swiper, emitEvent);
                emitEvent(ComponentEvents.Ready, swiper);
                // MARK: Reinstance when the nexttick with <keep-alive>
                // Vue.nextTick(instancing) | setTimeout(instancing)
            }
        },
        // On options changed or DOM updated
        componentUpdated: function (element, binding, vnode) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            var autoUpdate = getStandardisedOptionByAttrs(vnode, ComponentPropNames.AutoUpdate);
            if (getBooleanValueByInput(autoUpdate)) {
                var swiper = getSwiperInstance(element, binding, vnode);
                if (swiper) {
                    var swiperOptions = getSwipeOptions(binding);
                    var isLoop = swiperOptions.loop;
                    if (isLoop) {
                        (_b = (_a = swiper) === null || _a === void 0 ? void 0 : _a.loopDestroy) === null || _b === void 0 ? void 0 : _b.call(_a);
                    }
                    (_c = swiper === null || swiper === void 0 ? void 0 : swiper.update) === null || _c === void 0 ? void 0 : _c.call(swiper);
                    (_e = (_d = swiper.navigation) === null || _d === void 0 ? void 0 : _d.update) === null || _e === void 0 ? void 0 : _e.call(_d);
                    (_g = (_f = swiper.pagination) === null || _f === void 0 ? void 0 : _f.render) === null || _g === void 0 ? void 0 : _g.call(_f);
                    (_j = (_h = swiper.pagination) === null || _h === void 0 ? void 0 : _h.update) === null || _j === void 0 ? void 0 : _j.call(_h);
                    if (isLoop) {
                        (_l = (_k = swiper) === null || _k === void 0 ? void 0 : _k.loopCreate) === null || _l === void 0 ? void 0 : _l.call(_k);
                        (_m = swiper === null || swiper === void 0 ? void 0 : swiper.update) === null || _m === void 0 ? void 0 : _m.call(swiper);
                    }
                }
            }
        },
        // Destroy this directive
        unbind: function (element, binding, vnode) {
            var _a;
            var autoDestroy = getStandardisedOptionByAttrs(vnode, ComponentPropNames.AutoDestroy);
            if (getBooleanValueByInput(autoDestroy)) {
                var swiper = getSwiperInstance(element, binding, vnode);
                if (swiper && swiper.initialized) {
                    (_a = swiper === null || swiper === void 0 ? void 0 : swiper.destroy) === null || _a === void 0 ? void 0 : _a.call(swiper, getBooleanValueByInput(getStandardisedOptionByAttrs(vnode, ComponentPropNames.DeleteInstanceOnDestroy)), getBooleanValueByInput(getStandardisedOptionByAttrs(vnode, ComponentPropNames.CleanupStylesOnDestroy)));
                }
            }
        }
    };
}/**
 * @file vue-awesome-swiper
 * @module SwiperComponent
 * @author Surmon <https://github.com/surmon-china>
 */
var SlotNames;
(function (SlotNames) {
    SlotNames["ParallaxBg"] = "parallax-bg";
    SlotNames["Pagination"] = "pagination";
    SlotNames["Scrollbar"] = "scrollbar";
    SlotNames["PrevButton"] = "button-prev";
    SlotNames["NextButton"] = "button-next";
})(SlotNames || (SlotNames = {}));
function getSwiperComponent(SwiperClass) {
    var _a;
    return Vue.extend({
        name: CoreNames.SwiperComponent,
        props: (_a = {
                defaultOptions: {
                    type: Object,
                    required: false,
                    default: function () { return ({}); }
                },
                // eslint-disable-next-line vue/require-default-prop
                options: {
                    type: Object,
                    required: false
                }
            },
            _a[ComponentPropNames.AutoUpdate] = {
                type: Boolean,
                default: true
            },
            // https://github.com/surmon-china/vue-awesome-swiper/pull/550/files
            _a[ComponentPropNames.AutoDestroy] = {
                type: Boolean,
                default: true
            },
            // https://github.com/surmon-china/vue-awesome-swiper/pull/388
            _a[ComponentPropNames.DeleteInstanceOnDestroy] = {
                type: Boolean,
                required: false,
                default: true
            },
            _a[ComponentPropNames.CleanupStylesOnDestroy] = {
                type: Boolean,
                required: false,
                default: true
            },
            _a),
        data: function () {
            var _a;
            return _a = {},
                _a[CoreNames.SwiperInstance] = null,
                _a;
        },
        computed: {
            swiperInstance: {
                cache: false,
                set: function (swiper) {
                    this[CoreNames.SwiperInstance] = swiper;
                },
                get: function () {
                    return this[CoreNames.SwiperInstance];
                }
            },
            swiperOptions: function () {
                return this.options || this.defaultOptions;
            },
            wrapperClass: function () {
                return this.swiperOptions.wrapperClass || DEFAULT_CLASSES.wrapperClass;
            }
        },
        methods: {
            // Feature: click event
            handleSwiperClick: function (event) {
                handleClickSlideEvent(this.swiperInstance, event, this.$emit.bind(this));
            },
            autoReLoopSwiper: function () {
                var _a, _b;
                if (this.swiperInstance && this.swiperOptions.loop) {
                    // https://github.com/surmon-china/vue-awesome-swiper/issues/593
                    // https://github.com/surmon-china/vue-awesome-swiper/issues/544
                    // https://github.com/surmon-china/vue-awesome-swiper/pull/545/files
                    var swiper = this.swiperInstance;
                    (_a = swiper === null || swiper === void 0 ? void 0 : swiper.loopDestroy) === null || _a === void 0 ? void 0 : _a.call(swiper);
                    (_b = swiper === null || swiper === void 0 ? void 0 : swiper.loopCreate) === null || _b === void 0 ? void 0 : _b.call(swiper);
                }
            },
            updateSwiper: function () {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                if (this[ComponentPropNames.AutoUpdate] && this.swiperInstance) {
                    this.autoReLoopSwiper();
                    (_b = (_a = this.swiperInstance) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b.call(_a);
                    (_d = (_c = this.swiperInstance.navigation) === null || _c === void 0 ? void 0 : _c.update) === null || _d === void 0 ? void 0 : _d.call(_c);
                    (_f = (_e = this.swiperInstance.pagination) === null || _e === void 0 ? void 0 : _e.render) === null || _f === void 0 ? void 0 : _f.call(_e);
                    (_h = (_g = this.swiperInstance.pagination) === null || _g === void 0 ? void 0 : _g.update) === null || _h === void 0 ? void 0 : _h.call(_g);
                }
            },
            destroySwiper: function () {
                var _a, _b;
                if (this[ComponentPropNames.AutoDestroy] && this.swiperInstance) {
                    // https://github.com/surmon-china/vue-awesome-swiper/pull/341
                    // https://github.com/surmon-china/vue-awesome-swiper/issues/340
                    if (this.swiperInstance.initialized) {
                        (_b = (_a = this.swiperInstance) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, this[ComponentPropNames.DeleteInstanceOnDestroy], this[ComponentPropNames.CleanupStylesOnDestroy]);
                    }
                }
            },
            initSwiper: function () {
                this.swiperInstance = new SwiperClass(this.$el, this.swiperOptions);
                bindSwiperEvents(this.swiperInstance, this.$emit.bind(this));
                this.$emit(ComponentEvents.Ready, this.swiperInstance);
            }
        },
        mounted: function () {
            if (!this.swiperInstance) {
                this.initSwiper();
            }
        },
        // Update swiper when the parent component activated with `keep-alive`.
        activated: function () {
            this.updateSwiper();
        },
        updated: function () {
            this.updateSwiper();
        },
        beforeDestroy: function () {
            // https://github.com/surmon-china/vue-awesome-swiper/commit/2924a9d4d3d1cf51c0d46076410b1f804b2b8a43#diff-7f4e0261ac562c0f354cb91a1ca8864f
            this.$nextTick(this.destroySwiper);
        },
        render: function (createElement) {
            return createElement('div', {
                staticClass: DEFAULT_CLASSES.containerClass,
                on: {
                    click: this.handleSwiperClick
                }
            }, [
                this.$slots[SlotNames.ParallaxBg],
                createElement('div', {
                    class: this.wrapperClass
                }, this.$slots.default),
                this.$slots[SlotNames.Pagination],
                this.$slots[SlotNames.PrevButton],
                this.$slots[SlotNames.NextButton],
                this.$slots[SlotNames.Scrollbar]
            ]);
        }
    });
}/**
 * @file vue-awesome-swiper
 * @module SwiperSlideComponent
 * @author Surmon <https://github.com/surmon-china>
 */
var SwiperSlideComponent = Vue.extend({
    name: CoreNames.SwiperSlideComponent,
    computed: {
        slideClass: function () {
            var _a, _b;
            return ((_b = (_a = this.$parent) === null || _a === void 0 ? void 0 : _a.swiperOptions) === null || _b === void 0 ? void 0 : _b.slideClass) || DEFAULT_CLASSES.slideClass;
        }
    },
    methods: {
        update: function () {
            var _a;
            var parent = this.$parent;
            // https://github.com/surmon-china/vue-awesome-swiper/issues/632
            if (parent[ComponentPropNames.AutoUpdate]) {
                (_a = parent === null || parent === void 0 ? void 0 : parent.swiperInstance) === null || _a === void 0 ? void 0 : _a.update();
            }
        }
    },
    mounted: function () {
        this.update();
    },
    updated: function () {
        this.update();
    },
    render: function (createElement) {
        return createElement('div', {
            class: this.slideClass
        }, this.$slots.default);
    }
});/**
 * @file vue-awesome-swiper
 * @module exporter
 * @author Surmon <https://github.com/surmon-china>
 */
var getInstaller = function (SwiperClass) {
    var install = function (Vue, globalOptions) {
        if (install.installed)
            { return; }
        var SwiperComponent = getSwiperComponent(SwiperClass);
        if (globalOptions) {
            SwiperComponent.options.props.defaultOptions.default = function () { return globalOptions; };
        }
        Vue.component(CoreNames.SwiperComponent, SwiperComponent);
        Vue.component(CoreNames.SwiperSlideComponent, SwiperSlideComponent);
        Vue.directive(CoreNames.SwiperDirective, getDirective(SwiperClass, globalOptions));
        install.installed = true;
    };
    return install;
};
function exporter(SwiperClass) {
    var _a;
    return _a = {
            version: '4.1.1',
            install: getInstaller(SwiperClass),
            directive: getDirective(SwiperClass)
        },
        _a[CoreNames.SwiperComponent] = getSwiperComponent(SwiperClass),
        _a[CoreNames.SwiperSlideComponent] = SwiperSlideComponent,
        _a;
}/**
 * @file vue-awesome-swiper
 * @module default-export
 * @author Surmon <https://github.com/surmon-china>
 */
var VueAwesomeSwiper = exporter(SwiperClass);
var version = VueAwesomeSwiper.version;
var install = VueAwesomeSwiper.install;
var directive = VueAwesomeSwiper.directive;
var Swiper = VueAwesomeSwiper.Swiper;
var SwiperSlide = VueAwesomeSwiper.SwiperSlide;exports.Swiper=Swiper;exports.SwiperSlide=SwiperSlide;exports.default=VueAwesomeSwiper;exports.directive=directive;exports.install=install;exports.version=version;Object.defineProperty(exports,'__esModule',{value:true});})));
});

var VueAwesomeSwiper = unwrapExports(vueAwesomeSwiper);

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
var throttle$2 = function ( delay, noTrailing, callback, debounceMode ) {

	// After wrapper has stopped being called, this timeout ensures that
	// `callback` is executed at the proper times in `throttle` and `end`
	// debounce modes.
	var timeoutID;

	// Keep track of the last time `callback` was executed.
	var lastExec = 0;

	// `noTrailing` defaults to falsy.
	if ( typeof noTrailing !== 'boolean' ) {
		debounceMode = callback;
		callback = noTrailing;
		noTrailing = undefined;
	}

	// The `wrapper` function encapsulates all of the throttling / debouncing
	// functionality and when executed will limit the rate at which `callback`
	// is executed.
	function wrapper () {

		var self = this;
		var elapsed = Number(new Date()) - lastExec;
		var args = arguments;

		// Execute `callback` and update the `lastExec` timestamp.
		function exec () {
			lastExec = Number(new Date());
			callback.apply(self, args);
		}

		// If `debounceMode` is true (at begin) this is used to clear the flag
		// to allow future `callback` executions.
		function clear () {
			timeoutID = undefined;
		}

		if ( debounceMode && !timeoutID ) {
			// Since `wrapper` is being called for the first time and
			// `debounceMode` is true (at begin), execute `callback`.
			exec();
		}

		// Clear any existing timeout.
		if ( timeoutID ) {
			clearTimeout(timeoutID);
		}

		if ( debounceMode === undefined && elapsed > delay ) {
			// In throttle mode, if `delay` time has been exceeded, execute
			// `callback`.
			exec();

		} else if ( noTrailing !== true ) {
			// In trailing throttle mode, since `delay` time has not been
			// exceeded, schedule `callback` to execute `delay` ms after most
			// recent execution.
			//
			// If `debounceMode` is true (at begin), schedule `clear` to execute
			// after `delay` ms.
			//
			// If `debounceMode` is false (at end), schedule `callback` to
			// execute after `delay` ms.
			timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		}

	}

	// Return the wrapper function.
	return wrapper;

};

/* eslint-disable no-undefined */



/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */
var debounce$2 = function ( delay, atBegin, callback ) {
	return callback === undefined ? throttle$2(delay, atBegin, false) : throttle$2(delay, callback, atBegin !== false);
};

var dom = createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.isInContainer = exports.getScrollContainer = exports.isScroll = exports.getStyle = exports.once = exports.off = exports.on = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /* istanbul ignore next */

exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.setStyle = setStyle;



var _vue2 = _interopRequireDefault(Vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isServer = _vue2.default.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer ? 0 : Number(document.documentMode);

/* istanbul ignore next */
var trim = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */
var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};

/* istanbul ignore next */
var on = exports.on = function () {
  if (!isServer && document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
var off = exports.off = function () {
  if (!isServer && document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();

/* istanbul ignore next */
exports.once = function once(el, event, fn) {
  var listener = function listener() {
    if (fn) {
      fn.apply(this, arguments);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};

/* istanbul ignore next */
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}
/* istanbul ignore next */
function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }
  if (!el.classList) {
    el.setAttribute('class', curClass);
  }
}
/* istanbul ignore next */
function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }
  if (!el.classList) {
    el.setAttribute('class', trim(curClass));
  }
}
/* istanbul ignore next */
var getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'styleFloat';
  }
  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }
      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);
  if (styleName === 'float') {
    styleName = 'cssFloat';
  }
  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};

/* istanbul ignore next */
function setStyle(element, styleName, value) {
  if (!element || !styleName) return;

  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {
    for (var prop in styleName) {
      if (styleName.hasOwnProperty(prop)) {
        setStyle(element, prop, styleName[prop]);
      }
    }
  } else {
    styleName = camelCase(styleName);
    if (styleName === 'opacity' && ieVersion < 9) {
      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
    } else {
      element.style[styleName] = value;
    }
  }
}
var isScroll = exports.isScroll = function isScroll(el, vertical) {
  if (isServer) return;

  var determinedDirection = vertical !== null && vertical !== undefined;
  var overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');

  return overflow.match(/(scroll|auto|overlay)/);
};

exports.getScrollContainer = function getScrollContainer(el, vertical) {
  if (isServer) return;

  var parent = el;
  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }
    if (isScroll(parent, vertical)) {
      return parent;
    }
    parent = parent.parentNode;
  }

  return parent;
};

exports.isInContainer = function isInContainer(el, container) {
  if (isServer || !el || !container) return false;

  var elRect = el.getBoundingClientRect();
  var containerRect = void 0;

  if ([window, document, document.documentElement, null, undefined].includes(container)) {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  } else {
    containerRect = container.getBoundingClientRect();
  }

  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};
});

unwrapExports(dom);
dom.isInContainer;
dom.getScrollContainer;
dom.isScroll;
dom.getStyle;
dom.once;
dom.off;
dom.on;
dom.hasClass;
dom.addClass;
dom.removeClass;
dom.setStyle;

var types = createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.isDefined = exports.isUndefined = exports.isFunction = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.isString = isString;
exports.isObject = isObject;
exports.isHtmlElement = isHtmlElement;



var _vue2 = _interopRequireDefault(Vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
}

function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}

function isHtmlElement(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}

/**
 *  - Inspired:
 *    https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js
 */
var isFunction = function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
};

if (typeof /./ !== 'function' && (typeof Int8Array === 'undefined' ? 'undefined' : _typeof(Int8Array)) !== 'object' && (_vue2.default.prototype.$isServer || typeof document.childNodes !== 'function')) {
  exports.isFunction = isFunction = function isFunction(obj) {
    return typeof obj === 'function' || false;
  };
}

exports.isFunction = isFunction;
exports.isUndefined = function isUndefined(val) {
  return val === void 0;
};

exports.isDefined = function isDefined(val) {
  return val !== undefined && val !== null;
};
});

unwrapExports(types);
types.isDefined;
types.isUndefined;
types.isFunction;
types.isString;
types.isObject;
types.isHtmlElement;

var util = createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.isMac = exports.isEmpty = exports.isEqual = exports.arrayEquals = exports.looseEqual = exports.capitalize = exports.kebabCase = exports.autoprefixer = exports.isFirefox = exports.isEdge = exports.isIE = exports.coerceTruthyValueToArray = exports.arrayFind = exports.arrayFindIndex = exports.escapeRegexpString = exports.valueEquals = exports.generateId = exports.getValueByPath = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.noop = noop;
exports.hasOwn = hasOwn;
exports.toObject = toObject;
exports.getPropByPath = getPropByPath;
exports.rafThrottle = rafThrottle;
exports.objToArray = objToArray;



var _vue2 = _interopRequireDefault(Vue);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasOwnProperty = Object.prototype.hasOwnProperty;

function noop() {}
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
exports.getValueByPath = function getValueByPath(object, prop) {
  prop = prop || '';
  var paths = prop.split('.');
  var current = object;
  var result = null;
  for (var i = 0, j = paths.length; i < j; i++) {
    var path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }
    current = current[path];
  }
  return result;
};

function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');

  var keyArr = path.split('.');
  var i = 0;
  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    var key = keyArr[i];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
}
exports.generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};

exports.valueEquals = function valueEquals(a, b) {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};

exports.escapeRegexpString = function escapeRegexpString() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
};

// TODO: use native Array.find, Array.findIndex when IE support is dropped
var arrayFindIndex = exports.arrayFindIndex = function arrayFindIndex(arr, pred) {
  for (var i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
};

exports.arrayFind = function arrayFind(arr, pred) {
  var idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
};

// coerce truthy value to array
exports.coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};

exports.isIE = function isIE() {
  return !_vue2.default.prototype.$isServer && !isNaN(Number(document.documentMode));
};

exports.isEdge = function isEdge() {
  return !_vue2.default.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;
};

exports.isFirefox = function isFirefox() {
  return !_vue2.default.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);
};

exports.autoprefixer = function autoprefixer(style) {
  if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) !== 'object') return style;
  var rules = ['transform', 'transition', 'animation'];
  var prefixes = ['ms-', 'webkit-'];
  rules.forEach(function (rule) {
    var value = style[rule];
    if (rule && value) {
      prefixes.forEach(function (prefix) {
        style[prefix + rule] = value;
      });
    }
  });
  return style;
};

exports.kebabCase = function kebabCase(str) {
  var hyphenateRE = /([^-])([A-Z])/g;
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
};

exports.capitalize = function capitalize(str) {
  if (!(0, types.isString)(str)) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
};

var looseEqual = exports.looseEqual = function looseEqual(a, b) {
  var isObjectA = (0, types.isObject)(a);
  var isObjectB = (0, types.isObject)(b);
  if (isObjectA && isObjectB) {
    return JSON.stringify(a) === JSON.stringify(b);
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
};

var arrayEquals = exports.arrayEquals = function arrayEquals(arrayA, arrayB) {
  arrayA = arrayA || [];
  arrayB = arrayB || [];

  if (arrayA.length !== arrayB.length) {
    return false;
  }

  for (var i = 0; i < arrayA.length; i++) {
    if (!looseEqual(arrayA[i], arrayB[i])) {
      return false;
    }
  }

  return true;
};

exports.isEqual = function isEqual(value1, value2) {
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return arrayEquals(value1, value2);
  }
  return looseEqual(value1, value2);
};

var isEmpty = exports.isEmpty = function isEmpty(val) {
  // null or undefined
  if (val == null) return true;

  if (typeof val === 'boolean') return false;

  if (typeof val === 'number') return !val;

  if (val instanceof Error) return val.message === '';

  switch (Object.prototype.toString.call(val)) {
    // String or Array
    case '[object String]':
    case '[object Array]':
      return !val.length;

    // Map or Set or File
    case '[object File]':
    case '[object Map]':
    case '[object Set]':
      {
        return !val.size;
      }
    // Plain Object
    case '[object Object]':
      {
        return !Object.keys(val).length;
      }
  }

  return false;
};

function rafThrottle(fn) {
  var locked = false;
  return function () {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (locked) return;
    locked = true;
    window.requestAnimationFrame(function (_) {
      fn.apply(_this, args);
      locked = false;
    });
  };
}

function objToArray(obj) {
  if (Array.isArray(obj)) {
    return obj;
  }
  return isEmpty(obj) ? [] : [obj];
}

exports.isMac = function isMac() {
  return !_vue2.default.prototype.$isServer && /macintosh|mac os x/i.test(navigator.userAgent);
};
});

unwrapExports(util);
util.isMac;
util.isEmpty;
util.isEqual;
util.arrayEquals;
util.looseEqual;
util.capitalize;
util.kebabCase;
util.autoprefixer;
util.isFirefox;
util.isEdge;
util.isIE;
util.coerceTruthyValueToArray;
util.arrayFind;
util.arrayFindIndex;
util.escapeRegexpString;
util.valueEquals;
util.generateId;
util.getValueByPath;
util.noop;
util.hasOwn;
util.toObject;
util.getPropByPath;
util.rafThrottle;
util.objToArray;

var merge$2 = createCommonjsModule(function (module, exports) {

exports.__esModule = true;

exports.default = function (target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];
        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
};
});

unwrapExports(merge$2);

var popupManager = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _vue2 = _interopRequireDefault(Vue);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasModal = false;
var hasInitZIndex = false;
var zIndex = void 0;

var getModal = function getModal() {
  if (_vue2.default.prototype.$isServer) return;
  var modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;

    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    });

    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }

  return modalDom;
};

var instances = {};

var PopupManager = {
  modalFade: true,

  getInstance: function getInstance(id) {
    return instances[id];
  },

  register: function register(id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },

  deregister: function deregister(id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },

  nextZIndex: function nextZIndex() {
    return PopupManager.zIndex++;
  },

  modalStack: [],

  doOnModalClick: function doOnModalClick() {
    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;

    var instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },

  openModal: function openModal(id, zIndex, dom$1, modalClass, modalFade) {
    if (_vue2.default.prototype.$isServer) return;
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;

    var modalStack = this.modalStack;

    for (var i = 0, j = modalStack.length; i < j; i++) {
      var item = modalStack[i];
      if (item.id === id) {
        return;
      }
    }

    var modalDom = getModal();

    (0, dom.addClass)(modalDom, 'v-modal');
    if (this.modalFade && !hasModal) {
      (0, dom.addClass)(modalDom, 'v-modal-enter');
    }
    if (modalClass) {
      var classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(function (item) {
        return (0, dom.addClass)(modalDom, item);
      });
    }
    setTimeout(function () {
      (0, dom.removeClass)(modalDom, 'v-modal-enter');
    }, 200);

    if (dom$1 && dom$1.parentNode && dom$1.parentNode.nodeType !== 11) {
      dom$1.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }

    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = '';

    this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
  },

  closeModal: function closeModal(id) {
    var modalStack = this.modalStack;
    var modalDom = getModal();

    if (modalStack.length > 0) {
      var topItem = modalStack[modalStack.length - 1];
      if (topItem.id === id) {
        if (topItem.modalClass) {
          var classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(function (item) {
            return (0, dom.removeClass)(modalDom, item);
          });
        }

        modalStack.pop();
        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (var i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }

    if (modalStack.length === 0) {
      if (this.modalFade) {
        (0, dom.addClass)(modalDom, 'v-modal-leave');
      }
      setTimeout(function () {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }
        (0, dom.removeClass)(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};

Object.defineProperty(PopupManager, 'zIndex', {
  configurable: true,
  get: function get() {
    if (!hasInitZIndex) {
      zIndex = zIndex || (_vue2.default.prototype.$ELEMENT || {}).zIndex || 2000;
      hasInitZIndex = true;
    }
    return zIndex;
  },
  set: function set(value) {
    zIndex = value;
  }
});

var getTopPopup = function getTopPopup() {
  if (_vue2.default.prototype.$isServer) return;
  if (PopupManager.modalStack.length > 0) {
    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    var instance = PopupManager.getInstance(topPopup.id);

    return instance;
  }
};

if (!_vue2.default.prototype.$isServer) {
  // handle `esc` key when the popup is shown
  window.addEventListener('keydown', function (event) {
    if (event.keyCode === 27) {
      var topPopup = getTopPopup();

      if (topPopup && topPopup.closeOnPressEscape) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
      }
    }
  });
}

exports.default = PopupManager;
});

unwrapExports(popupManager);

var scrollbarWidth = createCommonjsModule(function (module, exports) {

exports.__esModule = true;

exports.default = function () {
  if (_vue2.default.prototype.$isServer) return 0;
  if (scrollBarWidth !== undefined) return scrollBarWidth;

  var outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);

  var widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';

  var inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);

  var widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;

  return scrollBarWidth;
};



var _vue2 = _interopRequireDefault(Vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scrollBarWidth = void 0;
});

unwrapExports(scrollbarWidth);

var popup = createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.PopupManager = undefined;



var _vue2 = _interopRequireDefault(Vue);



var _merge2 = _interopRequireDefault(merge$2);



var _popupManager2 = _interopRequireDefault(popupManager);



var _scrollbarWidth2 = _interopRequireDefault(scrollbarWidth);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var idSeed = 1;

var scrollBarWidth = void 0;

exports.default = {
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    openDelay: {},
    closeDelay: {},
    zIndex: {},
    modal: {
      type: Boolean,
      default: false
    },
    modalFade: {
      type: Boolean,
      default: true
    },
    modalClass: {},
    modalAppendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: false
    },
    closeOnClickModal: {
      type: Boolean,
      default: false
    }
  },

  beforeMount: function beforeMount() {
    this._popupId = 'popup-' + idSeed++;
    _popupManager2.default.register(this._popupId, this);
  },
  beforeDestroy: function beforeDestroy() {
    _popupManager2.default.deregister(this._popupId);
    _popupManager2.default.closeModal(this._popupId);

    this.restoreBodyStyle();
  },
  data: function data() {
    return {
      opened: false,
      bodyPaddingRight: null,
      computedBodyPaddingRight: 0,
      withoutHiddenClass: true,
      rendered: false
    };
  },


  watch: {
    visible: function visible(val) {
      var _this = this;

      if (val) {
        if (this._opening) return;
        if (!this.rendered) {
          this.rendered = true;
          _vue2.default.nextTick(function () {
            _this.open();
          });
        } else {
          this.open();
        }
      } else {
        this.close();
      }
    }
  },

  methods: {
    open: function open(options) {
      var _this2 = this;

      if (!this.rendered) {
        this.rendered = true;
      }

      var props = (0, _merge2.default)({}, this.$props || this, options);

      if (this._closeTimer) {
        clearTimeout(this._closeTimer);
        this._closeTimer = null;
      }
      clearTimeout(this._openTimer);

      var openDelay = Number(props.openDelay);
      if (openDelay > 0) {
        this._openTimer = setTimeout(function () {
          _this2._openTimer = null;
          _this2.doOpen(props);
        }, openDelay);
      } else {
        this.doOpen(props);
      }
    },
    doOpen: function doOpen(props) {
      if (this.$isServer) return;
      if (this.willOpen && !this.willOpen()) return;
      if (this.opened) return;

      this._opening = true;

      var dom$1 = this.$el;

      var modal = props.modal;

      var zIndex = props.zIndex;
      if (zIndex) {
        _popupManager2.default.zIndex = zIndex;
      }

      if (modal) {
        if (this._closing) {
          _popupManager2.default.closeModal(this._popupId);
          this._closing = false;
        }
        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom$1, props.modalClass, props.modalFade);
        if (props.lockScroll) {
          this.withoutHiddenClass = !(0, dom.hasClass)(document.body, 'el-popup-parent--hidden');
          if (this.withoutHiddenClass) {
            this.bodyPaddingRight = document.body.style.paddingRight;
            this.computedBodyPaddingRight = parseInt((0, dom.getStyle)(document.body, 'paddingRight'), 10);
          }
          scrollBarWidth = (0, _scrollbarWidth2.default)();
          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          var bodyOverflowY = (0, dom.getStyle)(document.body, 'overflowY');
          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {
            document.body.style.paddingRight = this.computedBodyPaddingRight + scrollBarWidth + 'px';
          }
          (0, dom.addClass)(document.body, 'el-popup-parent--hidden');
        }
      }

      if (getComputedStyle(dom$1).position === 'static') {
        dom$1.style.position = 'absolute';
      }

      dom$1.style.zIndex = _popupManager2.default.nextZIndex();
      this.opened = true;

      this.onOpen && this.onOpen();

      this.doAfterOpen();
    },
    doAfterOpen: function doAfterOpen() {
      this._opening = false;
    },
    close: function close() {
      var _this3 = this;

      if (this.willClose && !this.willClose()) return;

      if (this._openTimer !== null) {
        clearTimeout(this._openTimer);
        this._openTimer = null;
      }
      clearTimeout(this._closeTimer);

      var closeDelay = Number(this.closeDelay);

      if (closeDelay > 0) {
        this._closeTimer = setTimeout(function () {
          _this3._closeTimer = null;
          _this3.doClose();
        }, closeDelay);
      } else {
        this.doClose();
      }
    },
    doClose: function doClose() {
      this._closing = true;

      this.onClose && this.onClose();

      if (this.lockScroll) {
        setTimeout(this.restoreBodyStyle, 200);
      }

      this.opened = false;

      this.doAfterClose();
    },
    doAfterClose: function doAfterClose() {
      _popupManager2.default.closeModal(this._popupId);
      this._closing = false;
    },
    restoreBodyStyle: function restoreBodyStyle() {
      if (this.modal && this.withoutHiddenClass) {
        document.body.style.paddingRight = this.bodyPaddingRight;
        (0, dom.removeClass)(document.body, 'el-popup-parent--hidden');
      }
      this.withoutHiddenClass = true;
    }
  }
};
exports.PopupManager = _popupManager2.default;
});

unwrapExports(popup);
popup.PopupManager;

var popper = createCommonjsModule(function (module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function (root, factory) {
    if ((_typeof(module)) === 'object' && module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.Popper = factory();
    }
})(undefined, function () {

    var root = window;

    // default options
    var DEFAULTS = {
        // placement of the popper
        placement: 'bottom',

        gpuAcceleration: true,

        // shift popper from its origin by the given amount of pixels (can be negative)
        offset: 0,

        // the element which will act as boundary of the popper
        boundariesElement: 'viewport',

        // amount of pixel used to define a minimum distance between the boundaries and the popper
        boundariesPadding: 5,

        // popper will try to prevent overflow following this order,
        // by default, then, it could overflow on the left and on top of the boundariesElement
        preventOverflowOrder: ['left', 'right', 'top', 'bottom'],

        // the behavior used by flip to change the placement of the popper
        flipBehavior: 'flip',

        arrowElement: '[x-arrow]',

        arrowOffset: 0,

        // list of functions used to modify the offsets before they are applied to the popper
        modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],

        modifiersIgnored: [],

        forceAbsolute: false
    };

    /**
     * Create a new Popper.js instance
     * @constructor Popper
     * @param {HTMLElement} reference - The reference element used to position the popper
     * @param {HTMLElement|Object} popper
     *      The HTML element used as popper, or a configuration used to generate the popper.
     * @param {String} [popper.tagName='div'] The tag name of the generated popper.
     * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
     * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
     * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
     * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
     * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
     * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
     * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
     * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
     * @param {Object} options
     * @param {String} [options.placement=bottom]
     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
     *      left(-start, -end)`
     *
     * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
     *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
     *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
     *      reference element.
     *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
     *
     * @param {Boolean} [options.gpuAcceleration=true]
     *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
     *      browser to use the GPU to accelerate the rendering.
     *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
     *
     * @param {Number} [options.offset=0]
     *      Amount of pixels the popper will be shifted (can be negative).
     *
     * @param {String|Element} [options.boundariesElement='viewport']
     *      The element which will define the boundaries of the popper position, the popper will never be placed outside
     *      of the defined boundaries (except if `keepTogether` is enabled)
     *
     * @param {Number} [options.boundariesPadding=5]
     *      Additional padding for the boundaries
     *
     * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
     *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
     *      this means that the last ones will never overflow
     *
     * @param {String|Array} [options.flipBehavior='flip']
     *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
     *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
     *      its axis (`right - left`, `top - bottom`).
     *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
     *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
     *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
     *
     * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
     *      List of functions used to modify the data before they are applied to the popper, add your custom functions
     *      to this array to edit the offsets and placement.
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Array} [options.modifiersIgnored=[]]
     *      Put here any built-in modifier name you want to exclude from the modifiers list
     *      The function should reflect the @params and @returns of preventOverflow
     *
     * @param {Boolean} [options.removeOnDestroy=false]
     *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
     */
    function Popper(reference, popper, options) {
        this._reference = reference.jquery ? reference[0] : reference;
        this.state = {};

        // if the popper variable is a configuration object, parse it to generate an HTMLElement
        // generate a default popper if is not defined
        var isNotDefined = typeof popper === 'undefined' || popper === null;
        var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';
        if (isNotDefined || isConfig) {
            this._popper = this.parse(isConfig ? popper : {});
        }
        // otherwise, use the given HTMLElement as popper
        else {
                this._popper = popper.jquery ? popper[0] : popper;
            }

        // with {} we create a new object with the options inside it
        this._options = Object.assign({}, DEFAULTS, options);

        // refactoring modifiers' list
        this._options.modifiers = this._options.modifiers.map(function (modifier) {
            // remove ignored modifiers
            if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return;

            // set the x-placement attribute before everything else because it could be used to add margins to the popper
            // margins needs to be calculated to get the correct popper offsets
            if (modifier === 'applyStyle') {
                this._popper.setAttribute('x-placement', this._options.placement);
            }

            // return predefined modifier identified by string or keep the custom one
            return this.modifiers[modifier] || modifier;
        }.bind(this));

        // make sure to apply the popper position before any computation
        this.state.position = this._getPosition(this._popper, this._reference);
        setStyle(this._popper, { position: this.state.position, top: 0 });

        // fire the first update to position the popper in the right place
        this.update();

        // setup event listeners, they will take care of update the position in specific situations
        this._setupEventListeners();
        return this;
    }

    //
    // Methods
    //
    /**
     * Destroy the popper
     * @method
     * @memberof Popper
     */
    Popper.prototype.destroy = function () {
        this._popper.removeAttribute('x-placement');
        this._popper.style.left = '';
        this._popper.style.position = '';
        this._popper.style.top = '';
        this._popper.style[getSupportedPropertyName('transform')] = '';
        this._removeEventListeners();

        // remove the popper if user explicity asked for the deletion on destroy
        if (this._options.removeOnDestroy) {
            this._popper.remove();
        }
        return this;
    };

    /**
     * Updates the position of the popper, computing the new offsets and applying the new style
     * @method
     * @memberof Popper
     */
    Popper.prototype.update = function () {
        var data = { instance: this, styles: {} };

        // store placement inside the data object, modifiers will be able to edit `placement` if needed
        // and refer to _originalPlacement to know the original value
        data.placement = this._options.placement;
        data._originalPlacement = this._options.placement;

        // compute the popper and reference offsets and put them inside data.offsets
        data.offsets = this._getOffsets(this._popper, this._reference, data.placement);

        // get boundaries
        data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);

        data = this.runModifiers(data, this._options.modifiers);

        if (typeof this.state.updateCallback === 'function') {
            this.state.updateCallback(data);
        }
    };

    /**
     * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onCreate = function (callback) {
        // the createCallbacks return as first argument the popper instance
        callback(this);
        return this;
    };

    /**
     * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
     * used to style popper and its arrow.
     * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
     * @method
     * @memberof Popper
     * @param {Function} callback
     */
    Popper.prototype.onUpdate = function (callback) {
        this.state.updateCallback = callback;
        return this;
    };

    /**
     * Helper used to generate poppers from a configuration file
     * @method
     * @memberof Popper
     * @param config {Object} configuration
     * @returns {HTMLElement} popper
     */
    Popper.prototype.parse = function (config) {
        var defaultConfig = {
            tagName: 'div',
            classNames: ['popper'],
            attributes: [],
            parent: root.document.body,
            content: '',
            contentType: 'text',
            arrowTagName: 'div',
            arrowClassNames: ['popper__arrow'],
            arrowAttributes: ['x-arrow']
        };
        config = Object.assign({}, defaultConfig, config);

        var d = root.document;

        var popper = d.createElement(config.tagName);
        addClassNames(popper, config.classNames);
        addAttributes(popper, config.attributes);
        if (config.contentType === 'node') {
            popper.appendChild(config.content.jquery ? config.content[0] : config.content);
        } else if (config.contentType === 'html') {
            popper.innerHTML = config.content;
        } else {
            popper.textContent = config.content;
        }

        if (config.arrowTagName) {
            var arrow = d.createElement(config.arrowTagName);
            addClassNames(arrow, config.arrowClassNames);
            addAttributes(arrow, config.arrowAttributes);
            popper.appendChild(arrow);
        }

        var parent = config.parent.jquery ? config.parent[0] : config.parent;

        // if the given parent is a string, use it to match an element
        // if more than one element is matched, the first one will be used as parent
        // if no elements are matched, the script will throw an error
        if (typeof parent === 'string') {
            parent = d.querySelectorAll(config.parent);
            if (parent.length > 1) {
                console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
            }
            if (parent.length === 0) {
                throw 'ERROR: the given `parent` doesn\'t exists!';
            }
            parent = parent[0];
        }
        // if the given parent is a DOM nodes list or an array of nodes with more than one element,
        // the first one will be used as parent
        if (parent.length > 1 && parent instanceof Element === false) {
            console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
            parent = parent[0];
        }

        // append the generated popper to its parent
        parent.appendChild(popper);

        return popper;

        /**
         * Adds class names to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} classes
         */
        function addClassNames(element, classNames) {
            classNames.forEach(function (className) {
                element.classList.add(className);
            });
        }

        /**
         * Adds attributes to the given element
         * @function
         * @ignore
         * @param {HTMLElement} target
         * @param {Array} attributes
         * @example
         * addAttributes(element, [ 'data-info:foobar' ]);
         */
        function addAttributes(element, attributes) {
            attributes.forEach(function (attribute) {
                element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
            });
        }
    };

    /**
     * Helper used to get the position which will be applied to the popper
     * @method
     * @memberof Popper
     * @param config {HTMLElement} popper element
     * @param reference {HTMLElement} reference element
     * @returns {String} position
     */
    Popper.prototype._getPosition = function (popper, reference) {
        getOffsetParent(reference);

        if (this._options.forceAbsolute) {
            return 'absolute';
        }

        // Decide if the popper will be fixed
        // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together
        var isParentFixed = isFixed(reference);
        return isParentFixed ? 'fixed' : 'absolute';
    };

    /**
     * Get offsets to the popper
     * @method
     * @memberof Popper
     * @access private
     * @param {Element} popper - the popper element
     * @param {Element} reference - the reference element (the popper will be relative to this)
     * @returns {Object} An object containing the offsets which will be applied to the popper
     */
    Popper.prototype._getOffsets = function (popper, reference, placement) {
        placement = placement.split('-')[0];
        var popperOffsets = {};

        popperOffsets.position = this.state.position;
        var isParentFixed = popperOffsets.position === 'fixed';

        //
        // Get reference element position
        //
        var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed);

        //
        // Get popper sizes
        //
        var popperRect = getOuterSizes(popper);

        //
        // Compute offsets of popper
        //

        // depending by the popper placement we have to compute its offsets slightly differently
        if (['right', 'left'].indexOf(placement) !== -1) {
            popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;
            if (placement === 'left') {
                popperOffsets.left = referenceOffsets.left - popperRect.width;
            } else {
                popperOffsets.left = referenceOffsets.right;
            }
        } else {
            popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;
            if (placement === 'top') {
                popperOffsets.top = referenceOffsets.top - popperRect.height;
            } else {
                popperOffsets.top = referenceOffsets.bottom;
            }
        }

        // Add width and height to our offsets object
        popperOffsets.width = popperRect.width;
        popperOffsets.height = popperRect.height;

        return {
            popper: popperOffsets,
            reference: referenceOffsets
        };
    };

    /**
     * Setup needed event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._setupEventListeners = function () {
        // NOTE: 1 DOM access here
        this.state.updateBound = this.update.bind(this);
        root.addEventListener('resize', this.state.updateBound);
        // if the boundariesElement is window we don't need to listen for the scroll event
        if (this._options.boundariesElement !== 'window') {
            var target = getScrollParent(this._reference);
            // here it could be both `body` or `documentElement` thanks to Firefox, we then check both
            if (target === root.document.body || target === root.document.documentElement) {
                target = root;
            }
            target.addEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = target;
        }
    };

    /**
     * Remove event listeners used to update the popper position
     * @method
     * @memberof Popper
     * @access private
     */
    Popper.prototype._removeEventListeners = function () {
        // NOTE: 1 DOM access here
        root.removeEventListener('resize', this.state.updateBound);
        if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
            this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
            this.state.scrollTarget = null;
        }
        this.state.updateBound = null;
    };

    /**
     * Computed the boundaries limits and return them
     * @method
     * @memberof Popper
     * @access private
     * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
     * @param {Number} padding - Boundaries padding
     * @param {Element} boundariesElement - Element used to define the boundaries
     * @returns {Object} Coordinates of the boundaries
     */
    Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
        // NOTE: 1 DOM access here
        var boundaries = {};
        var width, height;
        if (boundariesElement === 'window') {
            var body = root.document.body,
                html = root.document.documentElement;

            height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
            width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);

            boundaries = {
                top: 0,
                right: width,
                bottom: height,
                left: 0
            };
        } else if (boundariesElement === 'viewport') {
            var offsetParent = getOffsetParent(this._popper);
            var scrollParent = getScrollParent(this._popper);
            var offsetParentRect = getOffsetRect(offsetParent);

            // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`
            var getScrollTopValue = function getScrollTopValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
            };
            var getScrollLeftValue = function getScrollLeftValue(element) {
                return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
            };

            // if the popper is fixed we don't have to substract scrolling from the boundaries
            var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
            var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);

            boundaries = {
                top: 0 - (offsetParentRect.top - scrollTop),
                right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
                bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
                left: 0 - (offsetParentRect.left - scrollLeft)
            };
        } else {
            if (getOffsetParent(this._popper) === boundariesElement) {
                boundaries = {
                    top: 0,
                    left: 0,
                    right: boundariesElement.clientWidth,
                    bottom: boundariesElement.clientHeight
                };
            } else {
                boundaries = getOffsetRect(boundariesElement);
            }
        }
        boundaries.left += padding;
        boundaries.right -= padding;
        boundaries.top = boundaries.top + padding;
        boundaries.bottom = boundaries.bottom - padding;
        return boundaries;
    };

    /**
     * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
     * @method
     * @memberof Popper
     * @access public
     * @param {Object} data
     * @param {Array} modifiers
     * @param {Function} ends
     */
    Popper.prototype.runModifiers = function (data, modifiers, ends) {
        var modifiersToRun = modifiers.slice();
        if (ends !== undefined) {
            modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
        }

        modifiersToRun.forEach(function (modifier) {
            if (isFunction(modifier)) {
                data = modifier.call(this, data);
            }
        }.bind(this));

        return data;
    };

    /**
     * Helper used to know if the given modifier depends from another one.
     * @method
     * @memberof Popper
     * @param {String} requesting - name of requesting modifier
     * @param {String} requested - name of requested modifier
     * @returns {Boolean}
     */
    Popper.prototype.isModifierRequired = function (requesting, requested) {
        var index = getArrayKeyIndex(this._options.modifiers, requesting);
        return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
            return modifier === requested;
        }).length;
    };

    //
    // Modifiers
    //

    /**
     * Modifiers list
     * @namespace Popper.modifiers
     * @memberof Popper
     * @type {Object}
     */
    Popper.prototype.modifiers = {};

    /**
     * Apply the computed styles to the popper element
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The same data object
     */
    Popper.prototype.modifiers.applyStyle = function (data) {
        // apply the final offsets to the popper
        // NOTE: 1 DOM access here
        var styles = {
            position: data.offsets.popper.position
        };

        // round top and left to avoid blurry text
        var left = Math.round(data.offsets.popper.left);
        var top = Math.round(data.offsets.popper.top);

        // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
        // we automatically use the supported prefixed version if needed
        var prefixedProperty;
        if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
            styles.top = 0;
            styles.left = 0;
        }
        // othwerise, we use the standard `left` and `top` properties
        else {
                styles.left = left;
                styles.top = top;
            }

        // any property present in `data.styles` will be applied to the popper,
        // in this way we can make the 3rd party modifiers add custom styles to it
        // Be aware, modifiers could override the properties defined in the previous
        // lines of this modifier!
        Object.assign(styles, data.styles);

        setStyle(this._popper, styles);

        // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
        // NOTE: 1 DOM access here
        this._popper.setAttribute('x-placement', data.placement);

        // if the arrow modifier is required and the arrow style has been computed, apply the arrow style
        if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
            setStyle(data.arrowElement, data.offsets.arrow);
        }

        return data;
    };

    /**
     * Modifier used to shift the popper on the start or end of its reference element side
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.shift = function (data) {
        var placement = data.placement;
        var basePlacement = placement.split('-')[0];
        var shiftVariation = placement.split('-')[1];

        // if shift shiftVariation is specified, run the modifier
        if (shiftVariation) {
            var reference = data.offsets.reference;
            var popper = getPopperClientRect(data.offsets.popper);

            var shiftOffsets = {
                y: {
                    start: { top: reference.top },
                    end: { top: reference.top + reference.height - popper.height }
                },
                x: {
                    start: { left: reference.left },
                    end: { left: reference.left + reference.width - popper.width }
                }
            };

            var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';

            data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
        }

        return data;
    };

    /**
     * Modifier used to make sure the popper does not overflows from it's boundaries
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by `update` method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.preventOverflow = function (data) {
        var order = this._options.preventOverflowOrder;
        var popper = getPopperClientRect(data.offsets.popper);

        var check = {
            left: function left() {
                var left = popper.left;
                if (popper.left < data.boundaries.left) {
                    left = Math.max(popper.left, data.boundaries.left);
                }
                return { left: left };
            },
            right: function right() {
                var left = popper.left;
                if (popper.right > data.boundaries.right) {
                    left = Math.min(popper.left, data.boundaries.right - popper.width);
                }
                return { left: left };
            },
            top: function top() {
                var top = popper.top;
                if (popper.top < data.boundaries.top) {
                    top = Math.max(popper.top, data.boundaries.top);
                }
                return { top: top };
            },
            bottom: function bottom() {
                var top = popper.top;
                if (popper.bottom > data.boundaries.bottom) {
                    top = Math.min(popper.top, data.boundaries.bottom - popper.height);
                }
                return { top: top };
            }
        };

        order.forEach(function (direction) {
            data.offsets.popper = Object.assign(popper, check[direction]());
        });

        return data;
    };

    /**
     * Modifier used to make sure the popper is always near its reference
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.keepTogether = function (data) {
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var f = Math.floor;

        if (popper.right < f(reference.left)) {
            data.offsets.popper.left = f(reference.left) - popper.width;
        }
        if (popper.left > f(reference.right)) {
            data.offsets.popper.left = f(reference.right);
        }
        if (popper.bottom < f(reference.top)) {
            data.offsets.popper.top = f(reference.top) - popper.height;
        }
        if (popper.top > f(reference.bottom)) {
            data.offsets.popper.top = f(reference.bottom);
        }

        return data;
    };

    /**
     * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
     * Requires the `preventOverflow` modifier before it in order to work.
     * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.flip = function (data) {
        // check if preventOverflow is in the list of modifiers before the flip modifier.
        // otherwise flip would not work as expected.
        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
            console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
            return data;
        }

        if (data.flipped && data.placement === data._originalPlacement) {
            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
            return data;
        }

        var placement = data.placement.split('-')[0];
        var placementOpposite = getOppositePlacement(placement);
        var variation = data.placement.split('-')[1] || '';

        var flipOrder = [];
        if (this._options.flipBehavior === 'flip') {
            flipOrder = [placement, placementOpposite];
        } else {
            flipOrder = this._options.flipBehavior;
        }

        flipOrder.forEach(function (step, index) {
            if (placement !== step || flipOrder.length === index + 1) {
                return;
            }

            placement = data.placement.split('-')[0];
            placementOpposite = getOppositePlacement(placement);

            var popperOffsets = getPopperClientRect(data.offsets.popper);

            // this boolean is used to distinguish right and bottom from top and left
            // they need different computations to get flipped
            var a = ['right', 'bottom'].indexOf(placement) !== -1;

            // using Math.floor because the reference offsets may contain decimals we are not going to consider here
            if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
                // we'll use this boolean to detect any flip loop
                data.flipped = true;
                data.placement = flipOrder[index + 1];
                if (variation) {
                    data.placement += '-' + variation;
                }
                data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;

                data = this.runModifiers(data, this._options.modifiers, this._flip);
            }
        }.bind(this));
        return data;
    };

    /**
     * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
     * The offsets will shift the popper on the side of its reference element.
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.offset = function (data) {
        var offset = this._options.offset;
        var popper = data.offsets.popper;

        if (data.placement.indexOf('left') !== -1) {
            popper.top -= offset;
        } else if (data.placement.indexOf('right') !== -1) {
            popper.top += offset;
        } else if (data.placement.indexOf('top') !== -1) {
            popper.left -= offset;
        } else if (data.placement.indexOf('bottom') !== -1) {
            popper.left += offset;
        }
        return data;
    };

    /**
     * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
     * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
     * @method
     * @memberof Popper.modifiers
     * @argument {Object} data - The data object generated by _update method
     * @returns {Object} The data object, properly modified
     */
    Popper.prototype.modifiers.arrow = function (data) {
        var arrow = this._options.arrowElement;
        var arrowOffset = this._options.arrowOffset;

        // if the arrowElement is a string, suppose it's a CSS selector
        if (typeof arrow === 'string') {
            arrow = this._popper.querySelector(arrow);
        }

        // if arrow element is not found, don't run the modifier
        if (!arrow) {
            return data;
        }

        // the arrow element must be child of its popper
        if (!this._popper.contains(arrow)) {
            console.warn('WARNING: `arrowElement` must be child of its popper element!');
            return data;
        }

        // arrow depends on keepTogether in order to work
        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
            console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
            return data;
        }

        var arrowStyle = {};
        var placement = data.placement.split('-')[0];
        var popper = getPopperClientRect(data.offsets.popper);
        var reference = data.offsets.reference;
        var isVertical = ['left', 'right'].indexOf(placement) !== -1;

        var len = isVertical ? 'height' : 'width';
        var side = isVertical ? 'top' : 'left';
        var altSide = isVertical ? 'left' : 'top';
        var opSide = isVertical ? 'bottom' : 'right';
        var arrowSize = getOuterSizes(arrow)[len];

        //
        // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
        //

        // top/left side
        if (reference[opSide] - arrowSize < popper[side]) {
            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
        }
        // bottom/right side
        if (reference[side] + arrowSize > popper[opSide]) {
            data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
        }

        // compute center of the popper
        var center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);

        var sideValue = center - popper[side];

        // prevent arrow from being placed not contiguously to its popper
        sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
        arrowStyle[side] = sideValue;
        arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

        data.offsets.arrow = arrowStyle;
        data.arrowElement = arrow;

        return data;
    };

    //
    // Helpers
    //

    /**
     * Get the outer sizes of the given element (offset size + margins)
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Object} object containing width and height properties
     */
    function getOuterSizes(element) {
        // NOTE: 1 DOM access here
        var _display = element.style.display,
            _visibility = element.style.visibility;
        element.style.display = 'block';element.style.visibility = 'hidden';
        element.offsetWidth;

        // original method
        var styles = root.getComputedStyle(element);
        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
        var result = { width: element.offsetWidth + y, height: element.offsetHeight + x };

        // reset element styles
        element.style.display = _display;element.style.visibility = _visibility;
        return result;
    }

    /**
     * Get the opposite placement of the given one/
     * @function
     * @ignore
     * @argument {String} placement
     * @returns {String} flipped placement
     */
    function getOppositePlacement(placement) {
        var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
        return placement.replace(/left|right|bottom|top/g, function (matched) {
            return hash[matched];
        });
    }

    /**
     * Given the popper offsets, generate an output similar to getBoundingClientRect
     * @function
     * @ignore
     * @argument {Object} popperOffsets
     * @returns {Object} ClientRect like output
     */
    function getPopperClientRect(popperOffsets) {
        var offsets = Object.assign({}, popperOffsets);
        offsets.right = offsets.left + offsets.width;
        offsets.bottom = offsets.top + offsets.height;
        return offsets;
    }

    /**
     * Given an array and the key to find, returns its index
     * @function
     * @ignore
     * @argument {Array} arr
     * @argument keyToFind
     * @returns index or null
     */
    function getArrayKeyIndex(arr, keyToFind) {
        var i = 0,
            key;
        for (key in arr) {
            if (arr[key] === keyToFind) {
                return i;
            }
            i++;
        }
        return null;
    }

    /**
     * Get CSS computed property of the given element
     * @function
     * @ignore
     * @argument {Eement} element
     * @argument {String} property
     */
    function getStyleComputedProperty(element, property) {
        // NOTE: 1 DOM access here
        var css = root.getComputedStyle(element, null);
        return css[property];
    }

    /**
     * Returns the offset parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getOffsetParent(element) {
        // NOTE: 1 DOM access here
        var offsetParent = element.offsetParent;
        return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
    }

    /**
     * Returns the scrolling parent of the given element
     * @function
     * @ignore
     * @argument {Element} element
     * @returns {Element} offset parent
     */
    function getScrollParent(element) {
        var parent = element.parentNode;

        if (!parent) {
            return element;
        }

        if (parent === root.document) {
            // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
            // greater than 0 and return the proper element
            if (root.document.body.scrollTop || root.document.body.scrollLeft) {
                return root.document.body;
            } else {
                return root.document.documentElement;
            }
        }

        // Firefox want us to check `-x` and `-y` variations as well
        if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
            // If the detected scrollParent is body, we perform an additional check on its parentNode
            // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
            // fixes issue #65
            return parent;
        }
        return getScrollParent(element.parentNode);
    }

    /**
     * Check if the given element is fixed or is inside a fixed parent
     * @function
     * @ignore
     * @argument {Element} element
     * @argument {Element} customContainer
     * @returns {Boolean} answer to "isFixed?"
     */
    function isFixed(element) {
        if (element === root.document.body) {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return element.parentNode ? isFixed(element.parentNode) : element;
    }

    /**
     * Set the style to the given popper
     * @function
     * @ignore
     * @argument {Element} element - Element to apply the style to
     * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
     */
    function setStyle(element, styles) {
        function is_numeric(n) {
            return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
        }
        Object.keys(styles).forEach(function (prop) {
            var unit = '';
            // add unit if the value is numeric and is one of the following
            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
                unit = 'px';
            }
            element.style[prop] = styles[prop] + unit;
        });
    }

    /**
     * Check if the given variable is a function
     * @function
     * @ignore
     * @argument {*} functionToCheck - variable to check
     * @returns {Boolean} answer to: is a function?
     */
    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    /**
     * Get the position of the given element, relative to its offset parent
     * @function
     * @ignore
     * @param {Element} element
     * @return {Object} position - Coordinates of the element and its `scrollTop`
     */
    function getOffsetRect(element) {
        var elementRect = {
            width: element.offsetWidth,
            height: element.offsetHeight,
            left: element.offsetLeft,
            top: element.offsetTop
        };

        elementRect.right = elementRect.left + elementRect.width;
        elementRect.bottom = elementRect.top + elementRect.height;

        // position
        return elementRect;
    }

    /**
     * Get bounding client rect of given element
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @return {Object} client rect
     */
    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();

        // whether the IE version is lower than 11
        var isIE = navigator.userAgent.indexOf("MSIE") != -1;

        // fix ie document bounding top always 0 bug
        var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;

        return {
            left: rect.left,
            top: rectTop,
            right: rect.right,
            bottom: rect.bottom,
            width: rect.right - rect.left,
            height: rect.bottom - rectTop
        };
    }

    /**
     * Given an element and one of its parents, return the offset
     * @function
     * @ignore
     * @param {HTMLElement} element
     * @param {HTMLElement} parent
     * @return {Object} rect
     */
    function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
        var elementRect = getBoundingClientRect(element);
        var parentRect = getBoundingClientRect(parent);

        if (fixed) {
            var scrollParent = getScrollParent(parent);
            parentRect.top += scrollParent.scrollTop;
            parentRect.bottom += scrollParent.scrollTop;
            parentRect.left += scrollParent.scrollLeft;
            parentRect.right += scrollParent.scrollLeft;
        }

        var rect = {
            top: elementRect.top - parentRect.top,
            left: elementRect.left - parentRect.left,
            bottom: elementRect.top - parentRect.top + elementRect.height,
            right: elementRect.left - parentRect.left + elementRect.width,
            width: elementRect.width,
            height: elementRect.height
        };
        return rect;
    }

    /**
     * Get the prefixed supported property name
     * @function
     * @ignore
     * @argument {String} property (camelCase)
     * @returns {String} prefixed property (camelCase)
     */
    function getSupportedPropertyName(property) {
        var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

        for (var i = 0; i < prefixes.length; i++) {
            var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;
            if (typeof root.document.body.style[toCheck] !== 'undefined') {
                return toCheck;
            }
        }
        return null;
    }

    /**
     * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
     * objects to a target object. It will return the target object.
     * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
     * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
     * @function
     * @ignore
     */
    if (!Object.assign) {
        Object.defineProperty(Object, 'assign', {
            enumerable: false,
            configurable: true,
            writable: true,
            value: function value(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert first argument to object');
                }

                var to = Object(target);
                for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }
                    nextSource = Object(nextSource);

                    var keysArray = Object.keys(nextSource);
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
                return to;
            }
        });
    }

    return Popper;
});
});

var vuePopper = createCommonjsModule(function (module, exports) {

exports.__esModule = true;



var _vue2 = _interopRequireDefault(Vue);



function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopperJS = _vue2.default.prototype.$isServer ? function () {} : popper;
var stop = function stop(e) {
  return e.stopPropagation();
};

/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */
exports.default = {
  props: {
    transformOrigin: {
      type: [Boolean, String],
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    arrowOffset: {
      type: Number,
      default: 35
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return {
          gpuAcceleration: false
        };
      }
    }
  },

  data: function data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },


  watch: {
    value: {
      immediate: true,
      handler: function handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }
    },

    showPopper: function showPopper(val) {
      if (this.disabled) return;
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }
  },

  methods: {
    createPopper: function createPopper() {
      var _this = this;

      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      var options = this.popperOptions;
      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);
      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new PopperJS(reference, popper, options);
      this.popperJS.onCreate(function (_) {
        _this.$emit('created', _this);
        _this.resetTransformOrigin();
        _this.$nextTick(_this.updatePopper);
      });
      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }
      this.popperJS._popper.style.zIndex = popup.PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop);
    },
    updatePopper: function updatePopper() {
      var popperJS = this.popperJS;
      if (popperJS) {
        popperJS.update();
        if (popperJS._popper) {
          popperJS._popper.style.zIndex = popup.PopupManager.nextZIndex();
        }
      } else {
        this.createPopper();
      }
    },
    doDestroy: function doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!this.popperJS || this.showPopper && !forceDestroy) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },
    destroyPopper: function destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },
    resetTransformOrigin: function resetTransformOrigin() {
      if (!this.transformOrigin) return;
      var placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];
      var origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string' ? this.transformOrigin : ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';
    },
    appendArrow: function appendArrow(element) {
      var hash = void 0;
      if (this.appended) {
        return;
      }

      this.appended = true;

      for (var item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      var arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }
      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }
  },

  beforeDestroy: function beforeDestroy() {
    this.doDestroy(true);
    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop);
      document.body.removeChild(this.popperElm);
    }
  },


  // call destroy in keep-alive mode
  deactivated: function deactivated() {
    this.$options.beforeDestroy[0].call(this);
  }
};
});

unwrapExports(vuePopper);

var tooltip = createCommonjsModule(function (module) {
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 138);
/******/ })
/************************************************************************/
/******/ ({

/***/ 138:
/***/ (function(module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"
var vue_popper_ = __webpack_require__(5);
var vue_popper_default = /*#__PURE__*/__webpack_require__.n(vue_popper_);

// EXTERNAL MODULE: external "throttle-debounce/debounce"
var debounce_ = __webpack_require__(19);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce_);

// EXTERNAL MODULE: external "element-ui/lib/utils/dom"
var dom_ = __webpack_require__(2);

// EXTERNAL MODULE: external "element-ui/lib/utils/util"
var util_ = __webpack_require__(3);

// EXTERNAL MODULE: external "vue"
var external_vue_ = __webpack_require__(7);
var external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);

// CONCATENATED MODULE: ./packages/tooltip/src/main.js






/* harmony default export */ var main = ({
  name: 'ElTooltip',

  mixins: [vue_popper_default.a],

  props: {
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    manual: Boolean,
    effect: {
      type: String,
      default: 'dark'
    },
    arrowOffset: {
      type: Number,
      default: 0
    },
    popperClass: String,
    content: String,
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default: function _default() {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        };
      }
    },
    enterable: {
      type: Boolean,
      default: true
    },
    hideAfter: {
      type: Number,
      default: 0
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },

  data: function data() {
    return {
      tooltipId: 'el-tooltip-' + Object(util_["generateId"])(),
      timeoutPending: null,
      focusing: false
    };
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    if (this.$isServer) return;

    this.popperVM = new external_vue_default.a({
      data: { node: '' },
      render: function render(h) {
        return this.node;
      }
    }).$mount();

    this.debounceClose = debounce_default()(200, function () {
      return _this.handleClosePopper();
    });
  },
  render: function render(h) {
    var _this2 = this;

    if (this.popperVM) {
      this.popperVM.node = h(
        'transition',
        {
          attrs: {
            name: this.transition
          },
          on: {
            'afterLeave': this.doDestroy
          }
        },
        [h(
          'div',
          {
            on: {
              'mouseleave': function mouseleave() {
                _this2.setExpectedState(false);_this2.debounceClose();
              },
              'mouseenter': function mouseenter() {
                _this2.setExpectedState(true);
              }
            },

            ref: 'popper',
            attrs: { role: 'tooltip',
              id: this.tooltipId,
              'aria-hidden': this.disabled || !this.showPopper ? 'true' : 'false'
            },
            directives: [{
              name: 'show',
              value: !this.disabled && this.showPopper
            }],

            'class': ['el-tooltip__popper', 'is-' + this.effect, this.popperClass] },
          [this.$slots.content || this.content]
        )]
      );
    }

    var firstElement = this.getFirstElement();
    if (!firstElement) return null;

    var data = firstElement.data = firstElement.data || {};
    data.staticClass = this.addTooltipClass(data.staticClass);

    return firstElement;
  },
  mounted: function mounted() {
    var _this3 = this;

    this.referenceElm = this.$el;
    if (this.$el.nodeType === 1) {
      this.$el.setAttribute('aria-describedby', this.tooltipId);
      this.$el.setAttribute('tabindex', this.tabindex);
      Object(dom_["on"])(this.referenceElm, 'mouseenter', this.show);
      Object(dom_["on"])(this.referenceElm, 'mouseleave', this.hide);
      Object(dom_["on"])(this.referenceElm, 'focus', function () {
        if (!_this3.$slots.default || !_this3.$slots.default.length) {
          _this3.handleFocus();
          return;
        }
        var instance = _this3.$slots.default[0].componentInstance;
        if (instance && instance.focus) {
          instance.focus();
        } else {
          _this3.handleFocus();
        }
      });
      Object(dom_["on"])(this.referenceElm, 'blur', this.handleBlur);
      Object(dom_["on"])(this.referenceElm, 'click', this.removeFocusing);
    }
    // fix issue https://github.com/ElemeFE/element/issues/14424
    if (this.value && this.popperVM) {
      this.popperVM.$nextTick(function () {
        if (_this3.value) {
          _this3.updatePopper();
        }
      });
    }
  },

  watch: {
    focusing: function focusing(val) {
      if (val) {
        Object(dom_["addClass"])(this.referenceElm, 'focusing');
      } else {
        Object(dom_["removeClass"])(this.referenceElm, 'focusing');
      }
    }
  },
  methods: {
    show: function show() {
      this.setExpectedState(true);
      this.handleShowPopper();
    },
    hide: function hide() {
      this.setExpectedState(false);
      this.debounceClose();
    },
    handleFocus: function handleFocus() {
      this.focusing = true;
      this.show();
    },
    handleBlur: function handleBlur() {
      this.focusing = false;
      this.hide();
    },
    removeFocusing: function removeFocusing() {
      this.focusing = false;
    },
    addTooltipClass: function addTooltipClass(prev) {
      if (!prev) {
        return 'el-tooltip';
      } else {
        return 'el-tooltip ' + prev.replace('el-tooltip', '');
      }
    },
    handleShowPopper: function handleShowPopper() {
      var _this4 = this;

      if (!this.expectedState || this.manual) return;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        _this4.showPopper = true;
      }, this.openDelay);

      if (this.hideAfter > 0) {
        this.timeoutPending = setTimeout(function () {
          _this4.showPopper = false;
        }, this.hideAfter);
      }
    },
    handleClosePopper: function handleClosePopper() {
      if (this.enterable && this.expectedState || this.manual) return;
      clearTimeout(this.timeout);

      if (this.timeoutPending) {
        clearTimeout(this.timeoutPending);
      }
      this.showPopper = false;

      if (this.disabled) {
        this.doDestroy();
      }
    },
    setExpectedState: function setExpectedState(expectedState) {
      if (expectedState === false) {
        clearTimeout(this.timeoutPending);
      }
      this.expectedState = expectedState;
    },
    getFirstElement: function getFirstElement() {
      var slots = this.$slots.default;
      if (!Array.isArray(slots)) return null;
      var element = null;
      for (var index = 0; index < slots.length; index++) {
        if (slots[index] && slots[index].tag) {
          element = slots[index];
          break;
        }      }
      return element;
    }
  },

  beforeDestroy: function beforeDestroy() {
    this.popperVM && this.popperVM.$destroy();
  },
  destroyed: function destroyed() {
    var reference = this.referenceElm;
    if (reference.nodeType === 1) {
      Object(dom_["off"])(reference, 'mouseenter', this.show);
      Object(dom_["off"])(reference, 'mouseleave', this.hide);
      Object(dom_["off"])(reference, 'focus', this.handleFocus);
      Object(dom_["off"])(reference, 'blur', this.handleBlur);
      Object(dom_["off"])(reference, 'click', this.removeFocusing);
    }
  }
});
// CONCATENATED MODULE: ./packages/tooltip/index.js


/* istanbul ignore next */
main.install = function (Vue) {
  Vue.component(main.name, main);
};

/* harmony default export */ __webpack_exports__["default"] = (main);

/***/ }),

/***/ 19:
/***/ (function(module, exports) {

module.exports = debounce$2;

/***/ }),

/***/ 2:
/***/ (function(module, exports) {

module.exports = dom;

/***/ }),

/***/ 3:
/***/ (function(module, exports) {

module.exports = util;

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

module.exports = vuePopper;

/***/ }),

/***/ 7:
/***/ (function(module, exports) {

module.exports = Vue;

/***/ })

/******/ });
});

var _Tooltip = unwrapExports(tooltip);

/**
 * Adapted from https://github.com/alice/modality
 * Version: 1.0.2
 */
document.addEventListener('DOMContentLoaded', function () {
  var hadKeyboardEvent = false;
  var keyboardModalityWhitelist = ['input:not([type])', 'input[type=text]', 'input[type=number]', 'input[type=date]', 'input[type=time]', 'input[type=datetime]', 'textarea', '[role=textbox]', '[supports-modality=keyboard]'].join(',');
  var isHandlingKeyboardThrottle;

  var matcher = function () {
    var el = document.body;

    if (el.matchesSelector) {
      return el.matchesSelector;
    }

    if (el.webkitMatchesSelector) {
      return el.webkitMatchesSelector;
    }

    if (el.mozMatchesSelector) {
      return el.mozMatchesSelector;
    }

    if (el.msMatchesSelector) {
      return el.msMatchesSelector;
    }

    console.error("Couldn't find any matchesSelector method on document.body.");
  }();

  var disableFocusRingByDefault = function disableFocusRingByDefault() {
    var css = 'body:not([modality=keyboard]) :focus { outline: none; }';
    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';
    style.id = 'disable-focus-ring';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }

    head.insertBefore(style, head.firstChild);
  };

  var focusTriggersKeyboardModality = function focusTriggersKeyboardModality(el) {
    var triggers = false;

    if (matcher) {
      triggers = matcher.call(el, keyboardModalityWhitelist) && matcher.call(el, ':not([readonly])');
    }

    return triggers;
  };

  disableFocusRingByDefault();
  document.body.addEventListener('keydown', function () {
    hadKeyboardEvent = true;

    if (isHandlingKeyboardThrottle) {
      clearTimeout(isHandlingKeyboardThrottle);
    }

    isHandlingKeyboardThrottle = setTimeout(function () {
      hadKeyboardEvent = false;
    }, 100);
  }, true);
  document.body.addEventListener('focus', function (e) {
    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
      document.body.setAttribute('modality', 'keyboard');
    }
  }, true);
  document.body.addEventListener('blur', function () {
    document.body.removeAttribute('modality');
  }, true);
});

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		Object.keys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	Object.keys(source).forEach(function(key) {
		if (!options.isMergeableObject(source[key]) || !target[key]) {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		} else {
			destination[key] = deepmerge(target[key], source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

function configure(Component, props) {
  Object.keys(props).forEach(function (propName) {
    if (Component.props[propName] === undefined) {
      return;
    }

    var defaultValue = Component.props[propName].default;

    if (_typeof_1(defaultValue) === 'object') {
      Component.props[propName].default = deepmerge_1(defaultValue, props[propName]);
      return;
    }

    Component.props[propName].default = props[propName];
  });
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject$4(obj) {
  return obj !== null && _typeof_1(obj) === 'object';
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */

function looseEqual$1(a, b) {
  // eslint-disable-next-line eqeqeq
  return a == b || (isObject$4(a) && isObject$4(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
}
/**
 * Check if a val exists in arr using looseEqual comparison
 */

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual$1(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Check if the given string starts with the query, beginning
 * at the given position
 */

function startsWith(string, query) {
  var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return string.substr(position, query.length) === query;
}

//
//
//
//
//
//
var script$1C = {
  name: 'ui-aside',
  componentName: 'UiAside',
  props: {
    width: {
      type: String,
      default: '200px'
    }
  }
};

function normalizeComponent$3(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function (context) {
      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

/* script */
var __vue_script__$1C = script$1C;
/* template */

var __vue_render__$1s = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('aside', {
    staticClass: "ui-aside",
    style: {
      width: _vm.width
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$1s = [];
/* style */

var __vue_inject_styles__$1C = undefined;
/* scoped */

var __vue_scope_id__$1C = undefined;
/* module identifier */

var __vue_module_identifier__$1C = undefined;
/* functional template */

var __vue_is_functional_template__$1C = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1C = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1s,
  staticRenderFns: __vue_staticRenderFns__$1s
}, __vue_inject_styles__$1C, __vue_script__$1C, __vue_scope_id__$1C, __vue_is_functional_template__$1C, __vue_module_identifier__$1C, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1B = {
  name: 'ui-icon',
  props: {
    icon: String,
    iconSet: {
      type: String,
      default: 'material-icons'
    },
    ariaLabel: String,
    removeText: {
      type: Boolean,
      default: false
    },
    useSvg: {
      type: Boolean,
      default: false
    }
  }
};

/* script */
var __vue_script__$1B = script$1B;
/* template */

var __vue_render__$1r = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', {
    staticClass: "ui-icon",
    class: [_vm.iconSet, _vm.icon],
    attrs: {
      "aria-label": _vm.ariaLabel
    },
    on: {
      "click": function click($event) {
        return _vm.$emit('click', $event);
      }
    }
  }, [_vm.useSvg ? _c('svg', {
    staticClass: "ui-icon__svg"
  }, [_c('use', {
    attrs: {
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xlink:href": '#' + _vm.icon
    }
  })]) : _vm._t("default", [_vm._v(_vm._s(_vm.removeText ? null : _vm.icon))])], 2);
};

var __vue_staticRenderFns__$1r = [];
/* style */

var __vue_inject_styles__$1B = undefined;
/* scoped */

var __vue_scope_id__$1B = undefined;
/* module identifier */

var __vue_module_identifier__$1B = undefined;
/* functional template */

var __vue_is_functional_template__$1B = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1B = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1r,
  staticRenderFns: __vue_staticRenderFns__$1r
}, __vue_inject_styles__$1B, __vue_script__$1B, __vue_scope_id__$1B, __vue_is_functional_template__$1B, __vue_module_identifier__$1B, false, undefined, undefined, undefined);

var at$1 = _stringAt(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
var _advanceStringIndex = function (S, index, unicode) {
  return index + (unicode ? at$1(S, index).length : 1);
};

var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
var _regexpExecAbstract = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (_classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

// 21.2.5.3 get RegExp.prototype.flags

var _flags = function () {
  var that = _anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX$1 = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX$1] !== 0 || re2[LAST_INDEX$1] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX$1];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX$1] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var _regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: _regexpExec !== /./.exec
}, {
  exec: _regexpExec
});

var SPECIES$3 = _wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

var _fixReWks = function (KEY, length, exec) {
  var SYMBOL = _wks(KEY);

  var DELEGATES_TO_SYMBOL = !_fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES$3] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      _defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === _regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    _redefine(String.prototype, KEY, strfn);
    _hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
_fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = _anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = _regexpExecAbstract(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(_toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = _toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

// 7.2.8 IsRegExp(argument)


var MATCH$1 = _wks('match');
var _isRegexp = function (it) {
  var isRegExp;
  return _isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
};

// 7.3.20 SpeciesConstructor(O, defaultConstructor)


var SPECIES$2 = _wks('species');
var _speciesConstructor = function (O, D) {
  var C = _anObject(O).constructor;
  var S;
  return C === undefined || (S = _anObject(C)[SPECIES$2]) == undefined ? D : _aFunction(S);
};

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !_fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
_fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!_isRegexp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = _regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = _anObject(regexp);
      var S = String(this);
      var C = _speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = _advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

/**
 * Adapted from dominus v6.0.1
 * https://github.com/bevacqua/dominus/blob/master/src/classes.js
 */
var trim$3 = /^\s+|\s+$/g;
var whitespace = /\s+/g;

function interpret(input) {
  return typeof input === 'string' ? input.replace(trim$3, '').split(whitespace) : input;
}

function classes(el) {
  if (isElement(el)) {
    return (el.getAttribute('class') || '').replace(trim$3, '').split(whitespace);
  }

  return [];
}

function set(el, input) {
  if (isElement(el)) {
    el.setAttribute('class', interpret(input).join(' '));
  }
}

function add(el, input) {
  var current = remove(el, input);
  var values = interpret(input);
  current.push.apply(current, values);
  set(el, current);
  return current;
}

function remove(el, input) {
  var current = classes(el);
  var values = interpret(input);
  values.forEach(function (value) {
    var i = current.indexOf(value);

    if (i !== -1) {
      current.splice(i, 1);
    }
  });
  set(el, current);
  return current;
}

function contains$1(el, input) {
  var current = classes(el);
  var values = interpret(input);
  return values.every(function (value) {
    return current.indexOf(value) !== -1;
  });
}

function isElement(o) {
  var elementObjects = (typeof HTMLElement === "undefined" ? "undefined" : _typeof_1(HTMLElement)) === 'object';
  return elementObjects ? o instanceof HTMLElement : isElementObject(o);
}

function isElementObject(o) {
  return o && _typeof_1(o) === 'object' && typeof o.nodeName === 'string' && o.nodeType === 1;
}

var classlist = {
  add: add,
  remove: remove,
  contains: contains$1,
  has: contains$1,
  set: set,
  get: classes
};

function validate(ref, warning) {
  var isValid = ref instanceof Element || ref && ref._isVue || typeof ref === 'string';

  if (!isValid && warning) {
    console.warn(warning);
  }

  return isValid;
}
function resolve(ref, fallback) {
  if (ref instanceof Element) {
    return ref;
  } else if (ref && ref._isVue) {
    return ref.$el;
  } else if (typeof ref === 'string') {
    return document.querySelector(ref);
  }

  return fallback;
}
var elementRef = {
  validate: validate,
  resolve: resolve
};

//

var startRipple = function startRipple(eventType, event) {
  var holder = event.currentTarget || event.target;

  if (holder && !classlist.has(holder, 'ui-ripple-ink')) {
    holder = holder.querySelector('.ui-ripple-ink');
  }

  if (!holder) {
    return;
  } // Store the event use to generate this ripple on the holder: don't allow
  // further events of different types until we're done. Prevents double
  // ripples from mousedown/touchstart.


  var prev = holder.getAttribute('data-ui-event');

  if (prev && prev !== eventType) {
    return;
  }

  holder.setAttribute('data-ui-event', eventType); // Get ripple position

  var rect = holder.getBoundingClientRect();
  var x = event.clientX - rect.left;
  var y = event.clientY - rect.top; // Create the ripple

  var ripple = document.createElement('div');
  var max;

  if (rect.width === rect.height) {
    max = rect.width * 1.412;
  } else {
    max = Math.sqrt(rect.width * rect.width + rect.height * rect.height);
  }

  var size = max * 2 + 'px'; // Position the ripple

  ripple.style.width = size;
  ripple.style.height = size;
  ripple.style.marginLeft = -max + x + 'px';
  ripple.style.marginTop = -max + y + 'px'; // Add the ripple element

  ripple.className = 'ui-ripple-ink__ink';
  holder.appendChild(ripple);
  setTimeout(function () {
    classlist.add(ripple, 'is-held');
  }, 0);
  var releaseEvent = eventType === 'mousedown' ? 'mouseup' : 'touchend';

  var handleRelease = function handleRelease() {
    document.removeEventListener(releaseEvent, handleRelease);
    classlist.add(ripple, 'is-done'); // Larger than the animation duration in CSS

    var timeout = 650;
    setTimeout(function () {
      holder.removeChild(ripple);

      if (holder.children.length === 0) {
        holder.removeAttribute('data-ui-event');
      }
    }, timeout);
  };

  document.addEventListener(releaseEvent, handleRelease);
};

var handleMouseDown = function handleMouseDown(e) {
  // Trigger on left click only
  if (e.button === 0) {
    startRipple(e.type, e);
  }
};

var handleTouchStart = function handleTouchStart(e) {
  if (e.changedTouches) {
    for (var i = 0; i < e.changedTouches.length; ++i) {
      startRipple(e.type, e.changedTouches[i]);
    }
  }
};

var script$1A = {
  name: 'ui-ripple-ink',
  props: {
    trigger: {
      validator: function validator(value) {
        return elementRef.validate(value, '[UiRippleInk]: Invalid prop: "trigger". Expected Element, VueComponent or CSS selector string.');
      }
    }
  },
  watch: {
    trigger: function trigger() {
      this.setupRipple();
    }
  },
  created: function created() {
    // Instance data, not declared in data() as we don't want reactivity.
    this.triggerEl = null;
  },
  mounted: function mounted() {
    this.setupRipple();
  },
  beforeDestroy: function beforeDestroy() {
    this.destroyRipple();
  },
  methods: {
    setupRipple: function setupRipple() {
      this.triggerEl = elementRef.resolve(this.trigger, this.$el.parentElement);

      if (!this.triggerEl) {
        console.error('[UiRippleInk]: Trigger element not found.');
        return;
      }

      this.triggerEl.addEventListener('touchstart', handleTouchStart);
      this.triggerEl.addEventListener('mousedown', handleMouseDown);
    },
    destroyRipple: function destroyRipple() {
      if (!this.triggerEl) {
        return;
      }

      this.triggerEl.removeEventListener('mousedown', handleMouseDown);
      this.triggerEl.removeEventListener('touchstart', handleTouchStart);
    }
  }
};

/* script */
var __vue_script__$1A = script$1A;
/* template */

var __vue_render__$1q = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-ripple-ink"
  });
};

var __vue_staticRenderFns__$1q = [];
/* style */

var __vue_inject_styles__$1A = undefined;
/* scoped */

var __vue_scope_id__$1A = undefined;
/* module identifier */

var __vue_module_identifier__$1A = undefined;
/* functional template */

var __vue_is_functional_template__$1A = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1A = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1q,
  staticRenderFns: __vue_staticRenderFns__$1q
}, __vue_inject_styles__$1A, __vue_script__$1A, __vue_scope_id__$1A, __vue_is_functional_template__$1A, __vue_module_identifier__$1A, false, undefined, undefined, undefined);

//
var script$1z = {
  name: 'ui-close-button',
  props: {
    size: {
      type: String,
      default: 'normal' // 'mini', small', 'normal', or 'large'

    },
    color: {
      type: String,
      default: 'black' // 'black', or 'white'

    },
    disableRipple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-close-button--size-".concat(this.size), "ui-close-button--color-".concat(this.color), {
        'is-disabled': this.disabled || this.loading
      }];
    }
  },
  methods: {
    onClick: function onClick(e) {
      this.$emit('click', e);
    }
  },
  components: {
    UiIcon: __vue_component__$1B,
    UiRippleInk: __vue_component__$1A
  }
};

/* script */
var __vue_script__$1z = script$1z;
/* template */

var __vue_render__$1p = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('button', {
    staticClass: "ui-close-button",
    class: _vm.classes,
    attrs: {
      "aria-label": "Close",
      "type": "button",
      "disabled": _vm.disabled
    },
    on: {
      "click": _vm.onClick
    }
  }, [_c('div', {
    staticClass: "ui-close-button__icon"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M18.984 6.422L13.406 12l5.578 5.578-1.406 1.406L12 13.406l-5.578 5.578-1.406-1.406L10.594 12 5.016 6.422l1.406-1.406L12 10.594l5.578-5.578z"
    }
  })])])], 1), _vm._v(" "), _c('span', {
    staticClass: "ui-close-button__focus-ring"
  }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _c('ui-ripple-ink') : _vm._e()], 1);
};

var __vue_staticRenderFns__$1p = [];
/* style */

var __vue_inject_styles__$1z = undefined;
/* scoped */

var __vue_scope_id__$1z = undefined;
/* module identifier */

var __vue_module_identifier__$1z = undefined;
/* functional template */

var __vue_is_functional_template__$1z = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1z = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1p,
  staticRenderFns: __vue_staticRenderFns__$1p
}, __vue_inject_styles__$1z, __vue_script__$1z, __vue_scope_id__$1z, __vue_is_functional_template__$1z, __vue_module_identifier__$1z, false, undefined, undefined, undefined);

//
var script$1y = {
  name: 'ui-alert',
  props: {
    type: {
      type: String,
      default: 'info' // 'info', 'success', 'warning', or 'error'

    },
    removeIcon: {
      type: Boolean,
      default: false
    },
    disableAnimation: {
      type: Boolean,
      default: false
    },
    dismissible: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-alert--type-".concat(this.type), {
        'has-no-transition': this.disableAnimation
      }];
    }
  },
  methods: {
    dismissAlert: function dismissAlert() {
      this.$emit('dismiss');
    }
  },
  components: {
    UiCloseButton: __vue_component__$1z,
    UiIcon: __vue_component__$1B
  }
};

/* script */
var __vue_script__$1y = script$1y;
/* template */

var __vue_render__$1o = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": _vm.disableAnimation ? null : 'ui-alert--transition-toggle'
    }
  }, [_c('div', {
    staticClass: "ui-alert",
    class: _vm.classes,
    attrs: {
      "role": "alert"
    }
  }, [_c('div', {
    staticClass: "ui-alert__body"
  }, [!_vm.removeIcon ? _c('div', {
    staticClass: "ui-alert__icon"
  }, [_vm._t("icon", [_vm.type === 'info' ? _c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M12.984 9V6.984h-1.97V9h1.97zm0 8.016v-6h-1.97v6h1.97zm-.984-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
    }
  })])]) : _vm._e(), _vm._v(" "), _vm.type === 'success' ? _c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M9.984 17.016l9-9-1.406-1.453-7.594 7.594-3.563-3.563L5.016 12zm2.016-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
    }
  })])]) : _vm._e(), _vm._v(" "), _vm.type === 'warning' ? _c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M12.984 14.016v-4.03h-1.97v4.03h1.97zm0 3.984v-2.016h-1.97V18h1.97zm-12 3L12 2.016 23.016 21H.986z"
    }
  })])]) : _vm._e(), _vm._v(" "), _vm.type === 'error' ? _c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M12.984 12.984v-6h-1.97v6h1.97zm0 4.032V15h-1.97v2.016h1.97zm-.984-15c5.53 0 9.984 4.453 9.984 9.984S17.53 21.984 12 21.984 2.016 17.53 2.016 12 6.47 2.016 12 2.016z"
    }
  })])]) : _vm._e()])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-alert__content"
  }, [_vm._t("default")], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-alert__dismiss-button"
  }, [_vm.dismissible ? _c('ui-close-button', {
    attrs: {
      "size": "small"
    },
    on: {
      "click": _vm.dismissAlert
    }
  }) : _vm._e()], 1)])])]);
};

var __vue_staticRenderFns__$1o = [];
/* style */

var __vue_inject_styles__$1y = undefined;
/* scoped */

var __vue_scope_id__$1y = undefined;
/* module identifier */

var __vue_module_identifier__$1y = undefined;
/* functional template */

var __vue_is_functional_template__$1y = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1y = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1o,
  staticRenderFns: __vue_staticRenderFns__$1o
}, __vue_inject_styles__$1y, __vue_script__$1y, __vue_scope_id__$1y, __vue_is_functional_template__$1y, __vue_module_identifier__$1y, false, undefined, undefined, undefined);

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */


var check = function (O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

var setPrototypeOf = _setProto.set;
var _inheritIfRequired = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

var space = '[' + _stringWs + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = _fails(function () {
    return !!_stringWs[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim$2) : _stringWs[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  _export(_export.P + _export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim$2 = exporter.trim = function (string, TYPE) {
  string = String(_defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

var _stringTrim = exporter;

var gOPN$1 = _objectGopn.f;
var gOPD = _objectGopd.f;
var dP$2 = _objectDp.f;
var $trim = _stringTrim.trim;
var NUMBER = 'Number';
var $Number = _global[NUMBER];
var Base$1 = $Number;
var proto$1 = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = _cof(_objectCreate(proto$1)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber$1 = function (argument) {
  var it = _toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? _fails(function () { proto$1.valueOf.call(that); }) : _cof(that) != NUMBER)
        ? _inheritIfRequired(new Base$1(toNumber$1(it)), that, $Number) : toNumber$1(it);
  };
  for (var keys$2 = _descriptors ? gOPN$1(Base$1) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j$1 = 0, key; keys$2.length > j$1; j$1++) {
    if (_has(Base$1, key = keys$2[j$1]) && !_has($Number, key)) {
      dP$2($Number, key, gOPD(Base$1, key));
    }
  }
  $Number.prototype = proto$1;
  proto$1.constructor = $Number;
  _redefine(_global, NUMBER, $Number);
}

//
//
//
//
//
//
//
//
//
//
//
//
var script$1x = {
  name: 'ui-badge',
  props: {
    value: {
      type: [String, Number],
      default: ''
    },
    max: {
      type: Number,
      default: Infinity
    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    circle: Boolean,
    dot: Boolean,
    hidden: Boolean,
    badgeClass: [String, Object, Array]
  },
  computed: {
    classes: function classes() {
      return ["ui-badge", "ui-badge--color-".concat(this.color), {
        'is-circle': this.circle
      }, {
        'is-dot': this.dot
      }, {
        'is-hidden': this.hidden
      }, {
        'is-fixed': this.$slots.default && this.$slots.default.length > 0
      }].concat(this.badgeClass || '');
    },
    content: function content() {
      return isNaN(this.value) ? this.value : Number(this.value) < Number(this.max) ? this.value : "".concat(this.max, "+");
    }
  }
};

/* script */
var __vue_script__$1x = script$1x;
/* template */

var __vue_render__$1n = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', _vm._g({
    staticClass: "ui-badge-container"
  }, _vm.$listeners), [_vm._t("default"), _vm._v(" "), !_vm.hidden ? [_vm.dot ? _c('sup', {
    class: _vm.classes
  }) : _c('em', {
    class: _vm.classes
  }, [_vm._t("content", [_vm._v(_vm._s(_vm.content))])], 2)] : _vm._e()], 2);
};

var __vue_staticRenderFns__$1n = [];
/* style */

var __vue_inject_styles__$1x = undefined;
/* scoped */

var __vue_scope_id__$1x = undefined;
/* module identifier */

var __vue_module_identifier__$1x = undefined;
/* functional template */

var __vue_is_functional_template__$1x = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1x = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1n,
  staticRenderFns: __vue_staticRenderFns__$1n
}, __vue_inject_styles__$1x, __vue_script__$1x, __vue_scope_id__$1x, __vue_is_functional_template__$1x, __vue_module_identifier__$1x, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1w = {
  name: 'ui-progress-circular',
  props: {
    type: {
      type: String,
      default: 'indeterminate' // 'indeterminate' or 'determinate'

    },
    color: {
      type: String,
      default: 'primary' // 'primary', 'accent', multi-color', 'black', or 'white'

    },
    progress: {
      type: Number,
      default: 0
    },
    size: {
      type: Number,
      default: 32
    },
    stroke: Number,
    autoStroke: {
      type: Boolean,
      default: true
    },
    disableTransition: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-progress-circular--color-".concat(this.color), "ui-progress-circular--type-".concat(this.type)];
    },
    strokeDashArray: function strokeDashArray() {
      var circumference = 2 * Math.PI * this.radius; // Use first 3 decimal places, rounded as appropriate

      return Math.round(circumference * 1000) / 1000;
    },
    strokeDashOffset: function strokeDashOffset() {
      var progress = this.moderateProgress(this.progress);
      var circumference = 2 * Math.PI * this.radius;
      return (100 - progress) / 100 * circumference;
    },
    radius: function radius() {
      var stroke = this.stroke ? this.stroke : 4;
      return (this.size - stroke) / 2;
    },
    calculatedStroke: function calculatedStroke() {
      if (this.stroke) {
        return this.stroke;
      }

      if (this.autoStroke) {
        return parseInt(this.size / 8, 10);
      }

      return 4;
    }
  },
  methods: {
    moderateProgress: function moderateProgress(progress) {
      if (isNaN(progress) || progress < 0) {
        return 0;
      }

      if (progress > 100) {
        return 100;
      }

      return progress;
    }
  }
};

/* script */
var __vue_script__$1w = script$1w;
/* template */

var __vue_render__$1m = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": _vm.disableTransition ? null : 'ui-progress-circular--transition-fade'
    }
  }, [_c('div', {
    staticClass: "ui-progress-circular",
    class: _vm.classes,
    style: {
      width: _vm.size + 'px',
      height: _vm.size + 'px'
    }
  }, [_vm.type === 'determinate' ? _c('svg', {
    staticClass: "ui-progress-circular__determinate",
    attrs: {
      "role": "progressbar",
      "aria-valuemax": 100,
      "aria-valuemin": 0,
      "aria-valuenow": _vm.progress,
      "height": _vm.size,
      "width": _vm.size
    }
  }, [_c('circle', {
    staticClass: "ui-progress-circular__determinate-path",
    style: {
      'stroke-dashoffset': _vm.strokeDashOffset,
      'stroke-width': _vm.calculatedStroke
    },
    attrs: {
      "fill": "transparent",
      "stroke-dashoffset": "0",
      "cx": _vm.size / 2,
      "cy": _vm.size / 2,
      "r": _vm.radius,
      "stroke-dasharray": _vm.strokeDashArray
    }
  })]) : _c('svg', {
    staticClass: "ui-progress-circular__indeterminate",
    attrs: {
      "role": "progressbar",
      "viewBox": "25 25 50 50",
      "aria-valuemax": 100,
      "aria-valuemin": 0
    }
  }, [_c('circle', {
    staticClass: "ui-progress-circular__indeterminate-path",
    attrs: {
      "cx": "50",
      "cy": "50",
      "fill": "none",
      "r": "20",
      "stroke-miterlimit": "10",
      "stroke-width": _vm.calculatedStroke
    }
  })])])]);
};

var __vue_staticRenderFns__$1m = [];
/* style */

var __vue_inject_styles__$1w = undefined;
/* scoped */

var __vue_scope_id__$1w = undefined;
/* module identifier */

var __vue_module_identifier__$1w = undefined;
/* functional template */

var __vue_is_functional_template__$1w = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1w = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1m,
  staticRenderFns: __vue_staticRenderFns__$1m
}, __vue_inject_styles__$1w, __vue_script__$1w, __vue_scope_id__$1w, __vue_is_functional_template__$1w, __vue_module_identifier__$1w, false, undefined, undefined, undefined);

//
var script$1v = {
  name: 'ui-button',
  props: {
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary' or 'text'

    },
    buttonType: String,
    href: String,
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    raised: {
      type: Boolean,
      default: false
    },
    circle: {
      type: Boolean,
      default: false
    },
    icon: String,
    iconPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    loading: {
      type: Boolean,
      default: false
    },
    disableRipple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-button--type-".concat(this.type), "ui-button--color-".concat(this.color), "ui-button--icon-position-".concat(this.iconPosition), "ui-button--size-".concat(this.size), {
        'is-anchor': this.isAnchor
      }, {
        'is-raised': this.raised
      }, {
        'is-circle': this.circle
      }, {
        'is-loading': this.loading
      }, {
        'is-disabled': this.disabled || this.loading
      }];
    },
    isAnchor: function isAnchor() {
      return this.href !== undefined;
    },
    progressColor: function progressColor() {
      if (this.color === 'default' || this.type === 'secondary') {
        return 'black';
      }

      return 'white';
    }
  },
  methods: {
    onClick: function onClick(e) {
      this.$emit('click', e);
    }
  },
  components: {
    UiIcon: __vue_component__$1B,
    UiProgressCircular: __vue_component__$1w,
    UiRippleInk: __vue_component__$1A
  }
};

/* script */
var __vue_script__$1v = script$1v;
/* template */

var __vue_render__$1l = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c(_vm.isAnchor ? 'a' : 'button', {
    tag: "component",
    staticClass: "ui-button",
    class: _vm.classes,
    attrs: {
      "disabled": _vm.disabled || _vm.loading,
      "href": _vm.isAnchor ? _vm.disabled ? null : _vm.href : null,
      "type": _vm.isAnchor ? null : _vm.buttonType
    },
    on: {
      "click": _vm.onClick
    }
  }, [_c('div', {
    staticClass: "ui-button__content"
  }, [_vm.icon || _vm.$slots.icon ? _c('div', {
    staticClass: "ui-button__icon"
  }, [_vm._t("icon", [_c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  })])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-button__focus-ring"
  }), _vm._v(" "), _vm.loading ? _c('ui-progress-circular', {
    staticClass: "ui-button__progress",
    attrs: {
      "disable-transition": "",
      "color": _vm.progressColor,
      "size": 18,
      "stroke": 4.5
    }
  }) : _vm._e(), _vm._v(" "), 'text' != _vm.type && !_vm.disableRipple && !_vm.disabled ? _c('ui-ripple-ink') : _vm._e()], 1);
};

var __vue_staticRenderFns__$1l = [];
/* style */

var __vue_inject_styles__$1v = undefined;
/* scoped */

var __vue_scope_id__$1v = undefined;
/* module identifier */

var __vue_module_identifier__$1v = undefined;
/* functional template */

var __vue_is_functional_template__$1v = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1v = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1l,
  staticRenderFns: __vue_staticRenderFns__$1l
}, __vue_inject_styles__$1v, __vue_script__$1v, __vue_scope_id__$1v, __vue_is_functional_template__$1v, __vue_module_identifier__$1v, false, undefined, undefined, undefined);

var SPECIES$1 = _wks('species');

var _arraySpeciesConstructor = function (original) {
  var C;
  if (_isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
    if (_isObject(C)) {
      C = C[SPECIES$1];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


var _arraySpeciesCreate = function (original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex





var _arrayMethods = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $find$1 = _arrayMethods(6);
var KEY$1 = 'findIndex';
var forced$1 = true;
// Shouldn't skip holes
if (KEY$1 in []) Array(1)[KEY$1](function () { forced$1 = false; });
_export(_export.P + _export.F * forced$1, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY$1);

// https://github.com/tc39/Array.prototype.includes

var $includes = _arrayIncludes(true);

_export(_export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

_addToUnscopables('includes');

// helper for String#{startsWith, endsWith, includes}



var _stringContext = function (that, searchString, NAME) {
  if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(_defined(that));
};

var MATCH = _wks('match');
var _failsIsRegexp = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

var INCLUDES = 'includes';

_export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~_stringContext(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var arrayLikeToArray = _arrayLikeToArray$3;

function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

var arrayWithoutHoles = _arrayWithoutHoles$2;

function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

var iterableToArray = _iterableToArray$2;

function _unsupportedIterableToArray$3(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

var unsupportedIterableToArray = _unsupportedIterableToArray$3;

function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableSpread = _nonIterableSpread$2;

function _toConsumableArray$2(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray$2;

var _redefineAll = function (target, src, safe) {
  for (var key in src) _redefine(target, key, src[key], safe);
  return target;
};

var _anInstance = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

var _forOf = createCommonjsModule(function (module) {
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
  var f = _ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = _iterCall(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;
});

var SPECIES = _wks('species');

var _setSpecies = function (KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

var _validateCollection = function (it, TYPE) {
  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

var dP$1 = _objectDp.f;









var fastKey = _meta.fastKey;

var SIZE = _descriptors ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

var _collectionStrong = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = _objectCreate(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = _validateCollection(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        _validateCollection(this, NAME);
        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(_validateCollection(this, NAME), key);
      }
    });
    if (_descriptors) dP$1(C.prototype, 'size', {
      get: function () {
        return _validateCollection(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    _iterDefine(C, NAME, function (iterated, kind) {
      this._t = _validateCollection(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return _iterStep(1);
      }
      // return step by kind
      if (kind == 'keys') return _iterStep(0, entry.k);
      if (kind == 'values') return _iterStep(0, entry.v);
      return _iterStep(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    _setSpecies(NAME);
  }
};
_collectionStrong.getConstructor;
_collectionStrong.def;
_collectionStrong.getEntry;
_collectionStrong.setStrong;

var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = _global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    _redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    _redefineAll(C.prototype, methods);
    _meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = _fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = _iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME);
        var that = _inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  _setToStringTag(C, NAME);

  O[NAME] = C;
  _export(_export.G + _export.W + _export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

var SET = 'Set';

// 23.2 Set Objects
_collection(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
  }
}, _collectionStrong);

// fast apply, http://jsperf.lnkit.com/fast-apply/5
var _invoke = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

var process$3 = _global.process;
var setTask = _global.setImmediate;
var clearTask = _global.clearImmediate;
var MessageChannel$1 = _global.MessageChannel;
var Dispatch = _global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (_cof(process$3) == 'process') {
    defer = function (id) {
      process$3.nextTick(_ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(_ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel$1) {
    channel = new MessageChannel$1();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = _ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
    defer = function (id) {
      _global.postMessage(id + '', '*');
    };
    _global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
    defer = function (id) {
      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
        _html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(_ctx(run, id, 1), 0);
    };
  }
}
var _task = {
  set: setTask,
  clear: clearTask
};

var macrotask = _task.set;
var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
var process$2 = _global.process;
var Promise$2 = _global.Promise;
var isNode$1 = _cof(process$2) == 'process';

var _microtask = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode$1 && (parent = process$2.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode$1) {
    notify = function () {
      process$2.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise$2 && Promise$2.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise$2.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(_global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

// 25.4.1.5 NewPromiseCapability(C)


function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = _aFunction(resolve);
  this.reject = _aFunction(reject);
}

var f$1 = function (C) {
  return new PromiseCapability(C);
};

var _newPromiseCapability = {
	f: f$1
};

var _perform = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

var navigator$1 = _global.navigator;

var _userAgent = navigator$1 && navigator$1.userAgent || '';

var _promiseResolve = function (C, x) {
  _anObject(C);
  if (_isObject(x) && x.constructor === C) return x;
  var promiseCapability = _newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

var task = _task.set;
var microtask = _microtask();




var PROMISE = 'Promise';
var TypeError$1 = _global.TypeError;
var process$1 = _global.process;
var versions = process$1 && process$1.versions;
var v8 = versions && versions.v8 || '';
var $Promise = _global[PROMISE];
var isNode = _classof(process$1) == 'process';
var empty$1 = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
      exec(empty$1, empty$1);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty$1) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && _userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(_global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = _perform(function () {
        if (isNode) {
          process$1.emit('unhandledRejection', value, promise);
        } else if (handler = _global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = _global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(_global, function () {
    var handler;
    if (isNode) {
      process$1.emit('rejectionHandled', promise);
    } else if (handler = _global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    _anInstance(this, $Promise, PROMISE, '_h');
    _aFunction(executor);
    Internal.call(this);
    try {
      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = _redefineAll($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process$1.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = _ctx($resolve, promise, 1);
    this.reject = _ctx($reject, promise, 1);
  };
  _newPromiseCapability.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });
_setToStringTag($Promise, PROMISE);
_setSpecies(PROMISE);
Wrapper = _core[PROMISE];

// statics
_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
_export(_export.S + _export.F * (!USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return _promiseResolve(this, x);
  }
});
_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {
  $Promise.all(iter)['catch'](empty$1);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = _perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      _forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = _perform(function () {
      _forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

// 21.2.5.3 get RegExp.prototype.flags()
if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
  configurable: true,
  get: _flags
});

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  _redefine(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (_fails(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = _anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

_wksDefine('asyncIterator');

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction$3(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE$2(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE$2(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE$2(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE$2(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck$1 = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass$1 = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty$1 = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends$2 = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends$2({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE$2(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE$2(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE$2()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends$2({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find$1(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex$1(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find$1(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction$3(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update$1() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends$2({}, attributes, data.attributes);
  data.styles = _extends$2({}, styles, data.styles);
  data.arrowStyles = _extends$2({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find$1(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends$2({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find$1(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty$1({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty$1({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends$2({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty$1({}, side, reference[side]),
      end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends$2({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find$1(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" â or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck$1(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce$1(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends$2({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends$2({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends$2({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends$2({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction$3(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass$1(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update$1.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$1;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = _freeGlobal || freeSelf$1 || Function('return this')();

var _root = root$1;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$f.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$f.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$e.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$3;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$2(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$2;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$d = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$d.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map$1 = _getNative(_root, 'Map');

var _Map = Map$1;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$c.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$9.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays;

/** Built-in value references. */
var Uint8Array$1 = _root.Uint8Array;

var _Uint8Array = Uint8Array$1;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq_1(+object, +other);

    case errorTag$1:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$2:
      var convert = _mapToArray;

    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$2 = Array.isArray;

var isArray_1 = isArray$2;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$9.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$8.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    objectTag$3 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] =
typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys$1(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys$1;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise$1 = _getNative(_root, 'Promise');

var _Promise = Promise$1;

/* Built-in method references that are verified to be native. */
var Set$1 = _getNative(_root, 'Set');

var _Set = Set$1;

/* Built-in method references that are verified to be native. */
var WeakMap = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap;

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (_Map && getTag(new _Map) != mapTag) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object),
      othIsArr = isArray_1(other),
      objTag = objIsArr ? arrayTag : _getTag(object),
      othTag = othIsArr ? arrayTag : _getTag(other);

  objTag = objTag == argsTag ? objectTag$1 : objTag;
  othTag = othTag == argsTag ? objectTag$1 : othTag;

  var objIsObj = objTag == objectTag$1,
      othIsObj = othTag == objectTag$1,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || isTypedArray_1(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

var _baseIsEqual = baseIsEqual;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual$1(value, other) {
  return _baseIsEqual(value, other);
}

var isEqual_1 = isEqual$1;

function getInternetExplorerVersion$1() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf('MSIE ');

  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');

  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');

  if (edge > 0) {
    // Edge (IE 12+) => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  } // other browser


  return -1;
} //


var isIE$1;

function initCompat$1() {
  if (!initCompat$1.init) {
    initCompat$1.init = true;
    isIE$1 = getInternetExplorerVersion$1() !== -1;
  }
}

var script$1u = {
  name: 'ResizeObserver',
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  mounted: function mounted() {
    var _this = this;

    initCompat$1();
    this.$nextTick(function () {
      _this._w = _this.$el.offsetWidth;
      _this._h = _this.$el.offsetHeight;

      if (_this.emitOnMount) {
        _this.emitSize();
      }
    });
    var object = document.createElement('object');
    this._resizeObject = object;
    object.setAttribute('aria-hidden', 'true');
    object.setAttribute('tabindex', -1);
    object.onload = this.addResizeHandlers;
    object.type = 'text/html';

    if (isIE$1) {
      this.$el.appendChild(object);
    }

    object.data = 'about:blank';

    if (!isIE$1) {
      this.$el.appendChild(object);
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify: function compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize: function emitSize() {
      this.$emit('notify', {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers: function addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);

      this.compareAndNotify();
    },
    removeResizeHandlers: function removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE$1 && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);
        }

        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};

function normalizeComponent$2(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function (context) {
      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}
/* script */


var __vue_script__$1u = script$1u;
/* template */

var __vue_render__$1k = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c("div", {
    staticClass: "resize-observer",
    attrs: {
      tabindex: "-1"
    }
  });
};

var __vue_staticRenderFns__$1k = [];
__vue_render__$1k._withStripped = true;
/* style */

var __vue_inject_styles__$1u = undefined;
/* scoped */

var __vue_scope_id__$1u = "data-v-8859cc6c";
/* module identifier */

var __vue_module_identifier__$1u = undefined;
/* functional template */

var __vue_is_functional_template__$1u = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1u = /*#__PURE__*/normalizeComponent$2({
  render: __vue_render__$1k,
  staticRenderFns: __vue_staticRenderFns__$1k
}, __vue_inject_styles__$1u, __vue_script__$1u, __vue_scope_id__$1u, __vue_is_functional_template__$1u, __vue_module_identifier__$1u, false, undefined, undefined, undefined);

function install$3(Vue) {
  // eslint-disable-next-line vue/component-definition-name-casing
  Vue.component('resize-observer', __vue_component__$1u);
  Vue.component('ResizeObserver', __vue_component__$1u);
}

var plugin$4 = {
  // eslint-disable-next-line no-undef
  version: "1.0.1",
  install: install$3
};
var GlobalVue$4 = null;

if (typeof window !== 'undefined') {
  GlobalVue$4 = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue$4 = global.Vue;
}

if (GlobalVue$4) {
  GlobalVue$4.use(plugin$4);
}

var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty$3 = defineProperty;

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty$3) {
    _defineProperty$3(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _baseAssignValue = baseAssignValue;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq_1(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignMergeValue = assignMergeValue;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

var _createBaseFor = createBaseFor;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

var _baseFor = baseFor;

var _cloneBuffer = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
});

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

var _cloneArrayBuffer = cloneArrayBuffer;

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var _cloneTypedArray = cloneTypedArray;

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

var _copyArray = copyArray;

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

var _baseCreate = baseCreate;

/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype;

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

var _initCloneObject = initCloneObject;

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike_1(value) && isArrayLike_1(value);
}

var isArrayLikeObject_1 = isArrayLikeObject;

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$1(value) {
  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

var isPlainObject_1 = isPlainObject$1;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

var _safeGet = safeGet;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

var _assignValue = assignValue;

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

var _copyObject = copyObject;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

var _nativeKeysIn = nativeKeysIn;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

var _baseKeysIn = baseKeysIn;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

var keysIn_1 = keysIn;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, keysIn_1(value));
}

var toPlainObject_1 = toPlainObject;

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray_1(srcValue),
        isBuff = !isArr && isBuffer_1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_1(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject_1(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
      newValue = objValue;
      if (isArguments_1(objValue)) {
        newValue = toPlainObject_1(objValue);
      }
      else if (!isObject_1(objValue) || isFunction_1(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

var _baseMergeDeep = baseMergeDeep;

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (isObject_1(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, keysIn_1);
}

var _baseMerge = baseMerge;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax$1 = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty$3 ? identity_1 : function(func, string) {
  return _defineProperty$3(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, identity_1), func + '');
}

var _baseRest = baseRest;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike_1(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq_1(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall;

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

var _createAssigner = createAssigner;

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge$1 = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

var merge_1 = merge$1;

function _typeof$3(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  return Constructor;
}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$g(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$g(Object(source), true).forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$g(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var SVGAnimatedString = function SVGAnimatedString() {};

if (typeof window !== 'undefined') {
  SVGAnimatedString = window.SVGAnimatedString;
}

function convertToArray(value) {
  if (typeof value === 'string') {
    value = value.split(' ');
  }

  return value;
}
/**
 * Add classes to an element.
 * This method checks to ensure that the classes don't already exist before adding them.
 * It uses el.className rather than classList in order to be IE friendly.
 * @param {object} el - The element to add the classes to.
 * @param {classes} string - List of space separated classes to be added to the element.
 */


function addClasses(el, classes) {
  var newClasses = convertToArray(classes);
  var classList;

  if (el.className instanceof SVGAnimatedString) {
    classList = convertToArray(el.className.baseVal);
  } else {
    classList = convertToArray(el.className);
  }

  newClasses.forEach(function (newClass) {
    if (classList.indexOf(newClass) === -1) {
      classList.push(newClass);
    }
  });

  if (el instanceof SVGElement) {
    el.setAttribute('class', classList.join(' '));
  } else {
    el.className = classList.join(' ');
  }
}
/**
 * Remove classes from an element.
 * It uses el.className rather than classList in order to be IE friendly.
 * @export
 * @param {any} el The element to remove the classes from.
 * @param {any} classes List of space separated classes to be removed from the element.
 */


function removeClasses(el, classes) {
  var newClasses = convertToArray(classes);
  var classList;

  if (el.className instanceof SVGAnimatedString) {
    classList = convertToArray(el.className.baseVal);
  } else {
    classList = convertToArray(el.className);
  }

  newClasses.forEach(function (newClass) {
    var index = classList.indexOf(newClass);

    if (index !== -1) {
      classList.splice(index, 1);
    }
  });

  if (el instanceof SVGElement) {
    el.setAttribute('class', classList.join(' '));
  } else {
    el.className = classList.join(' ');
  }
}

var supportsPassive$1 = false;

if (typeof window !== 'undefined') {
  supportsPassive$1 = false;

  try {
    var opts$1 = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive$1 = true;
      }
    });
    window.addEventListener('test', null, opts$1);
  } catch (e) {}
}

var DEFAULT_OPTIONS = {
  container: false,
  delay: 0,
  html: false,
  placement: 'top',
  title: '',
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  offset: 0
};
var openTooltips = [];

var Tooltip = /*#__PURE__*/function () {
  /**
   * Create a new Tooltip.js instance
   * @class Tooltip
   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
   * @param {Object} options
   * @param {String} options.placement=bottom
   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
   *      left(-start, -end)`
   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
   * @param {Number|Object} options.delay=0
   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
   *      If a number is supplied, delay is applied to both hide/show.
   *      Object structure is: `{ show: 500, hide: 100 }`
   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.
   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
   * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
   *      Base HTML to used when creating the tooltip.
   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
   *      The outermost wrapper element should have the `.tooltip` class.
   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
   * @param {String} [options.trigger='hover focus']
   *      How tooltip is triggered - click, hover, focus, manual.
   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
   * @param {HTMLElement} options.boundariesElement
   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
   *      [offset docs](https://popper.js.org/popper-documentation.html)
   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
   *      [options docs](https://popper.js.org/popper-documentation.html)
   * @param {string} [options.ariaId] Id used for accessibility
   * @return {Object} instance - The generated tooltip instance
   */
  function Tooltip(_reference, _options) {
    var _this = this;

    _classCallCheck$2(this, Tooltip);

    _defineProperty$2(this, "_events", []);

    _defineProperty$2(this, "_setTooltipNodeEvent", function (evt, reference, delay, options) {
      var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;

      var callback = function callback(evt2) {
        var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget; // Remove event listener after call

        _this._tooltipNode.removeEventListener(evt.type, callback); // If the new reference is not the reference element


        if (!reference.contains(relatedreference2)) {
          // Schedule to hide tooltip
          _this._scheduleHide(reference, options.delay, options, evt2);
        }
      };

      if (_this._tooltipNode.contains(relatedreference)) {
        // listen to mouseleave on the tooltip element to be able to hide the tooltip
        _this._tooltipNode.addEventListener(evt.type, callback);

        return true;
      }

      return false;
    }); // apply user options over default ones


    _options = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_OPTIONS), _options);
    _reference.jquery && (_reference = _reference[0]);
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this); // cache reference and options

    this.reference = _reference;
    this.options = _options; // set initial state

    this._isOpen = false;

    this._init();
  } //
  // Public methods
  //

  /**
   * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
   * Tooltips with zero-length titles are never displayed.
   * @method Tooltip#show
   * @memberof Tooltip
   */


  _createClass$2(Tooltip, [{
    key: "show",
    value: function show() {
      this._show(this.reference, this.options);
    }
    /**
     * Hides an elementâs tooltip. This is considered a âmanualâ triggering of the tooltip.
     * @method Tooltip#hide
     * @memberof Tooltip
     */

  }, {
    key: "hide",
    value: function hide() {
      this._hide();
    }
    /**
     * Hides and destroys an elementâs tooltip.
     * @method Tooltip#dispose
     * @memberof Tooltip
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this._dispose();
    }
    /**
     * Toggles an elementâs tooltip. This is considered a âmanualâ triggering of the tooltip.
     * @method Tooltip#toggle
     * @memberof Tooltip
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this._isOpen) {
        return this.hide();
      } else {
        return this.show();
      }
    }
  }, {
    key: "setClasses",
    value: function setClasses(classes) {
      this._classes = classes;
    }
  }, {
    key: "setContent",
    value: function setContent(content) {
      this.options.title = content;

      if (this._tooltipNode) {
        this._setContent(content, this.options);
      }
    }
  }, {
    key: "setOptions",
    value: function setOptions(options) {
      var classesUpdated = false;
      var classes = options && options.classes || directive.options.defaultClass;

      if (!isEqual_1(this._classes, classes)) {
        this.setClasses(classes);
        classesUpdated = true;
      }

      options = getOptions(options);
      var needPopperUpdate = false;
      var needRestart = false;

      if (this.options.offset !== options.offset || this.options.placement !== options.placement) {
        needPopperUpdate = true;
      }

      if (this.options.template !== options.template || this.options.trigger !== options.trigger || this.options.container !== options.container || classesUpdated) {
        needRestart = true;
      }

      for (var key in options) {
        this.options[key] = options[key];
      }

      if (this._tooltipNode) {
        if (needRestart) {
          var isOpen = this._isOpen;
          this.dispose();

          this._init();

          if (isOpen) {
            this.show();
          }
        } else if (needPopperUpdate) {
          this.popperInstance.update();
        }
      }
    } //
    // Private methods
    //

  }, {
    key: "_init",
    value: function _init() {
      // get events list
      var events = typeof this.options.trigger === 'string' ? this.options.trigger.split(' ') : [];
      this._isDisposed = false;
      this._enableDocumentTouch = events.indexOf('manual') === -1;
      events = events.filter(function (trigger) {
        return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;
      }); // set event listeners

      this._setEventListeners(this.reference, events, this.options); // title attribute


      this.$_originalTitle = this.reference.getAttribute('title');
      this.reference.removeAttribute('title');
      this.reference.setAttribute('data-original-title', this.$_originalTitle);
    }
    /**
     * Creates a new tooltip node
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} reference
     * @param {String} template
     * @param {String|HTMLElement|TitleFunction} title
     * @param {Boolean} allowHtml
     * @return {HTMLelement} tooltipNode
     */

  }, {
    key: "_create",
    value: function _create(reference, template) {
      var _this2 = this; // create tooltip element


      var tooltipGenerator = window.document.createElement('div');
      tooltipGenerator.innerHTML = template.trim();
      var tooltipNode = tooltipGenerator.childNodes[0]; // add unique ID to our tooltip (needed for accessibility reasons)

      tooltipNode.id = this.options.ariaId || "tooltip_".concat(Math.random().toString(36).substr(2, 10)); // Initially hide the tooltip
      // The attribute will be switched in a next frame so
      // CSS transitions can play

      tooltipNode.setAttribute('aria-hidden', 'true');

      if (this.options.autoHide && this.options.trigger.indexOf('hover') !== -1) {
        tooltipNode.addEventListener('mouseenter', function (evt) {
          return _this2._scheduleHide(reference, _this2.options.delay, _this2.options, evt);
        });
        tooltipNode.addEventListener('click', function (evt) {
          return _this2._scheduleHide(reference, _this2.options.delay, _this2.options, evt);
        });
      } // return the generated tooltip node


      return tooltipNode;
    }
  }, {
    key: "_setContent",
    value: function _setContent(content, options) {
      var _this3 = this;

      this.asyncContent = false;

      this._applyContent(content, options).then(function () {
        if (!_this3.popperInstance) return;

        _this3.popperInstance.update();
      });
    }
  }, {
    key: "_applyContent",
    value: function _applyContent(title, options) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var allowHtml = options.html;
        var rootNode = _this4._tooltipNode;
        if (!rootNode) return;
        var titleNode = rootNode.querySelector(_this4.options.innerSelector);

        if (title.nodeType === 1) {
          // if title is a node, append it only if allowHtml is true
          if (allowHtml) {
            while (titleNode.firstChild) {
              titleNode.removeChild(titleNode.firstChild);
            }

            titleNode.appendChild(title);
          }
        } else if (typeof title === 'function') {
          // if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value
          var result = title();

          if (result && typeof result.then === 'function') {
            _this4.asyncContent = true;
            options.loadingClass && addClasses(rootNode, options.loadingClass);

            if (options.loadingContent) {
              _this4._applyContent(options.loadingContent, options);
            }

            result.then(function (asyncResult) {
              options.loadingClass && removeClasses(rootNode, options.loadingClass);
              return _this4._applyContent(asyncResult, options);
            }).then(resolve).catch(reject);
          } else {
            _this4._applyContent(result, options).then(resolve).catch(reject);
          }

          return;
        } else {
          // if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value
          allowHtml ? titleNode.innerHTML = title : titleNode.innerText = title;
        }

        resolve();
      });
    }
  }, {
    key: "_show",
    value: function _show(reference, options) {
      if (options && typeof options.container === 'string') {
        var container = document.querySelector(options.container);
        if (!container) return;
      }

      clearTimeout(this._disposeTimer);
      options = Object.assign({}, options);
      delete options.offset;
      var updateClasses = true;

      if (this._tooltipNode) {
        addClasses(this._tooltipNode, this._classes);
        updateClasses = false;
      }

      var result = this._ensureShown(reference, options);

      if (updateClasses && this._tooltipNode) {
        addClasses(this._tooltipNode, this._classes);
      }

      addClasses(reference, ['v-tooltip-open']);
      return result;
    }
  }, {
    key: "_ensureShown",
    value: function _ensureShown(reference, options) {
      var _this5 = this; // don't show if it's already visible


      if (this._isOpen) {
        return this;
      }

      this._isOpen = true;
      openTooltips.push(this); // if the tooltipNode already exists, just show it

      if (this._tooltipNode) {
        this._tooltipNode.style.display = '';

        this._tooltipNode.setAttribute('aria-hidden', 'false');

        this.popperInstance.enableEventListeners();
        this.popperInstance.update();

        if (this.asyncContent) {
          this._setContent(options.title, options);
        }

        return this;
      } // get title


      var title = reference.getAttribute('title') || options.title; // don't show tooltip if no title is defined

      if (!title) {
        return this;
      } // create tooltip node


      var tooltipNode = this._create(reference, options.template);

      this._tooltipNode = tooltipNode; // Add `aria-describedby` to our reference element for accessibility reasons

      reference.setAttribute('aria-describedby', tooltipNode.id); // append tooltip to container

      var container = this._findContainer(options.container, reference);

      this._append(tooltipNode, container);

      var popperOptions = _objectSpread2$1(_objectSpread2$1({}, options.popperOptions), {}, {
        placement: options.placement
      });

      popperOptions.modifiers = _objectSpread2$1(_objectSpread2$1({}, popperOptions.modifiers), {}, {
        arrow: {
          element: this.options.arrowSelector
        }
      });

      if (options.boundariesElement) {
        popperOptions.modifiers.preventOverflow = {
          boundariesElement: options.boundariesElement
        };
      }

      this.popperInstance = new Popper(reference, tooltipNode, popperOptions);

      this._setContent(title, options); // Fix position


      requestAnimationFrame(function () {
        if (!_this5._isDisposed && _this5.popperInstance) {
          _this5.popperInstance.update(); // Show the tooltip


          requestAnimationFrame(function () {
            if (!_this5._isDisposed) {
              _this5._isOpen && tooltipNode.setAttribute('aria-hidden', 'false');
            } else {
              _this5.dispose();
            }
          });
        } else {
          _this5.dispose();
        }
      });
      return this;
    }
  }, {
    key: "_noLongerOpen",
    value: function _noLongerOpen() {
      var index = openTooltips.indexOf(this);

      if (index !== -1) {
        openTooltips.splice(index, 1);
      }
    }
  }, {
    key: "_hide",
    value: function _hide()
    /* reference, options */
    {
      var _this6 = this; // don't hide if it's already hidden


      if (!this._isOpen) {
        return this;
      }

      this._isOpen = false;

      this._noLongerOpen(); // hide tooltipNode


      this._tooltipNode.style.display = 'none';

      this._tooltipNode.setAttribute('aria-hidden', 'true');

      if (this.popperInstance) {
        this.popperInstance.disableEventListeners();
      }

      clearTimeout(this._disposeTimer);
      var disposeTime = directive.options.disposeTimeout;

      if (disposeTime !== null) {
        this._disposeTimer = setTimeout(function () {
          if (_this6._tooltipNode) {
            _this6._tooltipNode.removeEventListener('mouseenter', _this6.hide);

            _this6._tooltipNode.removeEventListener('click', _this6.hide); // Don't remove popper instance, just the HTML element


            _this6._removeTooltipNode();
          }
        }, disposeTime);
      }

      removeClasses(this.reference, ['v-tooltip-open']);
      return this;
    }
  }, {
    key: "_removeTooltipNode",
    value: function _removeTooltipNode() {
      if (!this._tooltipNode) return;
      var parentNode = this._tooltipNode.parentNode;

      if (parentNode) {
        parentNode.removeChild(this._tooltipNode);
        this.reference.removeAttribute('aria-describedby');
      }

      this._tooltipNode = null;
    }
  }, {
    key: "_dispose",
    value: function _dispose() {
      var _this7 = this;

      this._isDisposed = true;
      this.reference.removeAttribute('data-original-title');

      if (this.$_originalTitle) {
        this.reference.setAttribute('title', this.$_originalTitle);
      } // remove event listeners first to prevent any unexpected behaviour


      this._events.forEach(function (_ref) {
        var func = _ref.func,
            event = _ref.event;

        _this7.reference.removeEventListener(event, func);
      });

      this._events = [];

      if (this._tooltipNode) {
        this._hide();

        this._tooltipNode.removeEventListener('mouseenter', this.hide);

        this._tooltipNode.removeEventListener('click', this.hide); // destroy instance


        this.popperInstance.destroy(); // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element

        if (!this.popperInstance.options.removeOnDestroy) {
          this._removeTooltipNode();
        }
      } else {
        this._noLongerOpen();
      }

      return this;
    }
  }, {
    key: "_findContainer",
    value: function _findContainer(container, reference) {
      // if container is a query, get the relative element
      if (typeof container === 'string') {
        container = window.document.querySelector(container);
      } else if (container === false) {
        // if container is `false`, set it to reference parent
        container = reference.parentNode;
      }

      return container;
    }
    /**
     * Append tooltip to container
     * @memberof Tooltip
     * @private
     * @param {HTMLElement} tooltip
     * @param {HTMLElement|String|false} container
     */

  }, {
    key: "_append",
    value: function _append(tooltipNode, container) {
      container.appendChild(tooltipNode);
    }
  }, {
    key: "_setEventListeners",
    value: function _setEventListeners(reference, events, options) {
      var _this8 = this;

      var directEvents = [];
      var oppositeEvents = [];
      events.forEach(function (event) {
        switch (event) {
          case 'hover':
            directEvents.push('mouseenter');
            oppositeEvents.push('mouseleave');
            if (_this8.options.hideOnTargetClick) oppositeEvents.push('click');
            break;

          case 'focus':
            directEvents.push('focus');
            oppositeEvents.push('blur');
            if (_this8.options.hideOnTargetClick) oppositeEvents.push('click');
            break;

          case 'click':
            directEvents.push('click');
            oppositeEvents.push('click');
            break;
        }
      }); // schedule show tooltip

      directEvents.forEach(function (event) {
        var func = function func(evt) {
          if (_this8._isOpen === true) {
            return;
          }

          evt.usedByTooltip = true;

          _this8._scheduleShow(reference, options.delay, options, evt);
        };

        _this8._events.push({
          event: event,
          func: func
        });

        reference.addEventListener(event, func);
      }); // schedule hide tooltip

      oppositeEvents.forEach(function (event) {
        var func = function func(evt) {
          if (evt.usedByTooltip === true) {
            return;
          }

          _this8._scheduleHide(reference, options.delay, options, evt);
        };

        _this8._events.push({
          event: event,
          func: func
        });

        reference.addEventListener(event, func);
      });
    }
  }, {
    key: "_onDocumentTouch",
    value: function _onDocumentTouch(event) {
      if (this._enableDocumentTouch) {
        this._scheduleHide(this.reference, this.options.delay, this.options, event);
      }
    }
  }, {
    key: "_scheduleShow",
    value: function _scheduleShow(reference, delay, options
    /*, evt */
    ) {
      var _this9 = this; // defaults to 0


      var computedDelay = delay && delay.show || delay || 0;
      clearTimeout(this._scheduleTimer);
      this._scheduleTimer = window.setTimeout(function () {
        return _this9._show(reference, options);
      }, computedDelay);
    }
  }, {
    key: "_scheduleHide",
    value: function _scheduleHide(reference, delay, options, evt) {
      var _this10 = this; // defaults to 0


      var computedDelay = delay && delay.hide || delay || 0;
      clearTimeout(this._scheduleTimer);
      this._scheduleTimer = window.setTimeout(function () {
        if (_this10._isOpen === false) {
          return;
        }

        if (!_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)) {
          return;
        } // if we are hiding because of a mouseleave, we must check that the new
        // reference isn't the tooltip, because in this case we don't want to hide it


        if (evt.type === 'mouseleave') {
          var isSet = _this10._setTooltipNodeEvent(evt, reference, delay, options); // if we set the new event, don't hide the tooltip yet
          // the new event will take care to hide it if necessary


          if (isSet) {
            return;
          }
        }

        _this10._hide(reference, options);
      }, computedDelay);
    }
  }]);

  return Tooltip;
}(); // Hide tooltips on touch devices


if (typeof document !== 'undefined') {
  document.addEventListener('touchstart', function (event) {
    for (var i = 0; i < openTooltips.length; i++) {
      openTooltips[i]._onDocumentTouch(event);
    }
  }, supportsPassive$1 ? {
    passive: true,
    capture: true
  } : true);
}
/**
 * Placement function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback PlacementFunction
 * @param {HTMLElement} tooltip - tooltip DOM node.
 * @param {HTMLElement} reference - reference DOM node.
 * @return {String} placement - One of the allowed placement options.
 */

/**
 * Title function, its context is the Tooltip instance.
 * @memberof Tooltip
 * @callback TitleFunction
 * @return {String} placement - The desired title.
 */


var state = {
  enabled: true
};
var positions = ['top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'];
var defaultOptions = {
  // Default tooltip placement relative to target element
  defaultPlacement: 'top',
  // Default CSS classes applied to the tooltip element
  defaultClass: 'vue-tooltip-theme',
  // Default CSS classes applied to the target element of the tooltip
  defaultTargetClass: 'has-tooltip',
  // Is the content HTML by default?
  defaultHtml: true,
  // Default HTML template of the tooltip element
  // It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)
  // Change if the classes conflict with other libraries (for example bootstrap)
  defaultTemplate: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  // Selector used to get the arrow element in the tooltip template
  defaultArrowSelector: '.tooltip-arrow, .tooltip__arrow',
  // Selector used to get the inner content element in the tooltip template
  defaultInnerSelector: '.tooltip-inner, .tooltip__inner',
  // Delay (ms)
  defaultDelay: 0,
  // Default events that trigger the tooltip
  defaultTrigger: 'hover focus',
  // Default position offset (px)
  defaultOffset: 0,
  // Default container where the tooltip will be appended
  defaultContainer: 'body',
  defaultBoundariesElement: undefined,
  defaultPopperOptions: {},
  // Class added when content is loading
  defaultLoadingClass: 'tooltip-loading',
  // Displayed when tooltip content is loading
  defaultLoadingContent: '...',
  // Hide on mouseover tooltip
  autoHide: true,
  // Close tooltip on click on tooltip target?
  defaultHideOnTargetClick: true,
  // Auto destroy tooltip DOM nodes (ms)
  disposeTimeout: 5000,
  // Options for popover
  popover: {
    defaultPlacement: 'bottom',
    // Use the `popoverClass` prop for theming
    defaultClass: 'vue-popover-theme',
    // Base class (change if conflicts with other libraries)
    defaultBaseClass: 'tooltip popover',
    // Wrapper class (contains arrow and inner)
    defaultWrapperClass: 'wrapper',
    // Inner content class
    defaultInnerClass: 'tooltip-inner popover-inner',
    // Arrow class
    defaultArrowClass: 'tooltip-arrow popover-arrow',
    // Class added when popover is open
    defaultOpenClass: 'open',
    defaultDelay: 0,
    defaultTrigger: 'click',
    defaultOffset: 0,
    defaultContainer: 'body',
    defaultBoundariesElement: undefined,
    defaultPopperOptions: {},
    // Hides if clicked outside of popover
    defaultAutoHide: true,
    // Update popper on content resize
    defaultHandleResize: true
  }
};

function getOptions(options) {
  var result = {
    placement: typeof options.placement !== 'undefined' ? options.placement : directive.options.defaultPlacement,
    delay: typeof options.delay !== 'undefined' ? options.delay : directive.options.defaultDelay,
    html: typeof options.html !== 'undefined' ? options.html : directive.options.defaultHtml,
    template: typeof options.template !== 'undefined' ? options.template : directive.options.defaultTemplate,
    arrowSelector: typeof options.arrowSelector !== 'undefined' ? options.arrowSelector : directive.options.defaultArrowSelector,
    innerSelector: typeof options.innerSelector !== 'undefined' ? options.innerSelector : directive.options.defaultInnerSelector,
    trigger: typeof options.trigger !== 'undefined' ? options.trigger : directive.options.defaultTrigger,
    offset: typeof options.offset !== 'undefined' ? options.offset : directive.options.defaultOffset,
    container: typeof options.container !== 'undefined' ? options.container : directive.options.defaultContainer,
    boundariesElement: typeof options.boundariesElement !== 'undefined' ? options.boundariesElement : directive.options.defaultBoundariesElement,
    autoHide: typeof options.autoHide !== 'undefined' ? options.autoHide : directive.options.autoHide,
    hideOnTargetClick: typeof options.hideOnTargetClick !== 'undefined' ? options.hideOnTargetClick : directive.options.defaultHideOnTargetClick,
    loadingClass: typeof options.loadingClass !== 'undefined' ? options.loadingClass : directive.options.defaultLoadingClass,
    loadingContent: typeof options.loadingContent !== 'undefined' ? options.loadingContent : directive.options.defaultLoadingContent,
    popperOptions: _objectSpread2$1({}, typeof options.popperOptions !== 'undefined' ? options.popperOptions : directive.options.defaultPopperOptions)
  };

  if (result.offset) {
    var typeofOffset = _typeof$3(result.offset);

    var offset = result.offset; // One value -> switch

    if (typeofOffset === 'number' || typeofOffset === 'string' && offset.indexOf(',') === -1) {
      offset = "0, ".concat(offset);
    }

    if (!result.popperOptions.modifiers) {
      result.popperOptions.modifiers = {};
    }

    result.popperOptions.modifiers.offset = {
      offset: offset
    };
  }

  if (result.trigger && result.trigger.indexOf('click') !== -1) {
    result.hideOnTargetClick = false;
  }

  return result;
}

function getPlacement(value, modifiers) {
  var placement = value.placement;

  for (var i = 0; i < positions.length; i++) {
    var pos = positions[i];

    if (modifiers[pos]) {
      placement = pos;
    }
  }

  return placement;
}

function getContent(value) {
  var type = _typeof$3(value);

  if (type === 'string') {
    return value;
  } else if (value && type === 'object') {
    return value.content;
  } else {
    return false;
  }
}

function createTooltip(el, value) {
  var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = getContent(value);
  var classes = typeof value.classes !== 'undefined' ? value.classes : directive.options.defaultClass;

  var opts = _objectSpread2$1({
    title: content
  }, getOptions(_objectSpread2$1(_objectSpread2$1({}, _typeof$3(value) === 'object' ? value : {}), {}, {
    placement: getPlacement(value, modifiers)
  })));

  var tooltip = el._tooltip = new Tooltip(el, opts);
  tooltip.setClasses(classes);
  tooltip._vueEl = el; // Class on target

  var targetClasses = typeof value.targetClasses !== 'undefined' ? value.targetClasses : directive.options.defaultTargetClass;
  el._tooltipTargetClasses = targetClasses;
  addClasses(el, targetClasses);
  return tooltip;
}

function destroyTooltip(el) {
  if (el._tooltip) {
    el._tooltip.dispose();

    delete el._tooltip;
    delete el._tooltipOldShow;
  }

  if (el._tooltipTargetClasses) {
    removeClasses(el, el._tooltipTargetClasses);
    delete el._tooltipTargetClasses;
  }
}

function bind$2(el, _ref) {
  var value = _ref.value;
      _ref.oldValue;
      var modifiers = _ref.modifiers;
  var content = getContent(value);

  if (!content || !state.enabled) {
    destroyTooltip(el);
  } else {
    var tooltip;

    if (el._tooltip) {
      tooltip = el._tooltip; // Content

      tooltip.setContent(content); // Options

      tooltip.setOptions(_objectSpread2$1(_objectSpread2$1({}, value), {}, {
        placement: getPlacement(value, modifiers)
      }));
    } else {
      tooltip = createTooltip(el, value, modifiers);
    } // Manual show


    if (typeof value.show !== 'undefined' && value.show !== el._tooltipOldShow) {
      el._tooltipOldShow = value.show;
      value.show ? tooltip.show() : tooltip.hide();
    }
  }
}

var directive = {
  options: defaultOptions,
  bind: bind$2,
  update: bind$2,
  unbind: function unbind(el) {
    destroyTooltip(el);
  }
};

function addListeners(el) {
  el.addEventListener('click', onClick);
  el.addEventListener('touchstart', onTouchStart, supportsPassive$1 ? {
    passive: true
  } : false);
}

function removeListeners(el) {
  el.removeEventListener('click', onClick);
  el.removeEventListener('touchstart', onTouchStart);
  el.removeEventListener('touchend', onTouchEnd);
  el.removeEventListener('touchcancel', onTouchCancel);
}

function onClick(event) {
  var el = event.currentTarget;
  event.closePopover = !el.$_vclosepopover_touch;
  event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
}

function onTouchStart(event) {
  if (event.changedTouches.length === 1) {
    var el = event.currentTarget;
    el.$_vclosepopover_touch = true;
    var touch = event.changedTouches[0];
    el.$_vclosepopover_touchPoint = touch;
    el.addEventListener('touchend', onTouchEnd);
    el.addEventListener('touchcancel', onTouchCancel);
  }
}

function onTouchEnd(event) {
  var el = event.currentTarget;
  el.$_vclosepopover_touch = false;

  if (event.changedTouches.length === 1) {
    var touch = event.changedTouches[0];
    var firstTouch = el.$_vclosepopover_touchPoint;
    event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20;
    event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;
  }
}

function onTouchCancel(event) {
  var el = event.currentTarget;
  el.$_vclosepopover_touch = false;
}

var vclosepopover = {
  bind: function bind(el, _ref) {
    var value = _ref.value,
        modifiers = _ref.modifiers;
    el.$_closePopoverModifiers = modifiers;

    if (typeof value === 'undefined' || value) {
      addListeners(el);
    }
  },
  update: function update(el, _ref2) {
    var value = _ref2.value,
        oldValue = _ref2.oldValue,
        modifiers = _ref2.modifiers;
    el.$_closePopoverModifiers = modifiers;

    if (value !== oldValue) {
      if (typeof value === 'undefined' || value) {
        addListeners(el);
      } else {
        removeListeners(el);
      }
    }
  },
  unbind: function unbind(el) {
    removeListeners(el);
  }
};

function getDefault(key) {
  var value = directive.options.popover[key];

  if (typeof value === 'undefined') {
    return directive.options[key];
  }

  return value;
}

var isIOS = false;

if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}

var openPopovers = [];

var Element$1 = function Element() {};

if (typeof window !== 'undefined') {
  Element$1 = window.Element;
}

var script$1t = {
  name: 'VPopover',
  components: {
    ResizeObserver: __vue_component__$1u
  },
  props: {
    open: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: function _default() {
        return getDefault('defaultPlacement');
      }
    },
    delay: {
      type: [String, Number, Object],
      default: function _default() {
        return getDefault('defaultDelay');
      }
    },
    offset: {
      type: [String, Number],
      default: function _default() {
        return getDefault('defaultOffset');
      }
    },
    trigger: {
      type: String,
      default: function _default() {
        return getDefault('defaultTrigger');
      }
    },
    container: {
      type: [String, Object, Element$1, Boolean],
      default: function _default() {
        return getDefault('defaultContainer');
      }
    },
    boundariesElement: {
      type: [String, Element$1],
      default: function _default() {
        return getDefault('defaultBoundariesElement');
      }
    },
    popperOptions: {
      type: Object,
      default: function _default() {
        return getDefault('defaultPopperOptions');
      }
    },
    popoverClass: {
      type: [String, Array],
      default: function _default() {
        return getDefault('defaultClass');
      }
    },
    popoverBaseClass: {
      type: [String, Array],
      default: function _default() {
        return directive.options.popover.defaultBaseClass;
      }
    },
    popoverInnerClass: {
      type: [String, Array],
      default: function _default() {
        return directive.options.popover.defaultInnerClass;
      }
    },
    popoverWrapperClass: {
      type: [String, Array],
      default: function _default() {
        return directive.options.popover.defaultWrapperClass;
      }
    },
    popoverArrowClass: {
      type: [String, Array],
      default: function _default() {
        return directive.options.popover.defaultArrowClass;
      }
    },
    autoHide: {
      type: Boolean,
      default: function _default() {
        return directive.options.popover.defaultAutoHide;
      }
    },
    handleResize: {
      type: Boolean,
      default: function _default() {
        return directive.options.popover.defaultHandleResize;
      }
    },
    openGroup: {
      type: String,
      default: null
    },
    openClass: {
      type: [String, Array],
      default: function _default() {
        return directive.options.popover.defaultOpenClass;
      }
    },
    ariaId: {
      default: null
    }
  },
  data: function data() {
    return {
      isOpen: false,
      id: Math.random().toString(36).substr(2, 10)
    };
  },
  computed: {
    cssClass: function cssClass() {
      return _defineProperty$2({}, this.openClass, this.isOpen);
    },
    popoverId: function popoverId() {
      return "popover_".concat(this.ariaId != null ? this.ariaId : this.id);
    }
  },
  watch: {
    open: function open(val) {
      if (val) {
        this.show();
      } else {
        this.hide();
      }
    },
    disabled: function disabled(val, oldVal) {
      if (val !== oldVal) {
        if (val) {
          this.hide();
        } else if (this.open) {
          this.show();
        }
      }
    },
    container: function container(val) {
      if (this.isOpen && this.popperInstance) {
        var popoverNode = this.$refs.popover;
        var reference = this.$refs.trigger;
        var container = this.$_findContainer(this.container, reference);

        if (!container) {
          console.warn('No container for popover', this);
          return;
        }

        container.appendChild(popoverNode);
        this.popperInstance.scheduleUpdate();
      }
    },
    trigger: function trigger(val) {
      this.$_removeEventListeners();
      this.$_addEventListeners();
    },
    placement: function placement(val) {
      var _this = this;

      this.$_updatePopper(function () {
        _this.popperInstance.options.placement = val;
      });
    },
    offset: '$_restartPopper',
    boundariesElement: '$_restartPopper',
    popperOptions: {
      handler: '$_restartPopper',
      deep: true
    }
  },
  created: function created() {
    this.$_isDisposed = false;
    this.$_mounted = false;
    this.$_events = [];
    this.$_preventOpen = false;
  },
  mounted: function mounted() {
    var popoverNode = this.$refs.popover;
    popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);
    this.$_init();

    if (this.open) {
      this.show();
    }
  },
  deactivated: function deactivated() {
    this.hide();
  },
  beforeDestroy: function beforeDestroy() {
    this.dispose();
  },
  methods: {
    show: function show() {
      var _this2 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          event = _ref2.event;
          _ref2.skipDelay;
          var _ref2$force = _ref2.force,
          force = _ref2$force === void 0 ? false : _ref2$force;

      if (force || !this.disabled) {
        this.$_scheduleShow(event);
        this.$emit('show');
      }

      this.$emit('update:open', true);
      this.$_beingShowed = true;
      requestAnimationFrame(function () {
        _this2.$_beingShowed = false;
      });
    },
    hide: function hide() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          event = _ref3.event;
          _ref3.skipDelay;

      this.$_scheduleHide(event);
      this.$emit('hide');
      this.$emit('update:open', false);
    },
    dispose: function dispose() {
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({
        skipDelay: true
      });

      if (this.popperInstance) {
        this.popperInstance.destroy(); // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element

        if (!this.popperInstance.options.removeOnDestroy) {
          var popoverNode = this.$refs.popover;
          popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);
        }
      }

      this.$_mounted = false;
      this.popperInstance = null;
      this.isOpen = false;
      this.$emit('dispose');
    },
    $_init: function $_init() {
      if (this.trigger.indexOf('manual') === -1) {
        this.$_addEventListeners();
      }
    },
    $_show: function $_show() {
      var _this3 = this;

      var reference = this.$refs.trigger;
      var popoverNode = this.$refs.popover;
      clearTimeout(this.$_disposeTimer); // Already open

      if (this.isOpen) {
        return;
      } // Popper is already initialized


      if (this.popperInstance) {
        this.isOpen = true;
        this.popperInstance.enableEventListeners();
        this.popperInstance.scheduleUpdate();
      }

      if (!this.$_mounted) {
        var container = this.$_findContainer(this.container, reference);

        if (!container) {
          console.warn('No container for popover', this);
          return;
        }

        container.appendChild(popoverNode);
        this.$_mounted = true;
        this.isOpen = false;

        if (this.popperInstance) {
          requestAnimationFrame(function () {
            if (!_this3.hidden) {
              _this3.isOpen = true;
            }
          });
        }
      }

      if (!this.popperInstance) {
        var popperOptions = _objectSpread2$1(_objectSpread2$1({}, this.popperOptions), {}, {
          placement: this.placement
        });

        popperOptions.modifiers = _objectSpread2$1(_objectSpread2$1({}, popperOptions.modifiers), {}, {
          arrow: _objectSpread2$1(_objectSpread2$1({}, popperOptions.modifiers && popperOptions.modifiers.arrow), {}, {
            element: this.$refs.arrow
          })
        });

        if (this.offset) {
          var offset = this.$_getOffset();
          popperOptions.modifiers.offset = _objectSpread2$1(_objectSpread2$1({}, popperOptions.modifiers && popperOptions.modifiers.offset), {}, {
            offset: offset
          });
        }

        if (this.boundariesElement) {
          popperOptions.modifiers.preventOverflow = _objectSpread2$1(_objectSpread2$1({}, popperOptions.modifiers && popperOptions.modifiers.preventOverflow), {}, {
            boundariesElement: this.boundariesElement
          });
        }

        this.popperInstance = new Popper(reference, popoverNode, popperOptions); // Fix position

        requestAnimationFrame(function () {
          if (_this3.hidden) {
            _this3.hidden = false;

            _this3.$_hide();

            return;
          }

          if (!_this3.$_isDisposed && _this3.popperInstance) {
            _this3.popperInstance.scheduleUpdate(); // Show the tooltip


            requestAnimationFrame(function () {
              if (_this3.hidden) {
                _this3.hidden = false;

                _this3.$_hide();

                return;
              }

              if (!_this3.$_isDisposed) {
                _this3.isOpen = true;
              } else {
                _this3.dispose();
              }
            });
          } else {
            _this3.dispose();
          }
        });
      }

      var openGroup = this.openGroup;

      if (openGroup) {
        var popover;

        for (var i = 0; i < openPopovers.length; i++) {
          popover = openPopovers[i];

          if (popover.openGroup !== openGroup) {
            popover.hide();
            popover.$emit('close-group');
          }
        }
      }

      openPopovers.push(this);
      this.$emit('apply-show');
    },
    $_hide: function $_hide() {
      var _this4 = this; // Already hidden


      if (!this.isOpen) {
        return;
      }

      var index = openPopovers.indexOf(this);

      if (index !== -1) {
        openPopovers.splice(index, 1);
      }

      this.isOpen = false;

      if (this.popperInstance) {
        this.popperInstance.disableEventListeners();
      }

      clearTimeout(this.$_disposeTimer);
      var disposeTime = directive.options.popover.disposeTimeout || directive.options.disposeTimeout;

      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(function () {
          var popoverNode = _this4.$refs.popover;

          if (popoverNode) {
            // Don't remove popper instance, just the HTML element
            popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);
            _this4.$_mounted = false;
          }
        }, disposeTime);
      }

      this.$emit('apply-hide');
    },
    $_findContainer: function $_findContainer(container, reference) {
      // if container is a query, get the relative element
      if (typeof container === 'string') {
        container = window.document.querySelector(container);
      } else if (container === false) {
        // if container is `false`, set it to reference parent
        container = reference.parentNode;
      }

      return container;
    },
    $_getOffset: function $_getOffset() {
      var typeofOffset = _typeof$3(this.offset);

      var offset = this.offset; // One value -> switch

      if (typeofOffset === 'number' || typeofOffset === 'string' && offset.indexOf(',') === -1) {
        offset = "0, ".concat(offset);
      }

      return offset;
    },
    $_addEventListeners: function $_addEventListeners() {
      var _this5 = this;

      var reference = this.$refs.trigger;
      var directEvents = [];
      var oppositeEvents = [];
      var events = typeof this.trigger === 'string' ? this.trigger.split(' ').filter(function (trigger) {
        return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;
      }) : [];
      events.forEach(function (event) {
        switch (event) {
          case 'hover':
            directEvents.push('mouseenter');
            oppositeEvents.push('mouseleave');
            break;

          case 'focus':
            directEvents.push('focus');
            oppositeEvents.push('blur');
            break;

          case 'click':
            directEvents.push('click');
            oppositeEvents.push('click');
            break;
        }
      }); // schedule show tooltip

      directEvents.forEach(function (event) {
        var func = function func(event) {
          if (_this5.isOpen) {
            return;
          }

          event.usedByTooltip = true;
          !_this5.$_preventOpen && _this5.show({
            event: event
          });
          _this5.hidden = false;
        };

        _this5.$_events.push({
          event: event,
          func: func
        });

        reference.addEventListener(event, func);
      }); // schedule hide tooltip

      oppositeEvents.forEach(function (event) {
        var func = function func(event) {
          if (event.usedByTooltip) {
            return;
          }

          _this5.hide({
            event: event
          });

          _this5.hidden = true;
        };

        _this5.$_events.push({
          event: event,
          func: func
        });

        reference.addEventListener(event, func);
      });
    },
    $_scheduleShow: function $_scheduleShow() {
      var skipDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      clearTimeout(this.$_scheduleTimer);

      if (skipDelay) {
        this.$_show();
      } else {
        // defaults to 0
        var computedDelay = parseInt(this.delay && this.delay.show || this.delay || 0);
        this.$_scheduleTimer = setTimeout(this.$_show.bind(this), computedDelay);
      }
    },
    $_scheduleHide: function $_scheduleHide() {
      var _this6 = this;

      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var skipDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      clearTimeout(this.$_scheduleTimer);

      if (skipDelay) {
        this.$_hide();
      } else {
        // defaults to 0
        var computedDelay = parseInt(this.delay && this.delay.hide || this.delay || 0);
        this.$_scheduleTimer = setTimeout(function () {
          if (!_this6.isOpen) {
            return;
          } // if we are hiding because of a mouseleave, we must check that the new
          // reference isn't the tooltip, because in this case we don't want to hide it


          if (event && event.type === 'mouseleave') {
            var isSet = _this6.$_setTooltipNodeEvent(event); // if we set the new event, don't hide the tooltip yet
            // the new event will take care to hide it if necessary


            if (isSet) {
              return;
            }
          }

          _this6.$_hide();
        }, computedDelay);
      }
    },
    $_setTooltipNodeEvent: function $_setTooltipNodeEvent(event) {
      var _this7 = this;

      var reference = this.$refs.trigger;
      var popoverNode = this.$refs.popover;
      var relatedreference = event.relatedreference || event.toElement || event.relatedTarget;

      var callback = function callback(event2) {
        var relatedreference2 = event2.relatedreference || event2.toElement || event2.relatedTarget; // Remove event listener after call

        popoverNode.removeEventListener(event.type, callback); // If the new reference is not the reference element

        if (!reference.contains(relatedreference2)) {
          // Schedule to hide tooltip
          _this7.hide({
            event: event2
          });
        }
      };

      if (popoverNode.contains(relatedreference)) {
        // listen to mouseleave on the tooltip element to be able to hide the tooltip
        popoverNode.addEventListener(event.type, callback);
        return true;
      }

      return false;
    },
    $_removeEventListeners: function $_removeEventListeners() {
      var reference = this.$refs.trigger;
      this.$_events.forEach(function (_ref4) {
        var func = _ref4.func,
            event = _ref4.event;
        reference.removeEventListener(event, func);
      });
      this.$_events = [];
    },
    $_updatePopper: function $_updatePopper(cb) {
      if (this.popperInstance) {
        cb();
        if (this.isOpen) this.popperInstance.scheduleUpdate();
      }
    },
    $_restartPopper: function $_restartPopper() {
      if (this.popperInstance) {
        var isOpen = this.isOpen;
        this.dispose();
        this.$_isDisposed = false;
        this.$_init();

        if (isOpen) {
          this.show({
            skipDelay: true,
            force: true
          });
        }
      }
    },
    $_handleGlobalClose: function $_handleGlobalClose(event) {
      var _this8 = this;

      var touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.$_beingShowed) return;
      this.hide({
        event: event
      });

      if (event.closePopover) {
        this.$emit('close-directive');
      } else {
        this.$emit('auto-hide');
      }

      if (touch) {
        this.$_preventOpen = true;
        setTimeout(function () {
          _this8.$_preventOpen = false;
        }, 300);
      }
    },
    $_handleResize: function $_handleResize() {
      if (this.isOpen && this.popperInstance) {
        this.popperInstance.scheduleUpdate();
        this.$emit('resize');
      }
    }
  }
};

if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  if (isIOS) {
    document.addEventListener('touchend', handleGlobalTouchend, supportsPassive$1 ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener('click', handleGlobalClick, true);
  }
}

function handleGlobalClick(event) {
  handleGlobalClose(event);
}

function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}

function handleGlobalClose(event) {
  var touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var _loop = function _loop(i) {
    var popover = openPopovers[i];

    if (popover.$refs.popover) {
      var contains = popover.$refs.popover.contains(event.target);
      requestAnimationFrame(function () {
        if (event.closeAllPopover || event.closePopover && contains || popover.autoHide && !contains) {
          popover.$_handleGlobalClose(event, touch);
        }
      });
    }
  }; // Delay so that close directive has time to set values


  for (var i = 0; i < openPopovers.length; i++) {
    _loop(i);
  }
}

function normalizeComponent$1(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function (context) {
      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}
/* script */


var __vue_script__$1t = script$1t;
/* template */

var __vue_render__$1j = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c("div", {
    staticClass: "v-popover",
    class: _vm.cssClass
  }, [_c("div", {
    ref: "trigger",
    staticClass: "trigger",
    staticStyle: {
      display: "inline-block"
    },
    attrs: {
      "aria-describedby": _vm.isOpen ? _vm.popoverId : undefined,
      tabindex: _vm.trigger.indexOf("focus") !== -1 ? 0 : undefined
    }
  }, [_vm._t("default")], 2), _vm._v(" "), _c("div", {
    ref: "popover",
    class: [_vm.popoverBaseClass, _vm.popoverClass, _vm.cssClass],
    style: {
      visibility: _vm.isOpen ? "visible" : "hidden"
    },
    attrs: {
      id: _vm.popoverId,
      "aria-hidden": _vm.isOpen ? "false" : "true",
      tabindex: _vm.autoHide ? 0 : undefined
    },
    on: {
      keyup: function keyup($event) {
        if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
          return null;
        }

        _vm.autoHide && _vm.hide();
      }
    }
  }, [_c("div", {
    class: _vm.popoverWrapperClass
  }, [_c("div", {
    ref: "inner",
    class: _vm.popoverInnerClass,
    staticStyle: {
      position: "relative"
    }
  }, [_c("div", [_vm._t("popover", null, {
    isOpen: _vm.isOpen
  })], 2), _vm._v(" "), _vm.handleResize ? _c("ResizeObserver", {
    on: {
      notify: _vm.$_handleResize
    }
  }) : _vm._e()], 1), _vm._v(" "), _c("div", {
    ref: "arrow",
    class: _vm.popoverArrowClass
  })])])]);
};

var __vue_staticRenderFns__$1j = [];
__vue_render__$1j._withStripped = true;
/* style */

var __vue_inject_styles__$1t = undefined;
/* scoped */

var __vue_scope_id__$1t = undefined;
/* module identifier */

var __vue_module_identifier__$1t = undefined;
/* functional template */

var __vue_is_functional_template__$1t = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1t = /*#__PURE__*/normalizeComponent$1({
  render: __vue_render__$1j,
  staticRenderFns: __vue_staticRenderFns__$1j
}, __vue_inject_styles__$1t, __vue_script__$1t, __vue_scope_id__$1t, __vue_is_functional_template__$1t, __vue_module_identifier__$1t, false, undefined, undefined, undefined);

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}";
styleInject(css_248z);

function install$2(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (install$2.installed) return;
  install$2.installed = true;
  var finalOptions = {};
  merge_1(finalOptions, defaultOptions, options);
  plugin$3.options = finalOptions;
  directive.options = finalOptions;
  Vue.directive('tooltip', directive);
  Vue.directive('close-popover', vclosepopover);
  Vue.component('VPopover', __vue_component__$1t);
}
var VClosePopover = vclosepopover;
var VPopover = __vue_component__$1t;
var plugin$3 = {
  install: install$2,

  get enabled() {
    return state.enabled;
  },

  set enabled(value) {
    state.enabled = value;
  }

}; // Auto-install

var GlobalVue$3 = null;

if (typeof window !== 'undefined') {
  GlobalVue$3 = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue$3 = global.Vue;
}

if (GlobalVue$3) {
  GlobalVue$3.use(plugin$3);
}

var autosize = createCommonjsModule(function (module, exports) {
/*!
	Autosize 3.0.21
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	{
		factory(exports, module);
	}
})(commonjsGlobal, function (exports, module) {

	var map = typeof Map === "function" ? new Map() : (function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			'delete': function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	})();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function (name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = ta.clientWidth;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			var originalHeight = ta.style.height;
			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = 'auto';

			var endHeight = ta.scrollHeight + heightOffset;

			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				ta.style.height = originalHeight;
				return;
			}

			ta.style.height = endHeight + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight !== styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = (function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map['delete'](ta);
		}).bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function (el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function (el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	module.exports = autosize;
});
});

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1s = {
  name: 'ui-textbox-suggestion',
  props: {
    suggestion: {
      type: [String, Object],
      required: true
    },
    type: {
      type: String,
      default: 'simple' // 'simple' or 'image'

    },
    keys: {
      type: Object,
      default: function _default() {
        return {
          label: 'label',
          image: 'image'
        };
      }
    }
  },
  computed: {
    classes: function classes() {
      return defineProperty$2({}, "ui-textbox-suggestion--type-".concat(this.type), this.type);
    },
    imageStyle: function imageStyle() {
      return {
        'background-image': 'url(' + this.suggestion[this.keys.image] + ')'
      };
    }
  }
};

var __vue_script__$1s = script$1s;
/* template */

var __vue_render__$1i = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('li', {
    staticClass: "ui-textbox-suggestion",
    class: _vm.classes
  }, [_vm._t("default", [_vm.type === 'simple' ? _c('div', {
    staticClass: "ui-textbox-suggestion__simple"
  }, [_vm._v("\n      " + _vm._s(_vm.suggestion[_vm.keys.label] || _vm.suggestion) + "\n    ")]) : _vm._e(), _vm._v(" "), _vm.type === 'image' ? _c('div', {
    staticClass: "ui-textbox-suggestion__image"
  }, [_c('div', {
    staticClass: "ui-textbox-suggestion__image-object",
    style: _vm.imageStyle
  }), _vm._v(" "), _c('div', {
    staticClass: "ui-textbox-suggestion__image-text"
  }, [_vm._v("\n        " + _vm._s(_vm.suggestion[_vm.keys.label]) + "\n      ")])]) : _vm._e()])], 2);
};

var __vue_staticRenderFns__$1i = [];
/* style */

var __vue_inject_styles__$1s = undefined;
/* scoped */

var __vue_scope_id__$1s = undefined;
/* module identifier */

var __vue_module_identifier__$1s = undefined;
/* functional template */

var __vue_is_functional_template__$1s = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1s = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1i,
  staticRenderFns: __vue_staticRenderFns__$1i
}, __vue_inject_styles__$1s, __vue_script__$1s, __vue_scope_id__$1s, __vue_is_functional_template__$1s, __vue_module_identifier__$1s, false, undefined, undefined, undefined);

var DAutofocus = {
  inserted: function inserted(el, _ref) {
    var value = _ref.value;

    if (value) {
      el.focus();
    }
  },
  update: function update(el, _ref2) {
    var modifiers = _ref2.modifiers,
        value = _ref2.value;
    if (!modifiers.dynamic) return;

    if (value) {
      el.focus();
    }
  }
};

var script$1r = {
  name: 'ui-textbox',
  components: {
    UiIcon: __vue_component__$1B,
    UiTextboxSuggestion: __vue_component__$1s
  },
  directives: {
    autofocus: DAutofocus
  },
  props: {
    mellow: {
      type: Boolean,
      default: true
    },
    name: String,
    placeholder: String,
    tabindex: [String, Number],
    value: {
      type: [String, Number],
      default: ''
    },
    icon: String,
    iconPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    label: String,
    floatingLabel: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'text' // all the possible HTML5 input types, except those that have a special UI

    },
    multiLine: {
      type: Boolean,
      default: false
    },
    rows: {
      type: Number,
      default: 2
    },
    autocomplete: String,
    autofocus: {
      type: Boolean,
      default: false
    },
    autosize: {
      type: Boolean,
      default: false
    },
    min: Number,
    max: Number,
    step: {
      type: [String, Number],
      default: 'any'
    },
    maxlength: Number,
    minlength: Number,
    enforceMaxlength: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    help: String,
    error: String,
    invalid: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    keys: {
      type: Object,
      default: function _default() {
        return {
          label: 'label',
          value: 'value',
          image: 'image'
        };
      }
    },
    suggestions: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    suggestionType: {
      type: String,
      default: 'simple' // 'simple' or 'image'

    },
    suggestionTrigger: {
      type: String,
      default: 'focus' // 'focus' or 'input'

    },
    suggestionFilter: Function,
    beforeSuggestionFilter: Function,

    /* æ¸é¤æé® */
    clearable: {
      type: Boolean,
      default: false
    },
    //éæ©å»ºè®®çæ¶åæ¯å¦èªå¨æ´æ°
    autoUpdate: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      isActive: false,
      isTouched: false,
      initialValue: this.value,
      autosizeInitialized: false,
      showDropdown: false
    };
  },
  computed: {
    inputType: function inputType() {
      if (this.isSafari()) {
        return this.type == 'number' ? 'text' : this.type;
      } else {
        return this.type;
      }
    },
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-textbox--icon-position-".concat(this.iconPosition), true), defineProperty$2(_ref, 'ui-textbox--mellow', this.mellow), defineProperty$2(_ref, 'is-active', this.isActive), defineProperty$2(_ref, 'is-invalid', this.invalid), defineProperty$2(_ref, 'is-touched', this.isTouched), defineProperty$2(_ref, 'is-multi-line', this.multiLine), defineProperty$2(_ref, 'is-disabled', this.disabled), defineProperty$2(_ref, 'has-counter', this.maxlength), defineProperty$2(_ref, 'has-label', this.hasLabel), defineProperty$2(_ref, 'has-floating-label', this.hasFloatingLabel), defineProperty$2(_ref, 'has-clear', this.hasClear), _ref;
    },
    labelClasses: function labelClasses() {
      return {
        'is-inline': this.hasFloatingLabel && this.isLabelInline,
        'is-floating': this.hasFloatingLabel && !this.isLabelInline
      };
    },
    hasLabel: function hasLabel() {
      return Boolean(this.label) || Boolean(this.$slots.default);
    },
    hasFloatingLabel: function hasFloatingLabel() {
      return this.hasLabel && this.floatingLabel;
    },
    hasClear: function hasClear() {
      return this.clearable && !this.disabled && !this.readonly && this.valueLength;
    },
    isLabelInline: function isLabelInline() {
      return this.valueLength === 0 && !this.isActive;
    },
    minValue: function minValue() {
      if (this.type === 'number' && this.min !== undefined) {
        return this.min;
      }

      return null;
    },
    maxValue: function maxValue() {
      if (this.type === 'number' && this.max !== undefined) {
        return this.max;
      }

      return null;
    },
    stepValue: function stepValue() {
      return this.type === 'number' ? this.step : null;
    },
    valueLength: function valueLength() {
      return 'number' === typeof this.value ? String(this.value).length : this.value ? this.value.length : 0;
    },
    hasFeedback: function hasFeedback() {
      return this.showError || this.showHelp;
    },
    showError: function showError() {
      return this.invalid && (Boolean(this.error) || Boolean(this.$slots.error));
    },
    showHelp: function showHelp() {
      return Boolean(this.help) || Boolean(this.$slots.help);
    },
    matchingSuggestions: function matchingSuggestions() {
      var _this = this;

      var query = this.value === null ? '' : this.value;

      if (this.beforeSuggestionFilter) {
        return this.beforeSuggestionFilter(this.suggestions, query, this.defaultFilter);
      }

      var suggestions = this.suggestions.filter(function (suggestion) {
        if (_this.suggestionFilter) {
          return _this.suggestionFilter(suggestion, _this.value, _this.defaultFilter);
        }

        return _this.defaultFilter(suggestion, query);
      });
      return suggestions;
    }
  },
  watch: {
    value: function value() {
      if (this.isActive) {
        this.openDropdown();
      }
    },
    autosize: function autosize$1() {
      if (this.multiLine && this.autosize) {
        if (!this.autosizeInitialized) {
          autosize(this.$refs.textarea);

          this.autosizeInitialized = true;
        }
      } else {
        if (this.autosizeInitialized) {
          autosize.destroy(this.$refs.textarea);
        }

        this.autosizeInitialized = false;
      }
    }
  },
  created: function created() {
    // Normalize the value to an empty string if it's null
    if (this.value === null) {
      this.initialValue = '';
      this.updateValue('');
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    document.addEventListener('click', this.onExternalClick);

    if (this.multiLine && this.autosize) {
      autosize(this.$refs.textarea);

      this.autosizeInitialized = true;
    }

    this.removeDropdown();

    if (this.isSafari()) {
      var inputs = document.getElementsByClassName('ui-textbox__input');
      Array.from(inputs).map(function (input) {
        if (_this2.type == 'number') {
          input.addEventListener('input', function (e) {
            var reg = /^\d+$|^\d*\.\d+$/g;

            if (!reg.test(input.value)) {
              input.value = input.value.replace(/[^0-9.-]/g, '');
            }
          });
        }
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('click', this.onExternalClick);

    if (this.autosizeInitialized) {
      autosize.destroy(this.$refs.textarea);
    }

    this.removeDropdown();
  },
  methods: {
    isSafari: function isSafari() {
      if (!(/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent))) {
        return false;
      } else {
        return true;
      }
    },
    updateValue: function updateValue(value) {
      if (this.isSafari()) {
        if (this.type == 'number') {
          var reg = /^\d+$|^\d*\.\d+$/g;

          if (!reg.test(value)) {
            value = value.replace(/[^0-9.-]/g, '');
          }
        }
      }

      this.$emit('input', value);
    },
    onChange: function onChange(e) {
      this.$emit('change', this.value, e);
    },
    onFocus: function onFocus(e) {
      this.isActive = true;

      if (this.suggestionTrigger == 'focus') {
        this.openDropdown();
      }

      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);

      if (!this.isTouched) {
        this.isTouched = true;
        this.$emit('touch');
      }
    },
    onExternalClick: function onExternalClick(e) {
      if (!this.$el.contains(e.target) && this.showDropdown) {
        this.closeDropdown();
      }
    },
    onClear: function onClear(e) {
      this.$emit('clear', e);
      this.updateValue('');
    },
    onKeydown: function onKeydown(e) {
      this.$emit('keydown', e);
    },
    onKeydownEnter: function onKeydownEnter(e) {
      this.$emit('keydown-enter', e);
    },
    reset: function reset() {
      // Blur the input if it's focused to prevent required errors
      // when it's value is reset
      if (document.activeElement === this.$refs.input || document.activeElement === this.$refs.textarea) {
        document.activeElement.blur();
      }

      this.updateValue(this.initialValue);
      this.resetTouched();
    },
    resetTouched: function resetTouched() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        touched: false
      };
      this.isTouched = options.touched;
    },
    refreshSize: function refreshSize() {
      if (this.autosizeInitialized) {
        autosize.update(this.$refs.textarea);
      }
    },
    focus: function focus() {
      (this.$refs.input || this.$refs.textarea).focus();
    },
    defaultFilter: function defaultFilter(suggestion, query) {
      var text = suggestion[this.keys.label] || suggestion;

      if (typeof text === 'string') {
        text = text.toLowerCase();
      } // return fuzzysearch(query.toLowerCase(), text)


      return ~String(text).indexOf(query.toLowerCase());
    },
    selectSuggestion: function selectSuggestion(suggestion) {
      var _this3 = this;

      var value = 'undefined' !== typeof suggestion[this.keys.value] ? suggestion[this.keys.value] : suggestion;
      this.autoUpdate && this.updateValue(value);
      this.$emit('select', suggestion);
      this.$nextTick(function () {
        _this3.closeDropdown();

        _this3.focus();
      });
    },
    removeDropdown: function removeDropdown() {
      var suggestionsNode = this.$refs.suggestions;
      suggestionsNode.parentNode && suggestionsNode.parentNode.removeChild(suggestionsNode);
    },
    openDropdown: function openDropdown() {
      if (!this.showDropdown) {
        this.showDropdown = true;
        this.$emit('dropdown-open');
        var suggestionsNode = this.$refs.suggestions;
        document.body.appendChild(suggestionsNode);

        var _suggestionsNode$getB = suggestionsNode.getBoundingClientRect(),
            sHeight = _suggestionsNode$getB.height;

        var _this$$refs$content$g = this.$refs.content.getBoundingClientRect(),
            top = _this$$refs$content$g.top,
            bottom = _this$$refs$content$g.bottom,
            left = _this$$refs$content$g.left,
            width = _this$$refs$content$g.width;

        Object.assign(suggestionsNode.style, {
          width: "".concat(width, "px"),
          left: "".concat(left, "px"),
          top: bottom + sHeight > window.innerHeight // è¶åºä¸é¢è¾¹ç
          ? "".concat(top - sHeight - 2, "px") : "".concat(bottom, "px")
        });
      }
    },
    closeDropdown: function closeDropdown() {
      var _this4 = this;

      if (this.showDropdown) {
        this.$nextTick(function () {
          _this4.removeDropdown();

          _this4.showDropdown = false;

          _this4.$emit('dropdown-close');
        });
      }
    }
  }
};

var __vue_script__$1r = script$1r;
/* template */

var __vue_render__$1h = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-textbox",
    class: _vm.classes
  }, [!_vm.multiLine && _vm.$slots.prepend ? _c('div', {
    staticClass: "ui-textbox__prepend"
  }, [_vm._t("prepend")], 2) : _vm._e(), _vm._v(" "), _vm.icon || _vm.$slots.icon ? _c('div', {
    staticClass: "ui-textbox__icon-wrapper"
  }, [_vm._t("icon", [_c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  })])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "content",
    staticClass: "ui-textbox__content"
  }, [_c('label', {
    staticClass: "ui-textbox__label"
  }, [!_vm.multiLine && _vm.hasClear ? _c('ui-icon', {
    staticClass: "ui-textbox__clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        return _vm.onClear($event);
      }
    }
  }) : _vm._e(), _vm._v(" "), _vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-textbox__label-text",
    class: _vm.labelClasses
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), !_vm.multiLine ? _c('input', {
    directives: [{
      name: "autofocus",
      rawName: "v-autofocus",
      value: _vm.autofocus,
      expression: "autofocus"
    }],
    ref: "input",
    staticClass: "ui-textbox__input",
    attrs: {
      "autocomplete": _vm.autocomplete ? _vm.autocomplete : null,
      "disabled": _vm.disabled,
      "max": _vm.maxValue,
      "maxlength": _vm.enforceMaxlength ? _vm.maxlength : null,
      "minlength": _vm.minlength,
      "min": _vm.minValue,
      "name": _vm.name,
      "number": _vm.type === 'number' ? true : null,
      "placeholder": _vm.hasFloatingLabel ? null : _vm.placeholder,
      "readonly": _vm.readonly,
      "required": _vm.required,
      "step": _vm.stepValue,
      "tabindex": _vm.tabindex,
      "type": _vm.inputType
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "blur": _vm.onBlur,
      "change": _vm.onChange,
      "focus": _vm.onFocus,
      "input": function input($event) {
        return _vm.updateValue($event.target.value);
      },
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        return _vm.onKeydownEnter($event);
      }, _vm.onKeydown]
    }
  }) : _c('textarea', {
    directives: [{
      name: "autofocus",
      rawName: "v-autofocus",
      value: _vm.autofocus,
      expression: "autofocus"
    }],
    ref: "textarea",
    staticClass: "ui-textbox__textarea",
    attrs: {
      "autocomplete": _vm.autocomplete ? _vm.autocomplete : null,
      "disabled": _vm.disabled,
      "maxlength": _vm.enforceMaxlength ? _vm.maxlength : null,
      "minlength": _vm.minlength,
      "name": _vm.name,
      "placeholder": _vm.hasFloatingLabel ? null : _vm.placeholder,
      "readonly": _vm.readonly,
      "required": _vm.required,
      "rows": _vm.rows,
      "tabindex": _vm.tabindex
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "blur": _vm.onBlur,
      "change": _vm.onChange,
      "focus": _vm.onFocus,
      "input": function input($event) {
        return _vm.updateValue($event.target.value);
      },
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        return _vm.onKeydownEnter($event);
      }, _vm.onKeydown]
    }
  })], 1), _vm._v(" "), _vm.hasFeedback || _vm.maxlength ? _c('div', {
    staticClass: "ui-textbox__feedback"
  }, [_vm.showError ? _c('div', {
    staticClass: "ui-textbox__feedback-text"
  }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _c('div', {
    staticClass: "ui-textbox__feedback-text"
  }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e(), _vm._v(" "), _vm.maxlength ? _c('div', {
    staticClass: "ui-textbox__counter"
  }, [_vm._v("\n        " + _vm._s(_vm.valueLength + '/' + _vm.maxlength) + "\n      ")]) : _vm._e()]) : _vm._e()]), _vm._v(" "), _c('div', {
    ref: "suggestions",
    staticClass: "ui-textbox__suggestions"
  }, [_c('ul', _vm._l(_vm.matchingSuggestions, function (suggestion, index) {
    return _c('ui-textbox-suggestion', {
      key: index,
      attrs: {
        "keys": _vm.keys,
        "suggestion": suggestion,
        "type": _vm.suggestionType
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.selectSuggestion(suggestion);
        }
      }
    }, [_vm._t("suggestion", null, {
      "index": index,
      "suggestion": suggestion
    })], 2);
  }), 1)]), _vm._v(" "), !_vm.multiLine ? [_vm.$slots.append ? _c('div', {
    staticClass: "ui-textbox__append"
  }, [_vm._t("append")], 2) : _vm.$slots.extra ? _c('div', {
    staticClass: "ui-textbox__extra"
  }, [_vm._t("extra")], 2) : _vm._e()] : _vm._e()], 2);
};

var __vue_staticRenderFns__$1h = [];
/* style */

var __vue_inject_styles__$1r = undefined;
/* scoped */

var __vue_scope_id__$1r = undefined;
/* module identifier */

var __vue_module_identifier__$1r = undefined;
/* functional template */

var __vue_is_functional_template__$1r = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1r = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1h,
  staticRenderFns: __vue_staticRenderFns__$1h
}, __vue_inject_styles__$1r, __vue_script__$1r, __vue_scope_id__$1r, __vue_is_functional_template__$1r, __vue_module_identifier__$1r, false, undefined, undefined, undefined);

//
var script$1q = {
  name: 'ui-tag',
  props: {
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary'

    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    plain: {
      type: Boolean,
      default: false // æ¯å¦ä¸ºç©ºå¿æ ·å¼

    },
    round: {
      type: Boolean,
      default: false // æ¯å¦ä¸ºåè§æ ·å¼

    },
    closable: {
      type: Boolean,
      default: false // å³é­æé®

    }
  },
  methods: {
    handleClose: function handleClose(event) {
      event.stopPropagation();
      this.$emit('close', event);
    },
    handleClick: function handleClick(event) {
      this.$emit('click', event);
    }
  },
  computed: {
    classes: function classes() {
      return ['ui-tag', "ui-tag--type-".concat(this.type), "ui-tag--color-".concat(this.color), "ui-tag--size-".concat(this.size), {
        'is-plain': this.plain
      }, {
        'is-round': this.round
      }];
    }
  },
  components: {
    UiCloseButton: __vue_component__$1z,
    UiRippleInk: __vue_component__$1A
  }
};

/* script */
var __vue_script__$1q = script$1q;
/* template */

var __vue_render__$1g = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', {
    class: _vm.classes,
    on: {
      "click": _vm.handleClick
    }
  }, [_vm._t("default"), _vm._v(" "), _vm.closable ? _c('ui-close-button', {
    attrs: {
      "size": "small",
      "color": "white"
    },
    on: {
      "click": _vm.handleClose
    }
  }) : _vm._e(), _vm._v(" "), !_vm.closable ? _c('ui-ripple-ink') : _vm._e()], 2);
};

var __vue_staticRenderFns__$1g = [];
/* style */

var __vue_inject_styles__$1q = undefined;
/* scoped */

var __vue_scope_id__$1q = undefined;
/* module identifier */

var __vue_module_identifier__$1q = undefined;
/* functional template */

var __vue_is_functional_template__$1q = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1q = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1g,
  staticRenderFns: __vue_staticRenderFns__$1g
}, __vue_inject_styles__$1q, __vue_script__$1q, __vue_scope_id__$1q, __vue_is_functional_template__$1q, __vue_module_identifier__$1q, false, undefined, undefined, undefined);

function _extends$1(){return _extends$1=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$1.apply(this,arguments)}var normalMerge=["attrs","props","domProps"],toArrayMerge=["class","style","directives"],functionalMerge=["on","nativeOn"],mergeJsxProps=function(a){return a.reduce(function(c,a){for(var b in a)if(!c[b])c[b]=a[b];else if(-1!==normalMerge.indexOf(b))c[b]=_extends$1({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e);}else if(-1!==functionalMerge.indexOf(b)){for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h);}else c[b][f]=a[b][f];}else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];return c},{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments);}};var helper=mergeJsxProps;

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1p = {
  name: 'ui-checkbox',
  props: {
    name: String,
    label: String,
    tabindex: [String, Number],
    value: {
      required: true
    },
    trueValue: {
      default: true
    },
    falseValue: {
      default: false
    },
    submittedValue: {
      type: String,
      default: 'on' // HTML default

    },
    checked: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    color: {
      type: String,
      default: 'primary' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    disabled: {
      type: Boolean,
      default: false
    },
    indeterminate: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      isChecked: this.value === this.trueValue || this.checked
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-checkbox--color-".concat(this.color), "ui-checkbox--box-position-".concat(this.position), {
        'is-checked': this.isChecked
      }, {
        'is-active': this.isActive
      }, {
        'is-disabled': this.disabled
      }, {
        'is-indeterminate': this.indeterminate
      }];
    }
  },
  watch: {
    value: function value() {
      this.isChecked = this.value === this.trueValue;
    }
  },
  created: function created() {
    this.$emit('input', this.isChecked ? this.trueValue : this.falseValue);
  },
  methods: {
    focus: function focus() {
      this.$refs.input.focus();
    },
    onClick: function onClick(e) {
      var isCheckedPrevious = this.isChecked;
      var isChecked = e.target.checked;
      this.$emit('input', isChecked ? this.trueValue : this.falseValue, e);

      if (isCheckedPrevious !== isChecked) {
        e.target.checked = isCheckedPrevious; // å°checkedè¿åï¼ç¡®ä¿åæ¢ç¶ææ¯ç±valueæ¹åï¼èéåçç»ä»¶æ¬èº«åæ¢;

        this.$emit('change', isChecked ? this.trueValue : this.falseValue, e);
      }
    },
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    }
  }
};

/* script */
var __vue_script__$1p = script$1p;
/* template */

var __vue_render__$1f = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('label', {
    staticClass: "ui-checkbox",
    class: _vm.classes
  }, [_c('input', {
    ref: "input",
    staticClass: "ui-checkbox__input",
    attrs: {
      "type": "checkbox",
      "disabled": _vm.disabled,
      "name": _vm.name,
      "tabindex": _vm.tabindex
    },
    domProps: {
      "checked": _vm.isChecked,
      "value": _vm.submittedValue
    },
    on: {
      "blur": _vm.onBlur,
      "click": _vm.onClick,
      "focus": _vm.onFocus
    }
  }), _vm._v(" "), _vm._m(0), _vm._v(" "), _vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-checkbox__label-text"
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
};

var __vue_staticRenderFns__$1f = [function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-checkbox__checkmark"
  }, [_c('div', {
    staticClass: "ui-checkbox__checkmark-background"
  }), _vm._v(" "), _c('div', {
    staticClass: "ui-checkbox__focus-ring"
  })]);
}];
/* style */

var __vue_inject_styles__$1p = undefined;
/* scoped */

var __vue_scope_id__$1p = undefined;
/* module identifier */

var __vue_module_identifier__$1p = undefined;
/* functional template */

var __vue_is_functional_template__$1p = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1p = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1f,
  staticRenderFns: __vue_staticRenderFns__$1f
}, __vue_inject_styles__$1p, __vue_script__$1p, __vue_scope_id__$1p, __vue_is_functional_template__$1p, __vue_module_identifier__$1p, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1o = {
  name: 'ui-radio',
  props: {
    name: String,
    label: String,
    tabindex: [String, Number],
    value: {
      type: [Number, String],
      required: true
    },
    trueValue: {
      type: [Number, String],
      required: true
    },
    checked: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: 'primary' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    buttonPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-radio--color-".concat(this.color), "ui-radio--button-position-".concat(this.buttonPosition), {
        'is-active': this.isActive
      }, {
        'is-checked': this.isChecked
      }, {
        'is-disabled': this.disabled
      }];
    },
    isChecked: function isChecked() {
      return this.value === this.trueValue;
    }
  },
  created: function created() {
    if (this.checked) {
      this.$emit('input', this.trueValue);
    }
  },
  methods: {
    focus: function focus() {
      this.$refs.input.focus();
    },
    toggleCheck: function toggleCheck() {
      if (!this.disabled) {
        this.$emit('input', this.trueValue);
      }
    },
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    },
    onChange: function onChange(e) {
      this.$emit('change', this.isChecked, e);
    }
  }
};

/* script */
var __vue_script__$1o = script$1o;
/* template */

var __vue_render__$1e = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('label', {
    staticClass: "ui-radio",
    class: _vm.classes,
    on: {
      "click": _vm.toggleCheck
    }
  }, [_c('div', {
    staticClass: "ui-radio__input-wrapper"
  }, [_c('input', {
    ref: "input",
    staticClass: "ui-radio__input",
    attrs: {
      "type": "radio",
      "disabled": _vm.disabled,
      "name": _vm.name,
      "tabindex": _vm.tabindex
    },
    domProps: {
      "checked": _vm.checked,
      "value": _vm.trueValue
    },
    on: {
      "blur": _vm.onBlur,
      "change": _vm.onChange,
      "focus": _vm.onFocus
    }
  }), _vm._v(" "), _c('div', {
    staticClass: "ui-radio__focus-ring"
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-radio__outer-circle"
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-radio__inner-circle"
  })]), _vm._v(" "), _vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-radio__label-text"
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
};

var __vue_staticRenderFns__$1e = [];
/* style */

var __vue_inject_styles__$1o = undefined;
/* scoped */

var __vue_scope_id__$1o = undefined;
/* module identifier */

var __vue_module_identifier__$1o = undefined;
/* functional template */

var __vue_is_functional_template__$1o = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1o = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1e,
  staticRenderFns: __vue_staticRenderFns__$1e
}, __vue_inject_styles__$1o, __vue_script__$1o, __vue_scope_id__$1o, __vue_is_functional_template__$1o, __vue_module_identifier__$1o, false, undefined, undefined, undefined);

var dP = _objectDp.f;
var gOPN = _objectGopn.f;


var $RegExp = _global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (_descriptors && (!CORRECT_NEW || _fails(function () {
  re2[_wks('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = _isRegexp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : _inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i$3 = 0; keys.length > i$3;) proxy(keys[i$3++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  _redefine(_global, 'RegExp', $RegExp);
}

_setSpecies('RegExp');

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

// @@match logic
_fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      if (!rx.global) return _regexpExecAbstract(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = _regexpExecAbstract(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

function isString$1(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
}
function isObject$2(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
var isFunction$1 = function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
};
var isUndefined$1 = function isUndefined(val) {
  return val === void 0;
};

var generateId = function generateId() {
  return Math.floor(Math.random() * 10000);
};
var valueEquals = function valueEquals(a, b) {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;

  for (var i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};

var coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};
var capitalize = function capitalize(str) {
  if (!isString$1(str)) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
};
var looseEqual = function looseEqual(a, b) {
  var isObjectA = isObject$2(a);
  var isObjectB = isObject$2(b);

  if (isObjectA && isObjectB) {
    return JSON.stringify(a) === JSON.stringify(b);
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
};
var arrayEquals = function arrayEquals(arrayA, arrayB) {
  arrayA = arrayA || [];
  arrayB = arrayB || [];

  if (arrayA.length !== arrayB.length) {
    return false;
  }

  for (var i = 0; i < arrayA.length; i++) {
    if (!looseEqual(arrayA[i], arrayB[i])) {
      return false;
    }
  }

  return true;
};
var isEqual = function isEqual(value1, value2) {
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return arrayEquals(value1, value2);
  }

  return looseEqual(value1, value2);
};
var isEmpty = function isEmpty(val) {
  // null or undefined
  if (val == null) return true;
  if (typeof val === 'boolean') return false;
  if (typeof val === 'number') return !val;
  if (val instanceof Error) return val.message === '';

  switch (Object.prototype.toString.call(val)) {
    // String or Array
    case '[object String]':
    case '[object Array]':
      return !val.length;
    // Map or Set or File

    case '[object File]':
    case '[object Map]':
    case '[object Set]':
      {
        return !val.size;
      }
    // Plain Object

    case '[object Object]':
      {
        return !Object.keys(val).length;
      }
  }

  return false;
};
function numToPx(num) {
  if (!isNaN(num)) {
    return "".concat(num, "px");
  }

  return num;
}
function wrapFn(fn) {
  if ('function' === typeof fn) {
    return fn;
  }

  return function () {
    return fn;
  };
} // è¿ä¸¤ä¸ªå¯¹è±¡ key çé¡ºåºä¼å½±å formatTime å toTimeData çè§£æ

var formatSpecifiers = {
  days: 'dd',
  hours: 'hh',
  minutes: 'mm',
  seconds: 'ss',
  milliseconds: 'ms'
};
var millisecondsIn = {
  days: 60 * 60 * 24 * 1000,
  hours: 60 * 60 * 1000,
  minutes: 60 * 1000,
  seconds: 1 * 1000,
  milliseconds: 1
};
/**
 * åè½ä¸ Object.entries ç¸å
 */

function entries(obj) {
  return Object.keys(obj).map(function (k) {
    return [k, obj[k]];
  });
}
/**
 * åè½ä¸ String.prototype.includes ç¸å
 */


function includes(str, v) {
  return str.indexOf(v) > -1;
}
/**
 * åè½ä¸ String.prototype.padStart ç¸å
 */


function padStart(str, len, v) {
  while (str.length < len) {
    str = v + str;
  }

  return str;
}

function padZero(str) {
  var padRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return padStart(str + '', padRange, '0');
}
/**
 * å¤©ãå°æ¶ãåéãç§ãæ¯«ç§æ ¼å¼å
 * @param {string} key
 * @param {number} value
 * @returns {string}
 */


function timeFormatter(key, value) {
  // å¤©ãæ¶ãåãç§ä¸¤ä½ï¼æ¯«ç§ä¸ä½
  if (key === 'milliseconds') {
    return padZero(value, 3);
  } else {
    return padZero(value);
  }
}

function toMilliseconds() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$days = _ref.days,
      d = _ref$days === void 0 ? 0 : _ref$days,
      _ref$hours = _ref.hours,
      h = _ref$hours === void 0 ? 0 : _ref$hours,
      _ref$minutes = _ref.minutes,
      m = _ref$minutes === void 0 ? 0 : _ref$minutes,
      _ref$seconds = _ref.seconds,
      s = _ref$seconds === void 0 ? 0 : _ref$seconds,
      _ref$milliseconds = _ref.milliseconds,
      ms = _ref$milliseconds === void 0 ? 0 : _ref$milliseconds;

  return ms + 1000 * (s + 60 * (m + 60 * (h + 24 * d)));
}
/**
 * æç§formatæ ¼å¼æ¥å¡«å¥æ¶é´
 * @param {number} time - å©ä½æ¶é´æ¯«ç§æ°
 * @param {string} format - æ ¼å¼å­ç¬¦ä¸²
 */

function formatTime(time, format) {
  var result = format; // æ³¨æé¡ºåºå¾éè¦ãè¦åä»å¤§çæ¶é´åä½å¼å§æé å­ç¬¦ä¸²

  entries(formatSpecifiers).forEach(function (_ref2) {
    var _ref3 = slicedToArray(_ref2, 2),
        k = _ref3[0],
        specifier = _ref3[1];

    if (includes(result, specifier)) {
      var v = Math.floor(time / millisecondsIn[k]);
      time -= v * millisecondsIn[k];
      result = result.replace(specifier, timeFormatter(k, v));
    }
  });
  return result;
}
/**
 * å°æ¯«ç§æ°è§£æä¸ºtimeData
 * @param {number} time - å©ä½æ¶é´æ¯«ç§æ°
 * @return æ°æ®å¯¹è±¡ï¼åå«days, hours, minutes, seconds & millisecondså­æ®µ
 */

function toTimeData(time) {
  var timeData = {};
  entries(millisecondsIn).forEach(function (_ref4) {
    var _ref5 = slicedToArray(_ref4, 2),
        k = _ref5[0],
        v = _ref5[1];

    timeData[k] = Math.floor(time / v);
    time -= timeData[k] * v;
  });
  return timeData;
}

var stopPropagation = function stopPropagation(e) {
  return e.stopPropagation();
};

var script$1n = {
  name: 'ui-cascader-node',
  inject: ['panel'],
  components: {
    UiCheckbox: __vue_component__$1p,
    UiRadio: __vue_component__$1o,
    UiIcon: __vue_component__$1B
  },
  props: {
    node: {
      required: true
    },
    nodeId: String
  },
  computed: {
    config: function config() {
      return this.panel.config;
    },
    isLeaf: function isLeaf() {
      return this.node.isLeaf;
    },
    isDisabled: function isDisabled() {
      return this.node.isDisabled;
    },
    checkedValue: function checkedValue() {
      return this.panel.checkedValue;
    },
    isChecked: function isChecked() {
      return this.node.isSameNode(this.checkedValue);
    },
    inActivePath: function inActivePath() {
      return this.isInPath(this.panel.activePath);
    },
    inCheckedPath: function inCheckedPath() {
      var _this = this;

      if (!this.config.checkStrictly) return false;
      return this.panel.checkedNodePaths.some(function (checkedPath) {
        return _this.isInPath(checkedPath);
      });
    },
    value: function value() {
      return this.node.getValueByOption();
    }
  },
  methods: {
    handleExpand: function handleExpand() {
      var _this2 = this;

      var panel = this.panel,
          node = this.node,
          isDisabled = this.isDisabled,
          config = this.config;
      var multiple = config.multiple,
          checkStrictly = config.checkStrictly;
      if (!checkStrictly && isDisabled || node.loading) return;

      if (config.lazyload && !node.loaded) {
        panel.handleLazyload(node, function () {
          // do not use cached leaf value here, invoke this.isLeaf to get new value.
          var isLeaf = _this2.isLeaf;
          if (!isLeaf) _this2.handleExpand();

          if (multiple) {
            // if leaf sync checked state, else clear checked state
            var checked = isLeaf ? node.checked : false;

            _this2.handleMultiCheckChange(checked);
          }
        });
      } else {
        panel.handleExpand(node);
      }
    },
    handleCheckChange: function handleCheckChange() {
      var panel = this.panel,
          value = this.value,
          node = this.node;
      panel.handleCheckChange(value);
      panel.handleExpand(node);
    },
    handleMultiCheckChange: function handleMultiCheckChange(checked) {
      this.node.doCheck(checked);
      this.panel.calculateMultiCheckedValue();
    },
    isInPath: function isInPath(pathNodes) {
      var node = this.node;
      var selectedPathNode = pathNodes[node.level - 1] || {};
      return selectedPathNode.uid === node.uid;
    },
    renderPrefix: function renderPrefix(h) {
      var isLeaf = this.isLeaf,
          isChecked = this.isChecked,
          config = this.config,
          node = this.node;
      var checkStrictly = config.checkStrictly,
          multiple = config.multiple;

      if (multiple) {
        if (node.data.single) return this.renderRadio(h);else return this.renderCheckbox(h);
      } else if (checkStrictly) {
        return this.renderRadio(h);
      } else if (isLeaf && isChecked) {
        return this.renderCheckIcon(h);
      }

      return h("div", {
        "class": "item-other"
      }, [this.renderContent(h), this.renderPostfix(h)]);
    },
    renderPostfix: function renderPostfix(h) {
      var node = this.node,
          isLeaf = this.isLeaf;

      if (node.loading) {
        return this.renderLoadingIcon(h);
      } else if (!isLeaf) {
        return this.renderExpandIcon(h);
      }

      return null;
    },
    renderCheckbox: function renderCheckbox(h) {
      var node = this.node,
          config = this.config,
          isDisabled = this.isDisabled;
      var events = {
        on: {
          change: this.handleMultiCheckChange
        },
        nativeOn: {}
      };

      if (config.checkStrictly) {
        // when every node is selectable, click event should not trigger expand event.
        events.nativeOn.click = stopPropagation;
      }

      return h("ui-checkbox", helper([{
        "attrs": {
          "value": node.checked,
          "indeterminate": node.indeterminate,
          "disabled": isDisabled
        }
      }, events]), [this.renderContent(h), this.renderPostfix(h)]);
    },
    renderRadio: function renderRadio(h) {
      var checkedValue = this.checkedValue,
          value = this.value,
          isDisabled = this.isDisabled; // to keep same reference if value cause radio's checked state is calculated by reference comparision;

      if (isEqual(value, checkedValue)) {
        value = checkedValue;
      }

      return h("ui-radio", {
        "attrs": {
          "value": JSON.stringify(checkedValue),
          "trueValue": JSON.stringify(value),
          "disabled": isDisabled,
          "checked": value == this.checkedValue
        },
        "on": {
          "change": this.handleCheckChange
        },
        "nativeOn": {
          "click": stopPropagation
        }
      }, [this.renderContent(h), this.renderPostfix(h)]);
    },
    renderCheckIcon: function renderCheckIcon(h) {
      return h("div", {
        "class": "item-other"
      }, [h("ui-icon", {
        "class": "ui-cascader-node__postfix",
        "attrs": {
          "icon": "done"
        }
      }), this.renderContent(h), this.renderPostfix(h)]);
    },
    renderLoadingIcon: function renderLoadingIcon(h) {
      return h("ui-icon", {
        "class": "ui-cascader-node__postfix is-loadding"
      }, [h("svg", {
        "class": "icon",
        "style": "width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;",
        "attrs": {
          "viewBox": "0 0 1024 1024",
          "version": "1.1",
          "xmlns": "http://www.w3.org/2000/svg",
          "p-id": "1814"
        }
      }, [h("path", {
        "attrs": {
          "d": "M533.333333 682.666667v192h-64v-192h64z m-175.317333-72.618667l45.269333 45.269333-135.765333 135.744-45.248-45.226666 135.744-135.786667z m286.634667 0l135.744 135.765333-45.226667 45.248-135.786667-135.744 45.269334-45.269333zM330.666667 480v64h-192v-64h192z m533.333333 0v64h-192v-64h192z m-128.853333-247.061333l45.248 45.226666-135.744 135.786667-45.269334-45.269333 135.765334-135.744z m-467.626667 0l135.765333 135.744-45.269333 45.269333-135.744-135.765333 45.226667-45.248zM533.333333 149.333333v192h-64V149.333333h64z",
          "p-id": "1815"
        }
      })])]);
    },
    renderExpandIcon: function renderExpandIcon(h) {
      return h("ui-icon", {
        "class": "ui-cascader-node__postfix",
        "attrs": {
          "icon": "chevron_right"
        }
      });
    },
    renderContent: function renderContent(h) {
      var panel = this.panel,
          node = this.node;
      var render = panel.renderLabelFn;
      var vnode = render ? render({
        node: node,
        data: node.data
      }) : null;
      return h("span", {
        "class": "ui-cascader-node__label"
      }, [vnode || node.label]);
    }
  },
  render: function render(h) {
    var _this3 = this;

    var inActivePath = this.inActivePath,
        inCheckedPath = this.inCheckedPath,
        isChecked = this.isChecked,
        isLeaf = this.isLeaf,
        isDisabled = this.isDisabled,
        config = this.config,
        nodeId = this.nodeId;
    var expandTrigger = config.expandTrigger,
        checkStrictly = config.checkStrictly,
        multiple = config.multiple;
    var disabled = !checkStrictly && isDisabled;
    var events = {
      on: {}
    };

    if (expandTrigger === 'click') {
      events.on.click = this.handleExpand;
    } else {
      events.on.mouseenter = function (e) {
        _this3.handleExpand();

        _this3.$emit('expand', e);
      };

      events.on.focus = function (e) {
        _this3.handleExpand();

        _this3.$emit('expand', e);
      };
    }

    if (isLeaf && !isDisabled && !checkStrictly && !multiple) {
      events.on.click = this.handleCheckChange;
    }

    return h("li", helper([{
      "attrs": {
        "role": "menuitem",
        "id": nodeId,
        "aria-expanded": inActivePath,
        "tabindex": disabled ? null : -1
      },
      "class": {
        'ui-cascader-node': true,
        'is-selectable': checkStrictly,
        'in-active-path': inActivePath,
        'in-checked-path': inCheckedPath,
        'is-active': isChecked,
        'is-disabled': disabled
      }
    }, events]), [this.renderPrefix(h)]);
  }
};

/* script */
var __vue_script__$1n = script$1n;
/* template */

/* style */

var __vue_inject_styles__$1n = undefined;
/* scoped */

var __vue_scope_id__$1n = undefined;
/* module identifier */

var __vue_module_identifier__$1n = undefined;
/* functional template */

var __vue_is_functional_template__$1n = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1n = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$1n, __vue_script__$1n, __vue_scope_id__$1n, __vue_is_functional_template__$1n, __vue_module_identifier__$1n, false, undefined, undefined, undefined);

var script$1m = {
  name: 'ui-cascader-menu',
  inject: ['panel'],
  components: {
    UiCascaderNode: __vue_component__$1n
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: Number
  },
  data: function data() {
    return {
      activeNode: null,
      hoverTimer: null,
      id: generateId()
    };
  },
  computed: {
    isEmpty: function isEmpty() {
      return !this.nodes.length;
    },
    menuId: function menuId() {
      return "cascader-menu-".concat(this.id, "-").concat(this.index);
    }
  },
  methods: {
    handleExpand: function handleExpand(e) {
      this.activeNode = e.target;
    },
    handleMouseMove: function handleMouseMove(e) {
      var activeNode = this.activeNode,
          hoverTimer = this.hoverTimer;
      var hoverZone = this.$refs.hoverZone;
      if (!activeNode || !hoverZone) return;

      if (activeNode.contains(e.target)) {
        clearTimeout(hoverTimer);

        var _this$$el$getBounding = this.$el.getBoundingClientRect(),
            left = _this$$el$getBounding.left;

        var startX = e.clientX - left;
        var _this$$el = this.$el,
            offsetWidth = _this$$el.offsetWidth,
            offsetHeight = _this$$el.offsetHeight;
        var top = activeNode.offsetTop;
        var bottom = top + activeNode.offsetHeight;
        hoverZone.innerHTML = "\n          <path style=\"pointer-events: auto;\" fill=\"transparent\" d=\"M".concat(startX, " ").concat(top, " L").concat(offsetWidth, " 0 V").concat(top, " Z\" />\n          <path style=\"pointer-events: auto;\" fill=\"transparent\" d=\"M").concat(startX, " ").concat(bottom, " L").concat(offsetWidth, " ").concat(offsetHeight, " V").concat(bottom, " Z\" />\n        ");
      } else if (!hoverTimer) {
        this.hoverTimer = setTimeout(this.clearHoverZone, this.panel.config.hoverThreshold);
      }
    },
    clearHoverZone: function clearHoverZone() {
      var hoverZone = this.$refs.hoverZone;
      if (!hoverZone) return;
      hoverZone.innerHTML = '';
    },
    renderEmptyText: function renderEmptyText(h) {
      return h("div", {
        "class": "ui-cascader-menu__empty-text"
      }, ["\u6682\u65E0\u6570\u636E"]);
    },
    renderNodeList: function renderNodeList(h) {
      var menuId = this.menuId;
      var isHoverMenu = this.panel.isHoverMenu;
      var events = {
        on: {}
      };

      if (isHoverMenu) {
        events.on.expand = this.handleExpand;
      }

      var nodes = this.nodes.map(function (node, index) {
        var hasChildren = node.hasChildren;
        return h("ui-cascader-node", helper([{
          "key": node.uid,
          "attrs": {
            "node": node,
            "node-id": "".concat(menuId, "-").concat(index),
            "aria-haspopup": hasChildren,
            "aria-owns": hasChildren ? menuId : null
          }
        }, events]));
      });
      return [].concat(toConsumableArray(nodes), [isHoverMenu ? h("svg", {
        "ref": "hoverZone",
        "class": "ui-cascader-menu__hover-zone"
      }) : null]);
    }
  },
  render: function render(h) {
    var isEmpty = this.isEmpty,
        menuId = this.menuId;
    var events = {
      on: {}
    }; // optimize hover to expand experience (#8010)

    if (this.panel.isHoverMenu) {
      events.on.mousemove = this.handleMouseMove; // events.nativeOn.mouseleave = this.clearHoverZone;
    }

    return h("div", helper([{
      "class": "ui-cascader-menu",
      "attrs": {
        "id": menuId
      }
    }, events]), [h("ul", {
      "class": {
        'ui-cascader-menu__list': true,
        'is-empty': isEmpty
      }
    }, [isEmpty ? this.renderEmptyText(h) : this.renderNodeList(h)])]);
  }
};

/* script */
var __vue_script__$1m = script$1m;
/* template */

/* style */

var __vue_inject_styles__$1m = undefined;
/* scoped */

var __vue_scope_id__$1m = undefined;
/* module identifier */

var __vue_module_identifier__$1m = undefined;
/* functional template */

var __vue_is_functional_template__$1m = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1m = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$1m, __vue_script__$1m, __vue_scope_id__$1m, __vue_is_functional_template__$1m, __vue_module_identifier__$1m, false, undefined, undefined, undefined);

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck$1;

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass$1;

function isDef(val) {
  return val !== undefined && val !== null;
}

var uid$1 = 0;

var Node$2 = /*#__PURE__*/function () {
  function Node(data, config, parentNode) {
    classCallCheck(this, Node);

    this.data = data;
    this.config = config;
    this.parent = parentNode || null;
    this.level = !this.parent ? 1 : this.parent.level + 1;
    this.uid = uid$1++;
    this.initState();
    this.initChildren();
  }

  createClass(Node, [{
    key: "initState",
    value: function initState() {
      var _this$config = this.config,
          valueKey = _this$config.value,
          labelKey = _this$config.label;
      this.value = this.data[valueKey];
      this.label = this.data[labelKey];
      this.pathNodes = this.calculatePathNodes();
      this.path = this.pathNodes.map(function (node) {
        return node.value;
      });
      this.pathLabels = this.pathNodes.map(function (node) {
        return node.label;
      }); // lazy load

      this.loading = false;
      this.loaded = false;
    }
  }, {
    key: "initChildren",
    value: function initChildren() {
      var _this = this;

      var config = this.config;
      var childrenKey = config.children;
      var childrenData = this.data[childrenKey];
      this.hasChildren = Array.isArray(childrenData);
      this.children = (childrenData || []).map(function (child) {
        return new Node(child, config, _this);
      });
    }
  }, {
    key: "isDisabled",
    get: function get() {
      var data = this.data,
          parent = this.parent,
          config = this.config;
      var disabledKey = config.disabled;
      var checkStrictly = config.checkStrictly;
      return data[disabledKey] || !checkStrictly && parent && parent.isDisabled;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      var data = this.data,
          loaded = this.loaded,
          hasChildren = this.hasChildren,
          children = this.children;
      var _this$config2 = this.config,
          lazyload = _this$config2.lazyload,
          leafKey = _this$config2.leaf;

      if (lazyload) {
        var isLeaf = isDef(data[leafKey]) ? data[leafKey] : loaded ? !children.length : false;
        this.hasChildren = !isLeaf;
        return isLeaf;
      }

      return !hasChildren;
    }
  }, {
    key: "calculatePathNodes",
    value: function calculatePathNodes() {
      var nodes = [this];
      var parent = this.parent;

      while (parent) {
        nodes.unshift(parent);
        parent = parent.parent;
      }

      return nodes;
    }
  }, {
    key: "getPath",
    value: function getPath() {
      return this.path;
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.value;
    }
  }, {
    key: "getValueByOption",
    value: function getValueByOption() {
      return this.config.emitPath ? this.getPath() : this.getValue();
    }
  }, {
    key: "getText",
    value: function getText(allLevels, separator) {
      return allLevels ? this.pathLabels.join(separator) : this.label;
    }
  }, {
    key: "isSameNode",
    value: function isSameNode(checkedValue) {
      var value = this.getValueByOption();
      return this.config.multiple && Array.isArray(checkedValue) ? checkedValue.some(function (val) {
        return isEqual(val, value);
      }) : isEqual(checkedValue, value);
    }
  }, {
    key: "broadcast",
    value: function broadcast(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var handlerName = "onParent".concat(capitalize(event));
      this.children.forEach(function (child) {
        if (child) {
          // bottom up
          child.broadcast.apply(child, [event].concat(args));
          child[handlerName] && child[handlerName].apply(child, args);
        }
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var parent = this.parent;
      var handlerName = "onChild".concat(capitalize(event));

      if (parent) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        parent[handlerName] && parent[handlerName].apply(parent, args);
        parent.emit.apply(parent, [event].concat(args));
      }
    }
  }, {
    key: "onParentCheck",
    value: function onParentCheck(checked) {
      if (!this.isDisabled) {
        this.setCheckState(checked);
      }
    }
  }, {
    key: "onChildCheck",
    value: function onChildCheck() {
      var children = this.children;
      var validChildren = children.filter(function (child) {
        return !child.isDisabled;
      });
      var checked = validChildren.length ? validChildren.every(function (child) {
        return child.checked;
      }) : false;
      this.setCheckState(checked);
    }
  }, {
    key: "setCheckState",
    value: function setCheckState(checked) {
      var totalNum = this.children.length;
      var checkedNum = this.children.reduce(function (c, p) {
        var num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
        return c + num;
      }, 0);
      this.checked = checked;
      this.indeterminate = checkedNum !== totalNum && checkedNum > 0;
    }
  }, {
    key: "syncCheckState",
    value: function syncCheckState(checkedValue) {
      var value = this.getValueByOption();
      var checked = this.isSameNode(checkedValue, value);
      this.doCheck(checked);
    }
  }, {
    key: "doCheck",
    value: function doCheck(checked) {
      if (this.checked !== checked) {
        if (this.config.checkStrictly) {
          this.checked = checked;
        } else {
          // bottom up to unify the calculation of the indeterminate state
          this.broadcast('check', checked);
          this.setCheckState(checked);
          this.emit('check');
        }
      }
    }
  }]);

  return Node;
}();

var flatNodes = function flatNodes(data, leafOnly) {
  return data.reduce(function (res, node) {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }

    return res;
  }, []);
};

var Store = /*#__PURE__*/function () {
  function Store(data, config) {
    classCallCheck(this, Store);

    this.config = config;
    this.initNodes(data);
  }

  createClass(Store, [{
    key: "initNodes",
    value: function initNodes(data) {
      var _this = this;

      data = coerceTruthyValueToArray(data);
      this.nodes = data.map(function (nodeData) {
        return new Node$2(nodeData, _this.config);
      });
      this.flattedNodes = this.getFlattedNodes(false, false);
      this.leafNodes = this.getFlattedNodes(true, false);
    }
  }, {
    key: "appendNode",
    value: function appendNode(nodeData, parentNode) {
      var node = new Node$2(nodeData, this.config, parentNode);
      var children = parentNode ? parentNode.children : this.nodes;
      children.push(node);
    }
  }, {
    key: "appendNodes",
    value: function appendNodes(nodeDataList, parentNode) {
      var _this2 = this;

      nodeDataList = coerceTruthyValueToArray(nodeDataList);
      nodeDataList.forEach(function (nodeData) {
        return _this2.appendNode(nodeData, parentNode);
      });
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      return this.nodes;
    }
  }, {
    key: "getFlattedNodes",
    value: function getFlattedNodes(leafOnly) {
      var cached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var cachedNodes = leafOnly ? this.leafNodes : this.flattedNodes;
      return cached ? cachedNodes : flatNodes(this.nodes, leafOnly);
    }
  }, {
    key: "getNodeByValue",
    value: function getNodeByValue(value) {
      if (value) {
        var nodes = this.getFlattedNodes(false, !this.config.lazyload).filter(function (node) {
          return valueEquals(node.path, value) || node.value === value;
        });
        return nodes && nodes.length ? nodes[0] : null;
      }

      return null;
    }
  }]);

  return Store;
}();

function scrollIntoView$1(container, selected) {
  if (Vue.prototype.$isServer) return;

  if (!selected || !container.contains(selected)) {
    container.scrollTop = 0;
    return;
  }

  var _ref = container.getBoundingClientRect() || {},
      parentTop = _ref.top,
      parentBottom = _ref.bottom;

  var _ref2 = selected.getBoundingClientRect() || {},
      top = _ref2.top,
      bottom = _ref2.bottom;

  if (top >= parentTop && bottom <= parentBottom) return; // å¯è§èå´åä¸å¤ç

  container.scrollTop = container.scrollTop + top - parentTop;
}

function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var isLeaf = function isLeaf(el) {
  return !el.getAttribute('aria-owns');
};

var getSibling = function getSibling(el, distance) {
  var parentNode = el.parentNode;

  if (parentNode) {
    var siblings = parentNode.querySelectorAll('.ui-cascader-node[tabindex="-1"]');
    var index = Array.prototype.indexOf.call(siblings, el);
    return siblings[index + distance] || null;
  }

  return null;
};

var getMenuIndex = function getMenuIndex(el, distance) {
  if (!el) return;
  var pieces = el.id.split('-');
  return Number(pieces[pieces.length - 2]);
};

var focusNode = function focusNode(el) {
  if (!el) return;
  el.focus();
  !isLeaf(el) && el.click();
};

var checkNode = function checkNode(el) {
  if (!el) return;
  var input = el.querySelector('input');

  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};

var script$1l = {
  name: 'ui-cascader-panel',
  components: {
    UiCascaderMenu: __vue_component__$1m
  },
  props: {
    value: {},
    options: Array,
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function,
    expandTrigger: {
      type: String,
      default: 'hover'
    },
    multiple: {
      type: Boolean,
      default: false
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    emitPath: {
      type: Boolean,
      default: true // wether to emit an array of all levels value in which node is located

    },
    lazyload: Function,
    keys: {
      type: Object,
      default: function _default() {
        return {
          value: 'value',
          label: 'label',
          children: 'children',
          leaf: 'leaf',
          disabled: 'disabled'
        };
      }
    },
    hoverThreshold: {
      type: Number,
      default: 500
    }
  },
  provide: function provide() {
    return {
      panel: this
    };
  },
  data: function data() {
    return {
      checkedValue: null,
      checkedNodePaths: [],
      store: [],
      menus: [],
      activePath: [],
      loadCount: 0
    };
  },
  computed: {
    config: function config() {
      return _objectSpread$f(_objectSpread$f({
        value: 'value',
        label: 'label',
        children: 'children',
        leaf: 'leaf',
        disabled: 'disabled'
      }, this.keys), {}, {
        expandTrigger: this.expandTrigger,
        multiple: this.multiple,
        checkStrictly: this.checkStrictly,
        emitPath: this.emitPath,
        lazyload: this.lazyload,
        hoverThreshold: this.hoverThreshold
      });
    },
    leafOnly: function leafOnly() {
      return !this.checkStrictly;
    },
    isHoverMenu: function isHoverMenu() {
      return this.config.expandTrigger === 'hover';
    },
    renderLabelFn: function renderLabelFn() {
      return this.renderLabel || this.$scopedSlots.default;
    }
  },
  watch: {
    options: {
      handler: function handler() {
        this.initStore();
      },
      immediate: true,
      deep: true
    },
    value: function value() {
      this.syncCheckedValue();
      this.checkStrictly && this.calculateCheckedNodePaths();
    },
    checkedValue: function checkedValue(val) {
      if (!isEqual(val, this.value)) {
        this.checkStrictly && this.calculateCheckedNodePaths();
        this.$emit('input', val);
        this.$emit('change', val);
      }
    }
  },
  mounted: function mounted() {
    if (!isEmpty(this.value)) {
      this.syncCheckedValue();
    }
  },
  methods: {
    initStore: function initStore() {
      var _this = this;

      var config = this.config,
          options = this.options;

      if (config.lazyload && isEmpty(options)) {
        this.handleLazyload();
      } else {
        this.store = new Store(options, config);
        this.menus = [this.store.getNodes()];
        this.syncMenuState();
        this.$nextTick(function () {
          return _this.scrollIntoView();
        });
      }
    },
    syncCheckedValue: function syncCheckedValue() {
      this.checkedValue = this.value;
      this.syncMenuState();
    },
    syncMenuState: function syncMenuState() {
      var multiple = this.multiple,
          checkStrictly = this.checkStrictly;
      this.syncActivePath();
      multiple && this.syncMultiCheckState();
      checkStrictly && this.calculateCheckedNodePaths();
    },
    syncMultiCheckState: function syncMultiCheckState() {
      var _this2 = this;

      var nodes = this.getFlattedNodes(this.leafOnly);
      nodes.forEach(function (node) {
        node.syncCheckState(_this2.checkedValue);
      });
    },
    syncActivePath: function syncActivePath() {
      var _this3 = this;

      var checkedValue = this.checkedValue,
          store = this.store,
          multiple = this.multiple;

      if (isEmpty(checkedValue)) {
        this.activePath = [];
        this.menus = [store.getNodes()];
      } else {
        checkedValue = multiple ? checkedValue[0] : checkedValue;
        var checkedNode = this.getNodeByValue(checkedValue) || {};
        var nodes = [];
        checkedNode.parent;

        nodes.forEach(function (node) {
          return _this3.handleExpand(node, true
          /* silent */
          );
        });
      }
    },
    expandNodes: function expandNodes(nodes) {
      var _this4 = this;

      nodes.forEach(function (node) {
        return _this4.handleExpand(node, true
        /* silent */
        );
      });
    },
    calculateCheckedNodePaths: function calculateCheckedNodePaths() {
      var _this5 = this;

      var checkedValue = this.checkedValue,
          multiple = this.multiple;
      var checkedValues = multiple ? coerceTruthyValueToArray(checkedValue) : [checkedValue];
      this.checkedNodePaths = checkedValues.map(function (v) {
        var checkedNode = _this5.getNodeByValue(v);

        return checkedNode ? checkedNode.pathNodes : [];
      });
    },
    handleKeyDown: function handleKeyDown(e) {
      var target = e.target,
          keyCode = e.keyCode;

      switch (keyCode) {
        case KeyCode.up:
          var prev = getSibling(target, -1);
          focusNode(prev);
          break;

        case KeyCode.down:
          var next = getSibling(target, 1);
          focusNode(next);
          break;

        case KeyCode.left:
          var preMenu = this.$refs.menu[getMenuIndex(target) - 1];

          if (preMenu) {
            var expandedNode = preMenu.$el.querySelector('.ui-cascader-node[aria-expanded="true"]');
            focusNode(expandedNode);
          }

          break;

        case KeyCode.right:
          var nextMenu = this.$refs.menu[getMenuIndex(target) + 1];

          if (nextMenu) {
            var firstNode = nextMenu.$el.querySelector('.ui-cascader-node[tabindex="-1"]');
            focusNode(firstNode);
          }

          break;

        case KeyCode.enter:
          checkNode(target);
          break;

        case KeyCode.esc:
        case KeyCode.tab:
          this.$emit('close');
          break;

        default:
          return;
      }
    },
    handleExpand: function handleExpand(node, silent) {
      var activePath = this.activePath;
      var level = node.level;
      var path = activePath.slice(0, level - 1);
      var menus = this.menus.slice(0, level);

      if (!node.isLeaf) {
        path.push(node);
        menus.push(node.children);
      }

      this.activePath = path;
      this.menus = menus;

      if (!silent) {
        var pathValues = path.map(function (node) {
          return node.getValue();
        });
        var activePathValues = activePath.map(function (node) {
          return node.getValue();
        });

        if (!valueEquals(pathValues, activePathValues)) {
          this.$emit('expand-change', pathValues);
        }
      }
    },
    handleCheckChange: function handleCheckChange(value) {
      this.checkedValue = value;
    },
    handleLazyload: function handleLazyload(node, onFullfiled) {
      var _this6 = this;

      var config = this.config;

      if (!node) {
        node = node || {
          root: true,
          level: 0
        };
        this.store = new Store([], config);
        this.menus = [this.store.getNodes()];
      }

      node.loading = true;

      var resolve = function resolve(dataList) {
        var parent = node.root ? null : node;
        dataList && dataList.length && _this6.store.appendNodes(dataList, parent);
        node.loading = false;
        node.loaded = true; // dispose default value on lazy load mode

        if (Array.isArray(_this6.checkedValue)) {
          var nodeValue = _this6.checkedValue[_this6.loadCount++];
          var valueKey = _this6.config.value;
          var leafKey = _this6.config.leaf;

          if (Array.isArray(dataList) && dataList.filter(function (item) {
            return item[valueKey] === nodeValue;
          }).length > 0) {
            var checkedNode = _this6.store.getNodeByValue(nodeValue);

            if (!checkedNode.data[leafKey]) {
              _this6.handleLazyload(checkedNode, function () {
                _this6.handleExpand(checkedNode);
              });
            }

            if (_this6.loadCount === _this6.checkedValue.length) {
              _this6.$parent.computePresentText();
            }
          }
        }

        onFullfiled && onFullfiled(dataList);
      };

      config.lazyload(node, resolve);
    },

    /**
     * public methods
     */
    calculateMultiCheckedValue: function calculateMultiCheckedValue() {
      this.checkedValue = this.getCheckedNodes(this.leafOnly).map(function (node) {
        return node.getValueByOption();
      });
    },
    scrollIntoView: function scrollIntoView() {
      if (this.$isServer) return;
      var menus = this.$refs.menu || [];
      menus.forEach(function (menu) {
        var menuElement = menu.$el;

        if (menuElement) {
          var activeNode = menuElement.querySelector('.ui-cascader-node.in-active-path') || menuElement.querySelector('.ui-cascader-node.is-active');

          scrollIntoView$1(menuElement, activeNode);
        }
      });
    },
    getNodeByValue: function getNodeByValue(val) {
      return this.store.getNodeByValue(val);
    },
    getFlattedNodes: function getFlattedNodes(leafOnly) {
      var cached = !this.config.lazyload;
      return this.store.getFlattedNodes(leafOnly, cached);
    },
    getCheckedNodes: function getCheckedNodes(leafOnly) {
      var checkedValue = this.checkedValue,
          multiple = this.multiple;

      if (multiple) {
        var nodes = this.getFlattedNodes(leafOnly);
        return nodes.filter(function (node) {
          return node.checked;
        });
      } else {
        return isEmpty(checkedValue) ? [] : [this.getNodeByValue(checkedValue)];
      }
    },
    clearCheckedNodes: function clearCheckedNodes() {
      var config = this.config,
          leafOnly = this.leafOnly;
      var multiple = config.multiple,
          emitPath = config.emitPath;

      if (multiple) {
        this.getCheckedNodes(leafOnly).filter(function (node) {
          return !node.isDisabled;
        }).forEach(function (node) {
          return node.doCheck(false);
        });
        this.calculateMultiCheckedValue();
      } else {
        this.checkedValue = emitPath ? [] : null;
      }
    }
  }
};

/* script */
var __vue_script__$1l = script$1l;
/* template */

var __vue_render__$1d = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: ['ui-cascader-panel', _vm.border && 'is-bordered'],
    on: {
      "keydown": _vm.handleKeyDown
    }
  }, _vm._l(_vm.menus, function (menu, index) {
    return _c('ui-cascader-menu', {
      key: index,
      ref: "menu",
      refInFor: true,
      attrs: {
        "index": index,
        "nodes": menu
      }
    });
  }), 1);
};

var __vue_staticRenderFns__$1d = [];
/* style */

var __vue_inject_styles__$1l = undefined;
/* scoped */

var __vue_scope_id__$1l = undefined;
/* module identifier */

var __vue_module_identifier__$1l = undefined;
/* functional template */

var __vue_is_functional_template__$1l = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1l = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1d,
  staticRenderFns: __vue_staticRenderFns__$1d
}, __vue_inject_styles__$1l, __vue_script__$1l, __vue_scope_id__$1l, __vue_is_functional_template__$1l, __vue_module_identifier__$1l, false, undefined, undefined, undefined);

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_debounce = debounce;

var script$1k = {
  name: 'ui-cascader',
  components: {
    VPopover: VPopover,
    UiTextbox: __vue_component__$1r,
    UiTag: __vue_component__$1q,
    UiCascaderPanel: __vue_component__$1l
  },
  directives: {
    VClosePopover: VClosePopover
  },
  props: {
    hasSearch: {
      type: Boolean,
      default: false
    },
    value: {},
    label: String,
    floatingLabel: {
      type: Boolean,
      default: false
    },
    options: Array,
    props: Object,
    size: String,
    placeholder: {
      type: String,
      default: 'è¯·éæ©'
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: Function,
    separator: {
      type: String,
      default: ' / '
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    tagsLimit: {
      type: Number,
      default: 1
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: function _default() {
        return function () {};
      }
    },
    popoverClass: String,
    expandTrigger: String,
    multiple: {
      type: Boolean,
      default: false
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    emitPath: {
      type: Boolean,
      default: true // wether to emit an array of all levels value in which node is located

    },
    lazyload: Function,
    keys: {
      type: Object,
      default: function _default() {
        return {
          value: 'value',
          label: 'label',
          children: 'children',
          leaf: 'leaf',
          disabled: 'disabled'
        };
      }
    },
    hoverThreshold: {
      type: Number,
      default: 500
    },
    selectTop: {
      type: Boolean,
      default: false
    },
    historyTop: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    return {
      defaultProps: {
        children: 'children',
        label: 'label'
      },
      filterText: '',
      checkedValue: this.value || null,
      inputValue: null,
      presentText: null,
      presentTags: [],
      checkedNodes: [],
      filtering: false,
      suggestions: [],
      inputInitialHeight: 0,
      pressDeleteCount: 0,
      isFocus: false
    };
  },
  computed: {
    isDisabled: function isDisabled() {
      return this.disabled;
    },
    leafOnly: function leafOnly() {
      return !this.checkStrictly;
    },
    readonly: function readonly() {
      return !this.filterable || this.multiple;
    },
    hasClear: function hasClear() {
      if (!this.clearable || this.isDisabled || this.filtering) {
        return false;
      }

      return this.multiple ? !!this.checkedNodes.filter(function (node) {
        return !node.isDisabled;
      }).length : !!this.presentText;
    },
    panel: function panel() {
      return this.$refs.panel;
    }
  },
  watch: {
    filterText: function filterText(val) {
      this.$refs.tree.filter(val);
    },
    disabled: function disabled() {
      this.computePresentContent();
    },
    value: function value(val) {
      if (!isEqual(val, this.checkedValue)) {
        this.checkedValue = val;
        this.computePresentContent();
      }
    },
    checkedValue: function checkedValue(val) {
      var value = this.value;

      if (!isEqual(val, value) || isUndefined$1(value)) {
        this.computePresentContent(); // hide dropdown when single mode

        if (!this.multiple && !this.checkStrictly) {
          this.$refs['popover'].isOpen = false;
        }

        this.$emit('input', val);
        this.$emit('change', val);

        if (this.historyTop && this.historyTop != '' && this.is2DArray(val)) {
          var lastHistory = this.getLocalStorage(this.historyTop) || [];
          var checkVal = val.reduce(function (prev, cur) {
            prev.push(cur[0]);
            return prev;
          }, []);
          var newIdx = Array.from(new Set([].concat(toConsumableArray(checkVal), toConsumableArray(lastHistory))));
          this.setLocalStorage(this.historyTop, JSON.stringify(newIdx));
        }
      }
    },
    options: {
      handler: function handler() {
        this.$nextTick(this.computePresentContent);
      },
      deep: true
    },
    presentText: function presentText(val) {
      this.inputValue = val;
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.historyData();

    if (this.selectTop) {
      this.initData();
    }

    var input = this.$refs.input;

    if (input && input.$el) {
      this.inputInitialHeight = input.$el.offsetHeight || 40;
    }

    if (!isEmpty(this.value)) {
      this.computePresentContent();
    }

    this.filterHandler = lodash_debounce(function () {
      var inputValue = _this.inputValue;

      if (!inputValue) {
        _this.filtering = false;
        return;
      }

      var before = _this.beforeFilter(inputValue);

      if (before && before.then) {
        before.then(_this.getSuggestions);
      } else if (before !== false) {
        _this.getSuggestions();
      } else {
        _this.filtering = false;
      }
    }, this.debounce);
  },
  methods: {
    is2DArray: function is2DArray(variable) {
      if (!Array.isArray(variable)) {
        return false;
      }

      for (var i = 0; i < variable.length; i++) {
        if (!Array.isArray(variable[i])) {
          return false;
        }
      }

      return true;
    },
    deepMergeArrays: function deepMergeArrays(arr1, arr2) {
      var merged = toConsumableArray(arr1);

      arr2.forEach(function (item, index) {
        if (arr1[index] instanceof Object && item instanceof Object) {
          merged[index] = deepMergeObjects(arr1[index], item);
        } else {
          merged[index] = item;
        }
      });
      return merged;
    },
    initData: function initData() {
      var _this2 = this;

      var is2DArray = this.is2DArray(this.checkedValue);
      var checkValue;

      if (!is2DArray) {
        checkValue = [this.checkedValue[0]];
      } else {
        checkValue = this.checkedValue.reduce(function (prev, cur) {
          var isHas = prev.includes(cur[0]);

          if (!isHas) {
            prev.push(cur[0]);
          }

          return prev;
        }, []);
      }

      if (checkValue.length > 0) {
        var getIdxByValue = checkValue.reduce(function (prev, cur) {
          var curIdx = _this2.options.findIndex(function (item) {
            return item.value == cur;
          });

          prev.push(curIdx);
          return prev;
        }, []);
        var newArray = getIdxByValue.map(function (index) {
          return _this2.options[index];
        });
        var filterArr = this.options.filter(function (item, i) {
          return !getIdxByValue.includes(i);
        });
        this.options = [].concat(toConsumableArray(newArray), toConsumableArray(filterArr));
      }
    },
    setLocalStorage: function setLocalStorage(key, data) {
      var keyStr = "".concat(key, "_local_kkknui");
      localStorage.setItem(keyStr, data);
    },
    getLocalStorage: function getLocalStorage(key) {
      var keyStr = "".concat(key, "_local_kkknui");
      return JSON.parse(localStorage.getItem(keyStr));
    },
    historyData: function historyData() {
      var _this3 = this;

      if (this.historyTop && this.historyTop != '') {
        var historys = this.getLocalStorage(this.historyTop);

        if (historys) {
          var getIdxByValue = historys.reduce(function (prev, cur) {
            var curIdx = _this3.options.findIndex(function (item) {
              return item.value == cur;
            });

            if (curIdx != -1) {
              prev.push(curIdx);
            }

            return prev;
          }, []);
          var newArray = getIdxByValue.map(function (index) {
            return _this3.options[index];
          });
          var filterArr = this.options.filter(function (item, i) {
            return !getIdxByValue.includes(i);
          });
          this.options = [].concat(toConsumableArray(newArray), toConsumableArray(filterArr));
        }
      }
    },
    checkChange: function checkChange() {
      this.computePresentContent();
    },
    filterNode: function filterNode(value, data) {
      if (!value) return true;
      return data.label.indexOf(value) !== -1;
    },
    onOpen: function onOpen() {
      this.initData();
      if (this.$refs.suggestions) this.$refs.suggestions.style.minWidth = this.$refs.input.$el.getBoundingClientRect().width + 'px';
    },
    onClose: function onClose() {
      this.filtering = false;
      this.inputValue = this.presentText;
    },
    handleFocus: function handleFocus(e) {
      this.isFocus = true;
      this.$emit('focus', e);
    },
    handleBlur: function handleBlur(e) {
      this.isFocus = false;
      this.$emit('blur', e);
    },
    handleInput: function handleInput(val, event) {
      var _this4 = this;

      if (val) {
        this.$nextTick(function () {
          _this4.$refs['popover'].isOpen = true;
        });
      }

      if (event && event.isComposing) return;

      if (val) {
        this.filterHandler();
      } else {
        this.filtering = false;
      }
    },
    handleClear: function handleClear() {
      this.presentText = '';
      this.panel.clearCheckedNodes();
    },
    handleExpandChange: function handleExpandChange(value) {
      this.$emit('expand-change', value);
    },
    focusFirstNode: function focusFirstNode() {
      var _this5 = this;

      this.$nextTick(function () {
        var filtering = _this5.filtering;
        var _this5$$refs = _this5.$refs,
            popover = _this5$$refs.popover,
            suggestionPanel = _this5$$refs.suggestionPanel;
        var firstNode = null;

        if (filtering && suggestionPanel) {
          firstNode = suggestionPanel.$el.querySelector('.ui-cascader__suggestion-item');
        } else {
          var firstMenu = popover.querySelector('.ui-cascader-menu');
          firstNode = firstMenu.querySelector('.ui-cascader-node[tabindex="-1"]');
        }

        if (firstNode) {
          firstNode.focus();
          !filtering && firstNode.click();
        }
      });
    },
    computePresentContent: function computePresentContent() {
      var _this6 = this;

      // nextTick is required, because checked nodes may not change right now
      this.$nextTick(function () {
        if (_this6.multiple) {
          _this6.computePresentTags();

          _this6.presentText = _this6.presentTags.length ? ' ' : null;
        } else {
          _this6.computePresentText();
        }
      });
    },
    computePresentText: function computePresentText() {
      var checkedValue = this.checkedValue;

      if (!isEmpty(checkedValue)) {
        var node = this.panel.getNodeByValue(checkedValue);

        if (node && (this.checkStrictly || node.isLeaf)) {
          this.presentText = node.getText(this.showAllLevels, this.separator);
          return;
        }
      }

      this.presentText = null;
    },
    computePresentTags: function computePresentTags() {
      var _this7 = this;

      var filterable = this.filterable,
          isDisabled = this.isDisabled,
          leafOnly = this.leafOnly,
          showAllLevels = this.showAllLevels,
          separator = this.separator,
          tagsLimit = this.tagsLimit;
      var checkedNodes = [];

      if (this.hasSearch) {
        checkedNodes = this.$refs.tree.getCheckedNodes(leafOnly);
      } else {
        checkedNodes = this.getCheckedNodes(leafOnly);
      }

      var tags = [];
      var cnLen = checkedNodes.length;

      if (cnLen) {
        var hasSearch = filterable && !isDisabled;
        var restCount = cnLen - tagsLimit;
        var width = hasSearch || restCount > 0 ? 100 / (tagsLimit + 1) : 100 / cnLen;

        var genTag = function genTag(node) {
          return {
            node: node,
            style: {
              maxWidth: "".concat(width, "%")
            },
            key: _this7.hasSearch ? node.value : node.uid,
            text: _this7.hasSearch ? node.label : node.getText(showAllLevels, separator),
            closable: !isDisabled && !node.isDisabled
          };
        };

        var first = checkedNodes.slice(0, tagsLimit);
        first.map(function (node) {
          return tags.push(genTag(node));
        });

        if (restCount > 0) {
          tags.push({
            key: -1,
            style: {
              maxWidth: "".concat(hasSearch ? width / 2 : width, "%")
            },
            text: "+ ".concat(restCount),
            closable: false
          });
        }
      }

      this.checkedNodes = checkedNodes;
      this.presentTags = tags;

      if (this.hasSearch) {
        this.checkedValue = checkedNodes.map(function (item) {
          return item.value;
        });
      }
    },
    getSuggestions: function getSuggestions() {
      var _this8 = this;

      var filterMethod = this.filterMethod;

      if (!isFunction$1(filterMethod)) {
        filterMethod = function filterMethod(node, keyword) {
          return node.text.includes(keyword);
        };
      }

      var suggestions = this.panel.getFlattedNodes(this.leafOnly).filter(function (node) {
        if (node.isDisabled) return false;
        node.text = node.getText(_this8.showAllLevels, _this8.separator) || '';
        return filterMethod(node, _this8.inputValue);
      });

      if (this.multiple) ; else {
        suggestions.forEach(function (node) {
          node.checked = isEqual(_this8.checkedValue, node.getValueByOption());
        });
      }

      this.filtering = true;
      this.suggestions = suggestions;
    },
    handleDelete: function handleDelete() {
      var inputValue = this.inputValue,
          pressDeleteCount = this.pressDeleteCount,
          presentTags = this.presentTags;
      var lastIndex = presentTags.length - 1;
      var lastTag = presentTags[lastIndex];
      this.pressDeleteCount = inputValue ? 0 : pressDeleteCount + 1;
      if (!lastTag) return;

      if (this.pressDeleteCount) {
        this.deleteTag(lastIndex);
      }
    },
    handleSuggestionClick: function handleSuggestionClick(index) {
      var multiple = this.multiple;
      var targetNode = this.suggestions[index];

      if (multiple) {
        var checked = targetNode.checked;
        targetNode.doCheck(!checked);
        this.panel.calculateMultiCheckedValue();
      } else {
        this.checkedValue = targetNode.getValueByOption();
      }
    },
    deleteTag: function deleteTag(index) {
      var checkedValue = this.checkedValue;
      var val = checkedValue[index];
      this.checkedValue = checkedValue.filter(function (n, i) {
        return i !== index;
      });
      this.$emit('remove-tag', val);
      this.hasSearch && this.$refs.tree.setCheckedKeys(this.checkedValue);
    },

    /**
     * public methods
     */
    getCheckedNodes: function getCheckedNodes(leafOnly) {
      return this.panel.getCheckedNodes(leafOnly);
    }
  }
};

var __vue_script__$1k = script$1k;
/* template */

var __vue_render__$1c = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', [_c('v-popover', {
    ref: "popover",
    class: {
      'ui-cascader': true,
      'is-disabled': _vm.isDisabled,
      'has-clear': _vm.hasClear
    },
    attrs: {
      "placement": "bottom-start",
      "boundaries-element": "body",
      "popoverClass": ['ui-cascader__popover', _vm.popoverClass],
      "disabled": _vm.isDisabled
    },
    on: {
      "show": _vm.onOpen,
      "hide": _vm.onClose
    }
  }, [_c('ui-textbox', {
    ref: "input",
    staticClass: "ui-cascader__content",
    attrs: {
      "label": _vm.label,
      "floatingLabel": _vm.floatingLabel,
      "placeholder": _vm.label,
      "readonly": _vm.readonly,
      "disabled": _vm.isDisabled
    },
    on: {
      "focus": _vm.handleFocus,
      "blur": _vm.handleBlur,
      "input": _vm.handleInput
    },
    model: {
      value: _vm.multiple ? _vm.presentText : _vm.inputValue,
      callback: function callback($$v) {
        _vm.multiple ? _vm.presentText : _vm.inputValue = $$v;
      },
      expression: "multiple ? presentText : inputValue"
    }
  }, [_c('template', {
    slot: "append"
  }, [_vm.hasClear ? _c('ui-icon', {
    staticClass: "ui-cascader__clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.handleClear($event);
      }
    }
  }) : _vm._e(), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-cascader__input-arrow"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M6.984 9.984h10.03L12 15z"
    }
  })])])], 1)], 2), _vm._v(" "), _vm.multiple ? _c('div', {
    staticClass: "ui-cascader__tags"
  }, [_vm._l(_vm.presentTags, function (tag, index) {
    return _c('div', {
      key: tag.key,
      staticClass: "ui-cascader__tag",
      style: tag.style,
      attrs: {
        "title": tag.text
      }
    }, [_c('ui-tag', {
      attrs: {
        "size": "small",
        "closable": tag.closable
      },
      on: {
        "close": function close($event) {
          return _vm.deleteTag(index);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(tag.text))])])], 1);
  }), _vm._v(" "), _vm.filterable && !_vm.isDisabled ? _c('div', {
    staticClass: "ui-cascader__search-input"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model.trim",
      value: _vm.inputValue,
      expression: "inputValue",
      modifiers: {
        "trim": true
      }
    }],
    attrs: {
      "type": "text",
      "placeholder": _vm.presentTags.length || _vm.isFocus ? '' : _vm.label
    },
    domProps: {
      "value": _vm.inputValue
    },
    on: {
      "input": [function ($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.inputValue = $event.target.value.trim();
      }, function (e) {
        return _vm.handleInput(_vm.inputValue, e);
      }],
      "focus": _vm.handleFocus,
      "blur": [_vm.handleBlur, function ($event) {
        return _vm.$forceUpdate();
      }],
      "keydown": function keydown($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "delete", [8, 46], $event.key, ["Backspace", "Delete", "Del"])) {
          return null;
        }

        return _vm.handleDelete($event);
      }
    }
  })]) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "popover",
    staticClass: "ui-cascader__dropdown",
    attrs: {
      "slot": "popover"
    },
    slot: "popover"
  }, [_c('ui-cascader-panel', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.filtering && !_vm.hasSearch,
      expression: "!filtering && !hasSearch"
    }],
    ref: "panel",
    attrs: {
      "options": _vm.options,
      "expandTrigger": _vm.expandTrigger,
      "multiple": _vm.multiple,
      "checkStrictly": _vm.checkStrictly,
      "emitPath": _vm.emitPath,
      "lazyload": _vm.lazyload,
      "keys": _vm.keys,
      "hoverThreshold": _vm.hoverThreshold,
      "border": false,
      "render-label": _vm.$scopedSlots.default
    },
    on: {
      "expand-change": _vm.handleExpandChange
    },
    model: {
      value: _vm.checkedValue,
      callback: function callback($$v) {
        _vm.checkedValue = $$v;
      },
      expression: "checkedValue"
    }
  }), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.hasSearch,
      expression: "hasSearch"
    }],
    staticClass: "ui-cascader__search",
    on: {
      "click": function click($event) {
        $event.stopPropagation();
      },
      "keydown": function keydown($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.stopPropagation();
      }
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.filterText,
      expression: "filterText"
    }],
    staticClass: "ui-select__search-input",
    attrs: {
      "type": "text",
      "autocomplete": "off",
      "placeholder": "æç´¢"
    },
    domProps: {
      "value": _vm.filterText
    },
    on: {
      "input": function input($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.filterText = $event.target.value;
      }
    }
  }), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-select__search-icon"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M9.516 14.016c2.484 0 4.5-2.016 4.5-4.5s-2.016-4.5-4.5-4.5-4.5 2.016-4.5 4.5 2.016 4.5 4.5 4.5zm6 0l4.97 4.97-1.5 1.5-4.97-4.97v-.797l-.28-.282c-1.126.984-2.626 1.547-4.22 1.547-3.61 0-6.516-2.86-6.516-6.47S5.906 3 9.516 3s6.47 2.906 6.47 6.516c0 1.594-.564 3.094-1.548 4.22l.28.28h.798z"
    }
  })])]), _vm._v(" "), _c('ui-tree', {
    ref: "tree",
    attrs: {
      "data": _vm.options,
      "show-checkbox": "",
      "node-key": "value",
      "default-expand-all": "",
      "props": _vm.defaultProps,
      "filter-node-method": _vm.filterNode,
      "check-on-click-node": ""
    },
    on: {
      "check-change": _vm.checkChange
    }
  })], 1), _vm._v(" "), _vm.filterable ? _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.filtering,
      expression: "filtering"
    }],
    ref: "suggestions",
    staticClass: "ui-cascader__suggestion-panel"
  }, [_c('ul', {
    staticClass: "ui-cascader__suggestion-list"
  }, [_vm.suggestions.length ? _vm._l(_vm.suggestions, function (item, index) {
    return _c('li', {
      key: item.uid,
      class: ['ui-cascader__suggestion-item', item.checked && 'is-checked'],
      attrs: {
        "tabindex": -1
      },
      on: {
        "click": function click($event) {
          return _vm.handleSuggestionClick(index);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(item.text))]), _vm._v(" "), item.checked ? _c('i', {
      staticClass: "ui-icon-check"
    }) : _vm._e()]);
  }) : _vm._t("empty", [_c('li', {
    staticClass: "ui-cascader__empty-text"
  }, [_vm._v("æ å¹éæ°æ®")])])], 2)]) : _vm._e()], 1)], 1)], 1);
};

var __vue_staticRenderFns__$1c = [];
/* style */

var __vue_inject_styles__$1k = undefined;
/* scoped */

var __vue_scope_id__$1k = undefined;
/* module identifier */

var __vue_module_identifier__$1k = undefined;
/* functional template */

var __vue_is_functional_template__$1k = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1k = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1c,
  staticRenderFns: __vue_staticRenderFns__$1c
}, __vue_inject_styles__$1k, __vue_script__$1k, __vue_scope_id__$1k, __vue_is_functional_template__$1k, __vue_module_identifier__$1k, false, undefined, undefined, undefined);

function isArray$1(arr) {
  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }

  return Array.isArray(arr);
}
function getKeyOfData(list, key, value) {
  if (!isArray$1(list)) throw new Error('getKeyOfData args list invalid!');
  var i = -1;
  var len = list.length;
  var homeItem = {};

  while (++i < len) {
    var item = list[i];

    if (item[key] === value) {
      homeItem = item;
      break;
    } else if (item.children && item.children.length) {
      var res = getKeyOfData(item.children, key, value);
      if (res[key]) return res;
    }
  }

  return homeItem;
} // éä¸­

function findCheck(list) {
  var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  list.forEach(function (ret) {
    if (ret.check) arr.push(ret);else if (ret.children && ret.children.length !== 0) {
      findCheck(ret.children, arr);
    }
  });
  return arr;
}

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var computeChild = function computeChild(list, Vue) {
  list.forEach(function (item) {
    if (item.children && item.children.length) {
      var child = item.children;
      if (child.every(function (ret) {
        return ret.check;
      })) Vue.$set(item, 'check', true);else Vue.$set(item, 'check', false);
      child && computeChild(child, Vue);
    }
  });
};

var script$1j = {
  name: 'ui-tt-cascade-item',
  props: {
    value: {
      type: [String, Number]
    },
    data: {
      type: Array
    },
    level: {
      type: Number
    },
    disabled: {
      type: Boolean
    },
    indeterminate: {
      type: Boolean
    }
  },
  computed: {
    allIndeterminate: function allIndeterminate() {
      return this.indeterminate && this.data.some(function (item) {
        return item.check;
      }) && !this.data.every(function (item) {
        return item.check;
      });
    },
    itemClasses: function itemClasses() {
      var _this = this;

      return function (item) {
        var cls = ['ui-cascade-node'];
        item.value === _this.value && cls.push('in-active-path');
        return cls;
      };
    },
    all: function all() {
      var len = this.data.filter(function (ret) {
        return ret.check;
      }).length;
      return this.data.length === len;
    }
  },
  methods: {
    selectAll: function selectAll() {
      if (this.disabled) return;
      this.$emit('on-select', {
        check: !this.all,
        level: this.level
      });
    },
    selectItem: function selectItem(item) {
      if (this.disabled) return;
      this.$emit('on-select', {
        check: !item.check,
        level: this.level,
        cat: item.value
      });
    },
    itemIndeterminate: function itemIndeterminate(child) {
      var hasChild = function hasChild(meta) {
        return meta.children.reduce(function (sum, item) {
          var foundChilds = [];
          if (item.check) sum.push(item);
          if (item.children) foundChilds = hasChild(item);
          return sum.concat(foundChilds);
        }, []);
      };

      var some = hasChild(child).length > 0;
      var every = child.children && child.children.every(function (ret) {
        return ret.check;
      });
      return some && !every;
    }
  },
  watch: {
    data: {
      handler: function handler(nVal, oVal) {
        computeChild(nVal, this);
      },
      deep: true
    }
  },
  mounted: function mounted() {
    computeChild(this.data, this);
  }
};

/* script */
var __vue_script__$1j = script$1j;
/* template */

var __vue_render__$1b = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', [_c('ul', {
    staticClass: "ui-cascade-menu__list"
  }, _vm._l(_vm.data, function (item, index) {
    return _c('li', {
      key: index
    }, [item.children && item.children.length ? _c('div', {
      class: _vm.itemClasses(item),
      on: {
        "click": function click($event) {
          return _vm.$emit('on-child', {
            item: item,
            level: _vm.level
          });
        }
      }
    }, [_c('ui-checkbox', {
      attrs: {
        "disabled": _vm.disabled || item.disabled,
        "indeterminate": _vm.itemIndeterminate(item)
      },
      model: {
        value: item.check,
        callback: function callback($$v) {
          _vm.$set(item, "check", $$v);
        },
        expression: "item.check"
      }
    }, [_c('span', {
      staticClass: "ui-cascade-node__label"
    }, [_vm._v(_vm._s(item.label))]), _vm._v(" "), _c('ui-icon', {
      staticClass: "ui-cascade-node__postfix",
      attrs: {
        "icon": "chevron_right"
      }
    }), _vm._v(" "), _c('span', {
      staticClass: "c-item-checkbox c-cataract",
      on: {
        "click": function click($event) {
          return _vm.selectItem(item);
        }
      }
    })], 1)], 1) : _c('div', {
      class: _vm.itemClasses(item),
      on: {
        "click": function click($event) {
          return _vm.$emit('on-child', {
            item: item,
            level: _vm.level
          });
        }
      }
    }, [_c('ui-checkbox', {
      attrs: {
        "label": item.label,
        "disabled": _vm.disabled || item.disabled
      },
      model: {
        value: item.check,
        callback: function callback($$v) {
          _vm.$set(item, "check", $$v);
        },
        expression: "item.check"
      }
    })], 1)]);
  }), 0)]);
};

var __vue_staticRenderFns__$1b = [];
/* style */

var __vue_inject_styles__$1j = undefined;
/* scoped */

var __vue_scope_id__$1j = "data-v-ba931b68";
/* module identifier */

var __vue_module_identifier__$1j = undefined;
/* functional template */

var __vue_is_functional_template__$1j = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1j = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1b,
  staticRenderFns: __vue_staticRenderFns__$1b
}, __vue_inject_styles__$1j, __vue_script__$1j, __vue_scope_id__$1j, __vue_is_functional_template__$1j, __vue_module_identifier__$1j, false, undefined, undefined, undefined);

//
var script$1i = {
  name: 'ui-tt-cascade',
  components: {
    UiTtCascadeItem: __vue_component__$1j
  },
  props: {
    value: {
      type: Array
    },
    data: {
      type: Array
    },
    transfer: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean
    },
    indeterminate: {
      type: Boolean
    }
  },
  data: function data() {
    return {
      resource: []
    };
  },
  created: function created() {
    if (isArray$1(this.value) && this.value.length) {
      this.decompile(this.value);
    }

    this.updateResource();
  },
  computed: {
    result: function result() {
      var checkItems = findCheck(this.data);
      this.$emit('input', checkItems.map(function (ret) {
        return ret.value;
      }));
      this.$emit('result', checkItems.map(function (ret) {
        return ret.label;
      }));
      return checkItems;
    },
    resultLen: function resultLen() {
      return Boolean(this.result.length);
    }
  },
  watch: {
    data: {
      handler: function handler() {
        if (isArray$1(this.value) && this.value.length) {
          this.decompile(this.value);
        }

        this.updateResource();
      }
    }
  },
  methods: {
    updateResource: function updateResource() {
      this.resource = [];
      this.resource.push({
        data: this.data,
        current: 0,
        level: 1
      });
    },
    pushChild: function pushChild(params) {
      var item = params.item,
          level = params.level;
      var len = this.resource.length;

      if (level <= len - 1) {
        this.resource.splice(level, len - level);
      }

      if (level == len - 1 && !item.children) {
        this.resource.splice(level, 1);
      }

      if (item.children) {
        this.resource.push({
          data: item.children,
          current: 0,
          level: level + 1
        });
      }

      this.resource[level - 1].current = item.value;
    },
    // é»è®¤éä¸­
    decompile: function decompile(Ids) {
      var _this = this;

      var deepSelect = function deepSelect(item) {
        item.forEach(function (ret) {
          if (ret && ret.children && ret.children.length) deepSelect(ret.children);
          !ret.disabled && _this.$set(ret, 'check', true);
        });
      };

      Ids.forEach(function (ret) {
        var item = getKeyOfData(_this.data, 'value', ret);
        deepSelect([item]);
      });
    },
    selectAll: function selectAll(_ref) {
      var level = _ref.level,
          check = _ref.check,
          cat = _ref.cat;
      var index = level - 2;
      var current = index > -1 ? this.resource[index].current : 0;
      cat && (current = cat);
      this.selectFinalAll({
        check: check,
        current: current,
        list: this.data
      });
    },
    // å¨é
    selectFinalAll: function selectFinalAll(_ref2) {
      var _this2 = this;

      var list = _ref2.list,
          _ref2$check = _ref2.check,
          check = _ref2$check === void 0 ? true : _ref2$check,
          _ref2$current = _ref2.current,
          current = _ref2$current === void 0 ? 0 : _ref2$current;
      var data; // æ ééå½

      var setAllChecked = function setAllChecked(all, check) {
        all.forEach(function (ret) {
          if (ret.children && ret.children.length) setAllChecked(ret.children, check);

          _this2.$set(ret, 'check', check);
        });
      };

      if (current) {
        var item = getKeyOfData(list, 'value', current);
        data = item.children;
      } else data = list;

      setAllChecked(data, check);
    }
  }
};

/* script */
var __vue_script__$1i = script$1i;
/* template */

var __vue_render__$1a = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-tt-cascade"
  }, [_c('div', {
    staticClass: "ui-tt-cascade-panel"
  }, _vm._l(_vm.resource, function (box, idx) {
    return _c('div', {
      key: idx,
      staticClass: "ui-cascade-menu"
    }, [_c('ui-tt-cascade-item', {
      attrs: {
        "data": box.data,
        "level": box.level,
        "disabled": _vm.disabled,
        "indeterminate": _vm.indeterminate
      },
      on: {
        "on-child": _vm.pushChild,
        "on-select": _vm.selectAll
      },
      model: {
        value: box.current,
        callback: function callback($$v) {
          _vm.$set(box, "current", $$v);
        },
        expression: "box.current"
      }
    })], 1);
  }), 0), _vm._v(" "), _c('span', {
    staticStyle: {
      "display": "none"
    }
  }, [_vm._v(_vm._s(_vm.resultLen))])]);
};

var __vue_staticRenderFns__$1a = [];
/* style */

var __vue_inject_styles__$1i = undefined;
/* scoped */

var __vue_scope_id__$1i = "data-v-3ee5b8f6";
/* module identifier */

var __vue_module_identifier__$1i = undefined;
/* functional template */

var __vue_is_functional_template__$1i = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1i = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1a,
  staticRenderFns: __vue_staticRenderFns__$1a
}, __vue_inject_styles__$1i, __vue_script__$1i, __vue_scope_id__$1i, __vue_is_functional_template__$1i, __vue_module_identifier__$1i, false, undefined, undefined, undefined);

var script$1h = {
  name: 'ui-checkbox-group',
  props: {
    name: String,
    type: {
      type: String,
      default: 'default' // default or button

    },
    options: {
      type: Array,
      required: true
    },
    value: {
      type: Array,
      required: true
    },
    keys: {
      type: Object,
      default: function _default() {
        return {
          id: 'id',
          name: 'name',
          class: 'class',
          label: 'label',
          value: 'value',
          disabled: 'disabled'
        };
      }
    },
    label: String,
    color: {
      type: String,
      default: 'primary' // 'primary' or 'accent'

    },
    boxPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    vertical: {
      type: Boolean,
      default: false
    },
    help: String,
    error: String,
    invalid: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      ignoreChange: false,
      checkboxValues: [],
      initialValue: JSON.parse(JSON.stringify(this.value))
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-checkbox-group--color-".concat(this.color), "ui-checkbox-group--box-position-".concat(this.boxPosition), defineProperty$2({}, "ui-checkbox-group--type-".concat(this.type), this.type), {
        'is-vertical': this.vertical
      }, {
        'is-active': this.isActive
      }, {
        'is-invalid': this.invalid
      }, {
        'is-disabled': this.disabled
      }];
    },
    hasFeedback: function hasFeedback() {
      return this.showError || this.showHelp;
    },
    showError: function showError() {
      return this.invalid && (Boolean(this.error) || Boolean(this.$slots.error));
    },
    showHelp: function showHelp() {
      return Boolean(this.help) || Boolean(this.$slots.help);
    }
  },
  watch: {
    value: function value() {
      var _this = this;

      this.options.forEach(function (option, index) {
        var optionValue = option[_this.keys.value] || option;

        _this.$set(_this.checkboxValues, index, looseIndexOf(_this.value, optionValue) > -1);
      });
    },
    options: function options() {
      var _this2 = this;

      this.options.forEach(function (option, index) {
        var optionValue = option[_this2.keys.value] || option;

        _this2.$set(_this2.checkboxValues, index, looseIndexOf(_this2.value, optionValue) > -1);
      });
    }
  },
  methods: {
    reset: function reset() {
      var _this3 = this;

      this.ignoreChange = true;
      this.options.forEach(function (option, index) {
        _this3.checkboxValues[index] = _this3.isOptionCheckedByDefault(option);
      });
      this.ignoreChange = false;
      this.$emit('input', this.initialValue.length > 0 ? [].concat(this.initialValue) : []);
    },
    isOptionCheckedByDefault: function isOptionCheckedByDefault(option) {
      return looseIndexOf(this.initialValue, option[this.keys.value] || option) > -1;
    },
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    },
    onChange: function onChange(args, option) {
      if (this.ignoreChange) {
        return;
      }

      var checked = args[0];
      var e = args[1];
      var value = [];
      var optionValue = option[this.keys.value] || option;
      var i = looseIndexOf(this.value, optionValue);

      if (checked && i < 0) {
        value = [].concat(this.value, optionValue);
      }

      if (!checked && i > -1) {
        value = this.value.slice(0, i).concat(this.value.slice(i + 1));
      }

      this.$emit('input', value);
      this.$emit('change', value, e, option);
    }
  },
  components: {
    UiCheckbox: __vue_component__$1p
  }
};

var __vue_script__$1h = script$1h;
/* template */

var __vue_render__$19 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-checkbox-group",
    class: _vm.classes
  }, [_vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-checkbox-group__label-text"
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-checkbox-group__checkboxes"
  }, _vm._l(_vm.options, function (option, index) {
    return _c('ui-checkbox', {
      key: option[_vm.keys.id],
      staticClass: "ui-checkbox-group__checkbox",
      class: option[_vm.keys.class],
      attrs: {
        "box-position": _vm.boxPosition,
        "checked": _vm.isOptionCheckedByDefault(option),
        "color": _vm.color,
        "disabled": _vm.disabled || option[_vm.keys.disabled],
        "id": option[_vm.keys.id],
        "name": _vm.name || option[_vm.keys.name]
      },
      on: {
        "blur": _vm.onBlur,
        "change": function change($event) {
          return _vm.onChange(arguments, option);
        },
        "focus": _vm.onFocus
      },
      model: {
        value: _vm.checkboxValues[index],
        callback: function callback($$v) {
          _vm.$set(_vm.checkboxValues, index, $$v);
        },
        expression: "checkboxValues[index]"
      }
    }, [_vm._t("option", [_vm._v("\n        " + _vm._s(option[_vm.keys.label] || option) + "\n      ")], {
      "disabled": _vm.disabled || option[_vm.keys.disabled],
      "checked": _vm.isOptionCheckedByDefault(option),
      "value": _vm.checkboxValues[index],
      "option": option
    })], 2);
  }), 1), _vm._v(" "), _vm.hasFeedback ? _c('div', {
    staticClass: "ui-checkbox-group__feedback"
  }, [_vm.showError ? _c('div', {
    staticClass: "ui-checkbox-group__feedback-text"
  }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _c('div', {
    staticClass: "ui-checkbox-group__feedback-text"
  }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()]);
};

var __vue_staticRenderFns__$19 = [];
/* style */

var __vue_inject_styles__$1h = undefined;
/* scoped */

var __vue_scope_id__$1h = undefined;
/* module identifier */

var __vue_module_identifier__$1h = undefined;
/* functional template */

var __vue_is_functional_template__$1h = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1h = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$19,
  staticRenderFns: __vue_staticRenderFns__$19
}, __vue_inject_styles__$1h, __vue_script__$1h, __vue_scope_id__$1h, __vue_is_functional_template__$1h, __vue_module_identifier__$1h, false, undefined, undefined, undefined);

/**
 * Fast UUID generator, RFC4122 version 4 compliant.
 * @author Jeff Ward (jcward.com).
 * @license MIT license
 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
 */
var lut = [];

for (var i$2 = 0; i$2 < 256; i$2++) {
  lut[i$2] = (i$2 < 16 ? '0' : '') + i$2.toString(16);
}

var generate = function generate() {
  var d0 = Math.random() * 0xffffffff | 0;
  var d1 = Math.random() * 0xffffffff | 0;
  var d2 = Math.random() * 0xffffffff | 0;
  var d3 = Math.random() * 0xffffffff | 0;
  /* eslint-disable */

  return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
  /* eslint-enable */
};

var _short = function _short(prefix) {
  prefix = prefix || '';
  var uuid = generate();
  return prefix + uuid.split('-')[0];
};

var UUID = {
  generate: generate,
  short: _short
};

//
var script$1g = {
  name: 'ui-collapsible',
  props: {
    open: {
      type: Boolean,
      default: false
    },
    title: String,
    position: {
      type: String,
      default: 'header'
    },
    removeIcon: {
      type: Boolean,
      default: false
    },
    disableRipple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isOpen: this.open,
      id: UUID.short('ui-collapsible-')
    };
  },
  computed: {
    classes: function classes() {
      return [{
        'is-open': this.isOpen
      }, {
        'is-disabled': this.disabled
      }];
    }
  },
  watch: {
    open: function open() {
      if (this.isOpen !== this.open) {
        this.isOpen = this.open;
      }
    }
  },
  mounted: function mounted() {
    // Remove the max-height to allow the element to grow if it's open initially
    if (this.isOpen) {
      this.$refs.bodyWrapper.style.maxHeight = 'none';
    }
  },
  methods: {
    toggleCollapsible: function toggleCollapsible() {
      if (this.disabled) {
        return;
      }

      this.isOpen = !this.isOpen;
    },
    onEnter: function onEnter(el) {
      this.$emit('open');
      el.style.maxHeight = el.scrollHeight + 'px';
    },
    afterEnter: function afterEnter(el) {
      // Remove the max-height to allow the element to grow
      el.style.maxHeight = 'none';
    },
    beforeLeave: function beforeLeave(el) {
      // Restore max-height for the leave transition
      el.style.maxHeight = el.scrollHeight + 'px'; // Force repaint

      el.offsetHeight; // eslint-disable-line no-unused-expressions
    },
    onLeave: function onLeave(el) {
      el.style.maxHeight = 0;
      this.$emit('close');
    }
  },
  components: {
    UiIcon: __vue_component__$1B,
    UiRippleInk: __vue_component__$1A
  }
};

/* script */
var __vue_script__$1g = script$1g;
/* template */

var __vue_render__$18 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-collapsible",
    class: _vm.classes
  }, [_vm.position == 'header' ? _c('div', {
    staticClass: "ui-collapsible__header",
    attrs: {
      "aria-controls": _vm.id,
      "aria-expanded": _vm.isOpen ? 'true' : 'false',
      "tabindex": _vm.disabled ? null : 0
    },
    on: {
      "click": _vm.toggleCollapsible,
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        $event.preventDefault();
        return _vm.toggleCollapsible($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.toggleCollapsible($event);
      }]
    }
  }, [_c('div', {
    staticClass: "ui-collapsible__header-content"
  }, [_vm._t("header", [_vm._v(_vm._s(_vm.title))])], 2), _vm._v(" "), !_vm.removeIcon ? _c('ui-icon', {
    staticClass: "ui-collapsible__header-icon"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M7.406 7.828L12 12.422l4.594-4.594L18 9.234l-6 6-6-6z"
    }
  })])]) : _vm._e(), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _c('ui-ripple-ink') : _vm._e()], 1) : _vm._e(), _vm._v(" "), _c('transition', {
    on: {
      "enter": _vm.onEnter,
      "after-enter": _vm.afterEnter,
      "before-leave": _vm.beforeLeave,
      "leave": _vm.onLeave
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.isOpen,
      expression: "isOpen"
    }],
    ref: "bodyWrapper",
    staticClass: "ui-collapsible__body-wrapper",
    attrs: {
      "aria-hidden": _vm.isOpen ? null : 'true',
      "id": _vm.id
    }
  }, [_c('div', {
    staticClass: "ui-collapsible__body"
  }, [_vm._t("default")], 2)])]), _vm._v(" "), _vm.position == 'footer' ? _c('div', {
    staticClass: "ui-collapsible__footer",
    attrs: {
      "aria-controls": _vm.id,
      "aria-expanded": _vm.isOpen ? 'true' : 'false',
      "tabindex": _vm.disabled ? null : 0
    },
    on: {
      "click": _vm.toggleCollapsible,
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        $event.preventDefault();
        return _vm.toggleCollapsible($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.toggleCollapsible($event);
      }]
    }
  }, [_vm._t("footer", [_c('ui-icon', {
    attrs: {
      "icon": _vm.isOpen ? 'keyboard_arrow_up' : 'keyboard_arrow_down'
    }
  })], {
    "open": _vm.isOpen
  })], 2) : _vm._e()], 1);
};

var __vue_staticRenderFns__$18 = [];
/* style */

var __vue_inject_styles__$1g = undefined;
/* scoped */

var __vue_scope_id__$1g = undefined;
/* module identifier */

var __vue_module_identifier__$1g = undefined;
/* functional template */

var __vue_is_functional_template__$1g = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1g = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$18,
  staticRenderFns: __vue_staticRenderFns__$18
}, __vue_inject_styles__$1g, __vue_script__$1g, __vue_scope_id__$1g, __vue_is_functional_template__$1g, __vue_module_identifier__$1g, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$1f = {
  name: 'ui-focus-container',
  props: {
    containFocus: {
      type: Boolean,
      default: true
    },
    focusRedirector: Function,
    disabled: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'div'
    },
    lazy: {
      type: Boolean,
      default: false // When true, the focus redirectors are not rendered until containFocus is true

    }
  },
  computed: {
    renderRedirector: function renderRedirector() {
      if (this.disabled) {
        return false;
      }

      return this.lazy ? this.containFocus : true;
    }
  },
  methods: {
    focus: function focus() {
      this.$refs.content.focus();
    },
    redirectFocus: function redirectFocus(e, options) {
      if (!this.containFocus) {
        this.$emit('focus-overflow', e, options);
        return;
      }

      e.stopPropagation();

      if (this.focusRedirector) {
        this.focusRedirector(e, options);
        return;
      }

      if (options.isTabbingForward) {
        this.$refs.content.focus();
      } else {
        this.$refs.lastFocusable.focus();
      }
    }
  }
};

/* script */
var __vue_script__$1f = script$1f;
/* template */

var __vue_render__$17 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c(_vm.tag, {
    tag: "component",
    staticClass: "ui-focus-container"
  }, [_vm.renderRedirector ? _c('span', {
    staticClass: "ui-focus-container__focus-redirector",
    attrs: {
      "tabindex": "0"
    },
    on: {
      "focus": function focus($event) {
        return _vm.redirectFocus($event, {
          isTabbingForward: false
        });
      }
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "content",
    staticClass: "ui-focus-container__content",
    attrs: {
      "tabindex": "-1"
    }
  }, [_vm._t("default")], 2), _vm._v(" "), !_vm.disabled && _vm.containFocus ? _c('span', {
    ref: "lastFocusable",
    staticClass: "ui-focus-container__last-focusable",
    attrs: {
      "tabindex": "-1"
    }
  }) : _vm._e(), _vm._v(" "), _vm.renderRedirector ? _c('span', {
    staticClass: "ui-focus-container__focus-redirector",
    attrs: {
      "tabindex": "0"
    },
    on: {
      "focus": function focus($event) {
        return _vm.redirectFocus($event, {
          isTabbingForward: true
        });
      }
    }
  }) : _vm._e()]);
};

var __vue_staticRenderFns__$17 = [];
/* style */

var __vue_inject_styles__$1f = undefined;
/* scoped */

var __vue_scope_id__$1f = undefined;
/* module identifier */

var __vue_module_identifier__$1f = undefined;
/* functional template */

var __vue_is_functional_template__$1f = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1f = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$17,
  staticRenderFns: __vue_staticRenderFns__$17
}, __vue_inject_styles__$1f, __vue_script__$1f, __vue_scope_id__$1f, __vue_is_functional_template__$1f, __vue_module_identifier__$1f, false, undefined, undefined, undefined);

var EventHub = new Vue();

var script$1e = {
  name: 'ui-modal',
  props: {
    title: {
      type: String,
      default: 'æ é¢'
    },
    alignTop: {
      type: Boolean,
      default: false
    },
    alignTopMargin: {
      type: Number,
      default: 60
    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large', 'fullscreen', or 'auto'

    },
    role: {
      type: String,
      default: 'dialog' // 'dialog' or 'alertdialog'

    },
    transition: {
      type: String,
      default: 'scale-down' // 'scale-up', 'scale-down', or 'fade'

    },
    removeHeader: {
      type: Boolean,
      default: false
    },
    removeCloseButton: {
      type: Boolean,
      default: false
    },
    preventShift: {
      type: Boolean,
      default: false
    },
    dismissible: {
      type: Boolean,
      default: true
    },
    dismissOn: {
      type: String,
      default: 'backdrop esc close-button'
    },
    isFullMask: {
      type: Boolean,
      default: true
    },
    inline: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isOpen: false,
      lastFocusedElement: null
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-modal--size-".concat(this.size), {
        'has-footer': this.hasFooter
      }, {
        'is-open': this.isOpen
      }, {
        'is-aligned-top': this.alignTop
      }, {
        'is-full-mask': this.isFullMask
      }];
    },
    alignTopStyle: function alignTopStyle() {
      if (this.alignTop) {
        return {
          'padding-top': this.alignTopMargin + 'px'
        };
      }

      return null;
    },
    toggleTransition: function toggleTransition() {
      return "ui-modal--transition-".concat(this.transition);
    },
    hasFooter: function hasFooter() {
      return Boolean(this.$slots.footer);
    },
    dismissOnBackdrop: function dismissOnBackdrop() {
      return this.dismissOn.indexOf('backdrop') > -1;
    },
    dismissOnCloseButton: function dismissOnCloseButton() {
      return this.dismissOn.indexOf('close-button') > -1;
    },
    dismissOnEsc: function dismissOnEsc() {
      return this.dismissOn.indexOf('esc') > -1;
    }
  },
  watch: {
    isOpen: function isOpen() {
      var _this = this;

      this.$nextTick(function () {
        _this[_this.isOpen ? 'onOpen' : 'onClose']();
      });

      if (this.isFullMask) {
        // äºä»¶å¹¿æ­
        EventHub.$emit('nui:fullMask', this.isOpen);
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.isOpen) {
      this.returnFocus();
    }
  },
  methods: {
    open: function open() {
      this.isOpen = true;
    },
    close: function close() {
      if (!this.dismissible) {
        return;
      }

      this.isOpen = false;
    },
    redirectFocus: function redirectFocus() {
      this.$refs.focusContainer.focus();
    },
    returnFocus: function returnFocus() {
      if (this.lastFocusedElement) {
        this.lastFocusedElement.focus();
      }
    },
    onBackdropClick: function onBackdropClick() {
      if (this.dismissOnBackdrop) {
        this.close();
      } else {
        this.redirectFocus();
      }
    },
    onEsc: function onEsc() {
      if (this.dismissOnEsc) {
        this.close();
      }
    },
    onOpen: function onOpen() {
      this.lastFocusedElement = document.activeElement;
      this.$refs.focusContainer.focus();
      classlist.add(document.body, 'ui-modal--is-open');
      this.incrementOpenModalCount();
      this.$emit('open');
    },
    onClose: function onClose() {
      this.returnFocus();
      this.$emit('close');
    },
    onEnter: function onEnter() {
      this.$emit('reveal');
    },
    onLeave: function onLeave() {
      this.$emit('hide');
      var newCount = this.decrementOpenModalCount();

      if (newCount === 0) {
        classlist.remove(document.body, 'ui-modal--is-open');
      }
    },
    getOpenModalCount: function getOpenModalCount() {
      var count = document.body.getAttribute('data-ui-open-modals');
      return count === undefined ? 0 : Number(count);
    },
    setOpenModalCount: function setOpenModalCount(count) {
      var normalizedCount = Math.max(0, count);

      if (normalizedCount === 0) {
        document.body.removeAttribute('data-ui-open-modals');
      } else {
        document.body.setAttribute('data-ui-open-modals', normalizedCount);
      }

      return normalizedCount;
    },
    incrementOpenModalCount: function incrementOpenModalCount() {
      return this.setOpenModalCount(this.getOpenModalCount() + 1);
    },
    decrementOpenModalCount: function decrementOpenModalCount() {
      return this.setOpenModalCount(this.getOpenModalCount() - 1);
    }
  },
  components: {
    UiCloseButton: __vue_component__$1z,
    UiFocusContainer: __vue_component__$1f
  }
};

/* script */
var __vue_script__$1e = script$1e;
/* template */

var __vue_render__$16 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": _vm.toggleTransition
    },
    on: {
      "after-enter": _vm.onEnter,
      "after-leave": _vm.onLeave
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.isOpen,
      expression: "isOpen"
    }],
    staticClass: "ui-modal ui-modal__mask",
    class: _vm.classes,
    attrs: {
      "role": _vm.role
    },
    on: {
      "click": function click($event) {
        if ($event.target !== $event.currentTarget) {
          return null;
        }

        return _vm.onBackdropClick($event);
      }
    }
  }, [_c('div', {
    staticClass: "ui-modal__wrapper",
    class: {
      'has-dummy-scrollbar': _vm.preventShift
    },
    style: _vm.alignTopStyle,
    on: {
      "click": function click($event) {
        if ($event.target !== $event.currentTarget) {
          return null;
        }

        return _vm.onBackdropClick($event);
      }
    }
  }, [_c('ui-focus-container', {
    ref: "focusContainer",
    staticClass: "ui-modal__container",
    attrs: {
      "tabindex": "-1"
    },
    nativeOn: {
      "keydown": function keydown($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
          return null;
        }

        $event.stopPropagation();
        return _vm.onEsc($event);
      }
    }
  }, [!_vm.removeHeader ? _c('div', {
    staticClass: "ui-modal__header"
  }, [_vm._t("header", [_c('h1', {
    staticClass: "ui-modal__header-text"
  }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(" "), _c('div', {
    staticClass: "ui-modal__close-button"
  }, [_vm.dismissOnCloseButton && !_vm.removeCloseButton && _vm.dismissible ? _c('ui-close-button', {
    on: {
      "click": _vm.close
    }
  }) : _vm._e()], 1)], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-modal__body",
    class: {
      'ui-modal__body--inline': _vm.inline
    }
  }, [_vm._t("default")], 2), _vm._v(" "), _vm.hasFooter ? _c('div', {
    staticClass: "ui-modal__footer"
  }, [_vm._t("footer")], 2) : _vm._e()])], 1)])]);
};

var __vue_staticRenderFns__$16 = [];
/* style */

var __vue_inject_styles__$1e = undefined;
/* scoped */

var __vue_scope_id__$1e = undefined;
/* module identifier */

var __vue_module_identifier__$1e = undefined;
/* functional template */

var __vue_is_functional_template__$1e = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1e = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$16,
  staticRenderFns: __vue_staticRenderFns__$16
}, __vue_inject_styles__$1e, __vue_script__$1e, __vue_scope_id__$1e, __vue_is_functional_template__$1e, __vue_module_identifier__$1e, false, undefined, undefined, undefined);

//
var script$1d = {
  name: 'ui-confirm',
  props: {
    title: {
      type: String,
      default: 'UiConfirm'
    },
    type: {
      type: String,
      default: 'primary' // any of the color prop values of UiButton

    },
    size: String,
    confirmButtonText: {
      type: String,
      default: 'OK'
    },
    confirmButtonIcon: String,
    denyButtonText: {
      type: String,
      default: 'Cancel'
    },
    denyButtonIcon: String,
    autofocus: {
      type: String,
      default: 'deny-button' // 'confirm-button', 'deny-button' or 'none'

    },
    closeOnConfirm: {
      type: Boolean,
      default: true
    },
    dismissOn: String,
    transition: String,
    loading: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    confirmButtonColor: function confirmButtonColor() {
      var typeToColor = {
        default: 'default',
        primary: 'primary',
        accent: 'accent',
        success: 'green',
        warning: 'orange',
        danger: 'red'
      };
      return typeToColor[this.type];
    }
  },
  methods: {
    open: function open() {
      this.$refs.modal.open();
    },
    close: function close() {
      this.$refs.modal.close();
    },
    confirm: function confirm() {
      this.$emit('confirm');

      if (this.closeOnConfirm) {
        this.$refs.modal.close();
      }
    },
    deny: function deny() {
      this.$refs.modal.close();
      this.$emit('deny');
    },
    onModalOpen: function onModalOpen() {
      var button;

      if (this.autofocus === 'confirm-button') {
        button = this.$refs.confirmButton.$el;
      } else if (this.autofocus === 'deny-button') {
        button = this.$refs.denyButton.$el;
      }

      if (button) {
        classlist.add(button, 'has-focus-ring');
        button.addEventListener('blur', this.removeAutoFocus);
        button.focus();
      }

      this.$emit('open');
    },
    onModalReveal: function onModalReveal() {
      this.$emit('reveal');
    },
    onModalClose: function onModalClose() {
      this.$emit('close');
    },
    onModalHide: function onModalHide() {
      this.$emit('hide');
    },
    removeAutoFocus: function removeAutoFocus() {
      var button;

      if (this.autofocus === 'confirm-button') {
        button = this.$refs.confirmButton.$el;
      } else if (this.autofocus === 'deny-button') {
        button = this.$refs.denyButton.$el;
      }

      if (button) {
        classlist.remove(button, 'has-focus-ring'); // This listener should run only once

        button.removeEventListener('blur', this.removeAutoFocus);
      }
    }
  },
  components: {
    UiButton: __vue_component__$1v,
    UiModal: __vue_component__$1e
  }
};

/* script */
var __vue_script__$1d = script$1d;
/* template */

var __vue_render__$15 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('ui-modal', {
    ref: "modal",
    staticClass: "ui-confirm",
    attrs: {
      "role": "alertdialog",
      "dismiss-on": _vm.dismissOn,
      "dismissible": !_vm.loading,
      "title": _vm.title,
      "transition": _vm.transition,
      "size": _vm.size
    },
    on: {
      "close": _vm.onModalClose,
      "hide": _vm.onModalHide,
      "open": _vm.onModalOpen,
      "reveal": _vm.onModalReveal
    }
  }, [_c('div', {
    staticClass: "ui-confirm__message"
  }, [_vm._t("default")], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-confirm__footer",
    attrs: {
      "slot": "footer"
    },
    slot: "footer"
  }, [_c('ui-button', {
    ref: "confirmButton",
    attrs: {
      "color": _vm.confirmButtonColor,
      "icon": _vm.confirmButtonIcon,
      "loading": _vm.loading
    },
    on: {
      "click": _vm.confirm
    }
  }, [_vm._v(_vm._s(_vm.confirmButtonText))]), _vm._v(" "), _c('ui-button', {
    ref: "denyButton",
    attrs: {
      "disabled": _vm.loading,
      "icon": _vm.denyButtonIcon
    },
    on: {
      "click": _vm.deny
    }
  }, [_vm._v(_vm._s(_vm.denyButtonText))])], 1)]);
};

var __vue_staticRenderFns__$15 = [];
/* style */

var __vue_inject_styles__$1d = undefined;
/* scoped */

var __vue_scope_id__$1d = undefined;
/* module identifier */

var __vue_module_identifier__$1d = undefined;
/* functional template */

var __vue_is_functional_template__$1d = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1d = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$15,
  staticRenderFns: __vue_staticRenderFns__$15
}, __vue_inject_styles__$1d, __vue_script__$1d, __vue_scope_id__$1d, __vue_is_functional_template__$1d, __vue_module_identifier__$1d, false, undefined, undefined, undefined);

//
//
//
//
//
//
var script$1c = {
  name: 'ui-container',
  componentName: 'UiContainer',
  props: {
    direction: String
  },
  computed: {
    isVertical: function isVertical() {
      if (this.direction === 'vertical') {
        return true;
      } else if (this.direction === 'horizontal') {
        return false;
      }

      return this.$slots && this.$slots.default ? this.$slots.default.some(function (vnode) {
        var tag = vnode.componentOptions && vnode.componentOptions.tag;
        return tag === 'ui-header' || tag === 'ui-footer';
      }) : false;
    }
  }
};

/* script */
var __vue_script__$1c = script$1c;
/* template */

var __vue_render__$14 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('section', {
    staticClass: "ui-container",
    class: {
      'is-vertical': _vm.isVertical
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$14 = [];
/* style */

var __vue_inject_styles__$1c = undefined;
/* scoped */

var __vue_scope_id__$1c = undefined;
/* module identifier */

var __vue_module_identifier__$1c = undefined;
/* functional template */

var __vue_is_functional_template__$1c = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1c = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$14,
  staticRenderFns: __vue_staticRenderFns__$14
}, __vue_inject_styles__$1c, __vue_script__$1c, __vue_scope_id__$1c, __vue_is_functional_template__$1c, __vue_module_identifier__$1c, false, undefined, undefined, undefined);

var _strictMethod = function (method, arg) {
  return !!method && _fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

var $sort = [].sort;
var test = [1, 2, 3];

_export(_export.P + _export.F * (_fails(function () {
  // IE8-
  test.sort(undefined);
}) || !_fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !_strictMethod($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(_toObject(this))
      : $sort.call(_toObject(this), _aFunction(comparefn));
  }
});

var script$1b = {
  name: 'ui-date-time-picker-calendar',
  props: {
    date: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    size: {
      type: String,
      default: 'normal'
    },
    range: Boolean,
    value: {
      type: [Date, Array],
      default: function _default() {
        return [];
      }
    },
    leftVisible: Boolean,
    rightVisible: Boolean,
    disabled: Boolean,
    selectType: {
      type: String,
      default: 'date'
    },
    disabledDate: Function,
    multipleRange: {
      type: Boolean,
      default: false
    },
    firstDate: {
      type: Date,
      default: null
    }
  },
  components: {
    UiRippleInk: __vue_component__$1A,
    UiIcon: __vue_component__$1B
  },
  watch: {
    date: function date() {
      this.calcDates();
    }
  },
  data: function data() {
    return {
      week: 'æ¥ä¸äºä¸åäºå­',
      dates: []
    };
  },
  computed: {
    elClass: function elClass() {
      return defineProperty$2({
        'ui-date-time-calendar--disabled': this.disabled
      }, "ui-date-time-calendar--".concat(this.size), this.size);
    },
    hdClass: function hdClass() {
      return defineProperty$2({
        'ui-date-time-picker-header': true
      }, "ui-date-time-picker-header--".concat(this.size), this.size);
    },
    values: function values() {
      var value = [];

      if (this.range) {
        if (this.multipleRange && Array.isArray(this.value[0])) {
          value = this.value.reduce(function (acc, range) {
            if (Array.isArray(range) && range.length === 2) {
              acc.push.apply(acc, toConsumableArray(range));
            }

            return acc;
          }, []);
        } else {
          value = this.value;
        }
      } else {
        value = [this.value];
      }

      return value;
    },
    valuestime: function valuestime() {
      if (this.multipleRange && this.range && Array.isArray(this.value[0])) {
        return this.value.map(function (range) {
          if (Array.isArray(range) && range.length === 2) {
            return range.map(function (date) {
              return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
            });
          }

          return [];
        }).filter(function (range) {
          return range.length === 2;
        });
      }

      return this.values.map(function (item) {
        var date = item;
        return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
      });
    },
    year: function year() {
      return this.date.getFullYear();
    },
    month: function month() {
      return this.date.getMonth();
    }
  },
  methods: {
    // æ£æ¥æ¥ææ¯å¦å¨ä»»ä½èå´å
    isDateInRange: function isDateInRange(time) {
      if (!this.range) return false;

      if (this.multipleRange && Array.isArray(this.valuestime[0])) {
        // å¤éæ¨¡å¼ï¼æ£æ¥æ¯å¦å¨ä»»ä½ä¸ä¸ªèå´å
        return this.valuestime.some(function (range) {
          if (range.length === 2) {
            return time >= range[0] && time <= range[1];
          }

          return false;
        });
      } // åéæ¨¡å¼ï¼åæé»è¾


      return this.valuestime.length >= 2 && time >= this.valuestime[0] && time <= this.valuestime[1];
    },
    // æ£æ¥æ¯å¦æ¯èå´å¼å§
    isRangeStart: function isRangeStart(time) {
      if (!this.range) return false;

      if (this.multipleRange && Array.isArray(this.valuestime[0])) {
        return this.valuestime.some(function (range) {
          return range.length === 2 && time === range[0];
        });
      }

      return this.valuestime.length >= 1 && time === this.valuestime[0];
    },
    // æ£æ¥æ¯å¦æ¯èå´ç»æ
    isRangeEnd: function isRangeEnd(time) {
      if (!this.range) return false;

      if (this.multipleRange && Array.isArray(this.valuestime[0])) {
        return this.valuestime.some(function (range) {
          return range.length === 2 && time === range[1];
        });
      }

      return this.valuestime.length >= 2 && time === this.valuestime[1];
    },
    // æ£æ¥æ¯å¦æ¯å¼å§æ¥æï¼firstDateï¼
    isFirstDate: function isFirstDate(time) {
      if (!this.firstDate || !this.multipleRange) return false;
      var firstDateTime = new Date(this.firstDate.getFullYear(), this.firstDate.getMonth(), this.firstDate.getDate()).getTime();
      return time === firstDateTime;
    },
    onClick: function onClick(date) {
      if (this.isValidValue(date.value)) return;
      this.$emit('click', date.value);
    },
    onMouseEnter: function onMouseEnter(date) {
      this.$emit('mouseenter', date.value);
    },
    onYearMouseEnter: function onYearMouseEnter(year) {
      if (!this.range) {
        return;
      }

      this.$emit('mouseenter', new Date(year, 0, 1));
    },
    onMonthMouseEnter: function onMonthMouseEnter(month) {
      if (!this.range) {
        return;
      }

      this.$emit('mouseenter', new Date(this.year, month, 1));
    },
    onDateChange: function onDateChange(y, m) {
      this.$emit('update-date', y, m);
    },
    onOpenYearSelector: function onOpenYearSelector() {
      this.onDateChange(-this.year % 10, 0);
      this.$emit('open-select', 'year');
    },
    onOpenMonthSelector: function onOpenMonthSelector() {
      this.$emit('open-select', 'month');
    },
    onOpenDateSelector: function onOpenDateSelector() {
      this.$emit('open-select', 'date');
    },
    onSelectYear: function onSelectYear(year) {
      var date = new Date(year, this.month, this.date.getDate());
      if (this.isValidValue(date)) return;
      this.$emit('click', date, 'year');
    },
    onSelectMonth: function onSelectMonth(month) {
      var date = new Date(this.date.getFullYear(), month, this.date.getDate()); // let date = new Date()

      date.setDate(1);
      date.setMonth(month);
      if (this.isValidValue(date)) return;
      this.$emit('click', date, 'month');
    },
    generateYearClass: function generateYearClass(year) {
      var atvYear = this.values[0] ? this.values[0].getFullYear() : -1;
      var isInRange = false;
      var isInRangeStart = false;
      var isInRangeEnd = false;

      if (this.range) {
        var rangeStartYear = atvYear;
        var rangeEndYear = this.values[1] ? this.values[1].getFullYear() : -1;
        isInRange = year <= rangeEndYear && year >= rangeStartYear;
        isInRangeStart = year === rangeStartYear;
        isInRangeEnd = year === rangeEndYear;
      }

      return {
        'is-this-time': year === atvYear,
        'is-range': isInRange,
        'is-range-start': isInRangeStart,
        'is-range-end': isInRangeEnd,
        'is-disabled': this.isValidValue(new Date(year, this.month, this.date.getDate()))
      };
    },
    generateMonthClass: function generateMonthClass(month) {
      var date0 = this.values[0] || new Date();
      var year0 = date0.getFullYear();
      var month0 = date0.getMonth();
      var thisMonthTime = new Date(this.year, month, 1).getTime();
      var startMonthTime = new Date(year0, month0, 1).getTime();
      var isInRange = false;
      var isInRangeStart = false;
      var isInRangeEnd = false;

      if (this.range) {
        var date1 = this.values[1] || new Date();
        var year1 = date1.getFullYear();
        var month1 = date1.getMonth();
        var endMonthTime = new Date(year1, month1, 1).getTime();
        isInRange = thisMonthTime <= endMonthTime && thisMonthTime >= startMonthTime;
        isInRangeStart = thisMonthTime === startMonthTime;
        isInRangeEnd = thisMonthTime === endMonthTime;
      }

      return {
        'is-this-time': thisMonthTime === startMonthTime,
        'is-range': isInRange,
        'is-range-start': isInRangeStart,
        'is-range-end': isInRangeEnd,
        'is-disabled': this.isValidValue(new Date(this.year, month, this.date.getDate()))
      };
    },
    calcDates: function calcDates() {
      var dates = [];
      var year = this.year,
          month = this.month;
      var lastMonthTotalDates = new Date(year, month, 0).getDate();
      var totalDates = new Date(year, month + 1, 0).getDate();
      var startDay = new Date(year, month, 1).getDay();
      var week = [];
      var todayTimeStamp = new Date().setHours(0, 0, 0, 0);

      for (var i = 0; i <= 42; i++) {
        if (i && i % 7 === 0) {
          dates.push(week);
          week = [];
        }

        if (i < startDay) {
          var _d = startDay - i - 1;

          var _value = new Date(year, month - 1, lastMonthTotalDates - _d);

          var _time = _value.getTime();

          week.push({
            label: lastMonthTotalDates - _d,
            value: _value,
            time: _time,
            isToday: _time === todayTimeStamp,
            isThisMonth: false
          });
          continue;
        }

        if (i >= startDay + totalDates) {
          var _d2 = i - startDay - totalDates + 1;

          var _value2 = new Date(year, month + 1, _d2);

          var _time2 = _value2.getTime();

          week.push({
            label: _d2,
            value: _value2,
            time: _time2,
            isToday: _time2 === todayTimeStamp,
            isThisMonth: false
          });
          continue;
        }

        var d = i - startDay + 1;
        var value = new Date(year, month, d);
        var time = value.getTime();
        week.push({
          label: d,
          value: value,
          time: time,
          isToday: time === todayTimeStamp,
          isThisMonth: true
        });
      }

      this.dates = dates;
    },
    isValidValue: function isValidValue(time) {
      return typeof this.disabledDate === 'function' ? this.disabledDate(time) : false;
    },
    mounted: function mounted() {
      this.calcDates();
    }
  }
};

/* script */
var __vue_script__$1b = script$1b;
/* template */

var __vue_render__$13 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-date-time-calendar",
    class: _vm.elClass
  }, [_vm.selectType === 'year' ? [_c('div', {
    staticClass: "ui-date-time-picker-header",
    class: _vm.elClass
  }, [_vm.leftVisible ? _c('a', {
    attrs: {
      "title": "ä¸åå¹´"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(-10, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_left"
    }
  })], 1) : _vm._e(), _vm._v(" "), _c('span', {
    staticClass: "ui-grid-full ui-text-center"
  }, [_c('a', {
    staticClass: "ui-date-time-picker-header__item"
  }, [_vm._v(_vm._s(_vm.year) + "å¹´-" + _vm._s(_vm.year + 9) + "å¹´")])]), _vm._v(" "), _vm.rightVisible ? _c('a', {
    attrs: {
      "title": "ä¸åå¹´"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(10, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_right"
    }
  })], 1) : _vm._e()]), _vm._v(" "), _vm._l(10, function (item, i) {
    return _c('div', {
      key: item,
      staticClass: "ui-date-time-calendar__yearmonth-item",
      class: _vm.generateYearClass(i + _vm.year),
      on: {
        "mouseenter": function mouseenter($event) {
          return _vm.onYearMouseEnter(i + _vm.year);
        },
        "click": function click($event) {
          return _vm.onSelectYear(i + _vm.year);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(i + _vm.year))]), _vm._v(" "), _c('ui-ripple-ink')], 1);
  })] : _vm._e(), _vm._v(" "), _vm.selectType === 'month' ? [_c('div', {
    staticClass: "ui-date-time-picker-header",
    class: _vm.elClass
  }, [_vm.leftVisible ? _c('a', {
    attrs: {
      "title": "ä¸ä¸æ"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(-1, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_left"
    }
  })], 1) : _vm._e(), _vm._v(" "), _c('span', {
    staticClass: "ui-grid-full ui-text-center"
  }, [_c('a', {
    staticClass: "ui-date-time-picker-header__item",
    on: {
      "click": _vm.onOpenYearSelector
    }
  }, [_vm._v(_vm._s(_vm.year) + "å¹´")])]), _vm._v(" "), _vm.rightVisible ? _c('a', {
    attrs: {
      "title": "ä¸ä¸æ"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(1, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_right"
    }
  })], 1) : _vm._e()]), _vm._v(" "), _vm._l(12, function (item, i) {
    return _c('div', {
      key: item,
      staticClass: "ui-date-time-calendar__yearmonth-item",
      class: _vm.generateMonthClass(i),
      on: {
        "click": function click($event) {
          return _vm.onSelectMonth(i);
        },
        "mouseenter": function mouseenter($event) {
          return _vm.onMonthMouseEnter(i);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(item) + "æ")]), _vm._v(" "), _c('ui-ripple-ink')], 1);
  })] : _vm._e(), _vm._v(" "), _vm.selectType === 'date' ? [_c('div', {
    staticClass: "ui-date-time-picker-header",
    class: _vm.elClass
  }, [_vm.leftVisible ? [_c('a', {
    attrs: {
      "title": "ä¸ä¸å¹´"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(-1, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_left"
    }
  })], 1), _vm._v(" "), _c('a', {
    attrs: {
      "title": "ä¸ä¸æ"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(0, -1);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "arrow_left"
    }
  })], 1)] : _vm._e(), _vm._v(" "), _c('span', {
    staticClass: "ui-grid-full ui-text-center"
  }, [_c('a', {
    staticClass: "ui-date-time-picker-header__item",
    on: {
      "click": _vm.onOpenYearSelector
    }
  }, [_vm._v(_vm._s(_vm.year) + "å¹´")]), _vm._v(" "), _c('a', {
    staticClass: "ui-date-time-picker-header__item",
    on: {
      "click": _vm.onOpenMonthSelector
    }
  }, [_vm._v(_vm._s(_vm.month + 1) + "æ")])]), _vm._v(" "), _vm.rightVisible ? [_c('a', {
    attrs: {
      "title": "ä¸ä¸æ"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(0, 1);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "arrow_right"
    }
  })], 1), _vm._v(" "), _c('a', {
    attrs: {
      "title": "ä¸ä¸å¹´"
    },
    on: {
      "click": function click($event) {
        return _vm.onDateChange(1, 0);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_right"
    }
  })], 1)] : _vm._e()], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-date-time-calendar__week is-tt"
  }, _vm._l(_vm.week, function (item) {
    return _c('div', {
      key: item,
      staticClass: "ui-date-time-calendar__week-item"
    }, [_vm._v("\n        " + _vm._s(item) + "\n      ")]);
  }), 0), _vm._v(" "), _vm._l(_vm.dates, function (week, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-date-time-calendar__week"
    }, _vm._l(week, function (date, j) {
      return _c('div', {
        key: j,
        staticClass: "ui-date-time-calendar__week-item is-date",
        class: {
          'is-this-month': date.isThisMonth,
          'is-range': _vm.isDateInRange(date.time),
          'is-range-start': _vm.isRangeStart(date.time),
          'is-range-end': _vm.isRangeEnd(date.time),
          'is-first-date': _vm.isFirstDate(date.time),
          'is-select': !_vm.range && date.time === _vm.valuestime[0],
          'is-disabled': _vm.isValidValue(date.value),
          'is-today': date.isToday
        },
        on: {
          "click": function click($event) {
            return _vm.onClick(date);
          },
          "mouseenter": function mouseenter($event) {
            return _vm.onMouseEnter(date);
          }
        }
      }, [_c('span', [_vm._v(_vm._s(date.label))]), _vm._v(" "), date.isThisMonth ? _c('ui-ripple-ink') : _vm._e()], 1);
    }), 0);
  })] : _vm._e()], 2);
};

var __vue_staticRenderFns__$13 = [];
/* style */

var __vue_inject_styles__$1b = undefined;
/* scoped */

var __vue_scope_id__$1b = undefined;
/* module identifier */

var __vue_module_identifier__$1b = undefined;
/* functional template */

var __vue_is_functional_template__$1b = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1b = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$13,
  staticRenderFns: __vue_staticRenderFns__$13
}, __vue_inject_styles__$1b, __vue_script__$1b, __vue_scope_id__$1b, __vue_is_functional_template__$1b, __vue_module_identifier__$1b, false, undefined, undefined, undefined);

var script$1a = {
  name: 'ui-date-time-picker',
  components: {
    UiIcon: __vue_component__$1B,
    picker: {
      components: {
        UiIcon: __vue_component__$1B
      },
      props: {
        total: Number,
        count: Number,
        value: Number,
        split: Number
      },
      methods: {
        onInput: function onInput(value) {
          if (isNaN(Number(value)) || String(value).length > 2) {
            value = String(value).replace(/[^\d]*/g, '').slice(-2);
            this.$refs.input.value = value;
          }

          if (value >= this.total) {
            value -= this.total;
          }

          if (value < 0) {
            value += this.total;
          }

          this.$emit('input', value);
        },

        /**@param {MouseWheelEvent} e */

        /* onWheel(e) {
          let d = Math.abs(e.deltaY) / e.deltaY
          if (isNaN(d)) {
            return
          }
          this.onInput(this.value + d)
        }, */
        onClick: function onClick(d) {
          this.onInput(d + this.value);
        }
      },
      render: function render() {
        var _this = this;

        var h = arguments[0];
        return h("div", {
          "class": "ui-date-time-picker-clock__list"
        }, [h("input", {
          "ref": "input",
          "class": "ui-date-time-picker-clock__list-input",
          "attrs": {
            "type": "text"
          },
          "domProps": {
            "value": ('00' + this.value).slice(-2)
          },
          "on": {
            "input": function input(evt) {
              return _this.onInput(evt.target.value);
            }
          }
        }), this.split ? h("div", {
          "class": "ui-date-time-picker-clock__split"
        }, [Array.from({
          length: this.split
        }).map(function (v, i) {
          var val = i * _this.total / _this.split;
          return h("div", {
            "class": "ui-date-time-picker-clock__split-item",
            "on": {
              "mousedown": function mousedown(evt) {
                evt.stopPropagation();

                _this.onInput(val);
              }
            }
          }, [val]);
        })]) : null, h("div", {
          "class": "ui-date-time-picker-clock__list-choice"
        }, [h("div", {
          "on": {
            "click": function click() {
              return _this.onClick(1);
            }
          }
        }, [h("ui-icon", {
          "attrs": {
            "icon": "expand_less"
          }
        })]), h("div", {
          "on": {
            "click": function click() {
              return _this.onClick(-1);
            }
          }
        }, [h("ui-icon", {
          "attrs": {
            "icon": "expand_more"
          }
        })])])]);
      }
    }
  },
  props: {
    size: {
      type: String,
      default: 'normal'
    },
    value: {
      type: Date,
      default: function _default() {
        return new Date();
      }
    },
    min: Date,
    max: Date
  },
  data: function data() {
    return {};
  },
  computed: {
    valueParsed: function valueParsed() {
      var value = this.value || new Date();
      return {
        y: value.getFullYear(),
        M: value.getMonth(),
        d: value.getDate(),
        h: value.getHours(),
        m: value.getMinutes(),
        s: value.getSeconds()
      };
    },
    elClass: function elClass() {
      return {
        'ui-date-time-picker-clock--small': this.size === 'small',
        'ui-date-time-picker-clock--large': this.size === 'large'
      };
    },
    time: function time() {
      var _this$valueParsed = this.valueParsed,
          h = _this$valueParsed.h,
          m = _this$valueParsed.m,
          s = _this$valueParsed.s;
      return "".concat(('00' + h).slice(-2), ":").concat(('00' + m).slice(-2), ":").concat(('00' + s).slice(-2));
    }
  },
  methods: {
    onInput: function onInput(type, n) {
      var date = this.valueParsed;
      date[type] = n;
      var value = new Date(date.y, date.M, date.d, date.h, date.m, date.s);
      var vt = value.getTime();

      if (this.min) {
        var mt = this.min.getTime();

        if (vt < mt) {
          return;
        }
      }

      if (this.max) {
        var _mt = this.max.getTime();

        if (vt > _mt) {
          return;
        }
      }

      this.$emit('input', value);
    }
  }
};

/* script */
var __vue_script__$1a = script$1a;
/* template */

var __vue_render__$12 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-date-time-picker-clock",
    class: _vm.elClass
  }, [_c('div', {
    staticClass: "ui-date-time-picker-clock__body"
  }, [_c('picker', {
    attrs: {
      "split": 24,
      "total": 24,
      "value": _vm.valueParsed.h
    },
    on: {
      "input": function input($event) {
        return _vm.onInput('h', $event);
      }
    }
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-date-time-picker-clock__border"
  }, [_vm._v(":")]), _vm._v(" "), _c('picker', {
    attrs: {
      "split": 12,
      "total": 60,
      "value": _vm.valueParsed.m
    },
    on: {
      "input": function input($event) {
        return _vm.onInput('m', $event);
      }
    }
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-date-time-picker-clock__border"
  }, [_vm._v(":")]), _vm._v(" "), _c('picker', {
    attrs: {
      "split": 12,
      "total": 60,
      "value": _vm.valueParsed.s
    },
    on: {
      "input": function input($event) {
        return _vm.onInput('s', $event);
      }
    }
  })], 1)]);
};

var __vue_staticRenderFns__$12 = [];
/* style */

var __vue_inject_styles__$1a = undefined;
/* scoped */

var __vue_scope_id__$1a = undefined;
/* module identifier */

var __vue_module_identifier__$1a = undefined;
/* functional template */

var __vue_is_functional_template__$1a = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1a = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$12,
  staticRenderFns: __vue_staticRenderFns__$12
}, __vue_inject_styles__$1a, __vue_script__$1a, __vue_scope_id__$1a, __vue_is_functional_template__$1a, __vue_module_identifier__$1a, false, undefined, undefined, undefined);

// var o = {
//   'M+': date.getMonth() + 1, //æä»½
//   'd+': date.getDate(), //æ¥
//   'h+': date.getHours() % 12 === 0 ? 12 : date.getHours() % 12, //å°æ¶
//   'H+': date.getHours(), //å°æ¶
//   'm+': date.getMinutes(), //å
//   's+': date.getSeconds(), //ç§
//   'q+': Math.floor((date.getMonth() + 3) / 3), //å­£åº¦
//   S: date.getMilliseconds(), //æ¯«ç§
// }
// var week = {
//   '0': '/u65e5',
//   '1': '/u4e00',
//   '2': '/u4e8c',
//   '3': '/u4e09',
//   '4': '/u56db',
//   '5': '/u4e94',
//   '6': '/u516d',
// }
// export default function timeFmt(fmt = '', date = new Date()) {
//   date = formatDate(date)
//   if (/(y+)/.test(fmt)) {
//     fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length))
//   }
//   if (/(E+)/.test(fmt)) {
//     fmt = fmt.replace(
//       RegExp.$1,
//       (RegExp.$1.length > 1 ? (RegExp.$1.length > 2 ? '/u661f/u671f' : '/u5468') : '') +
//         week[date.getDay() + '']
//     )
//   }
//   for (var k in o) {
//     if (new RegExp('(' + k + ')').test(fmt)) {
//       fmt = fmt.replace(
//         RegExp.$1,
//         RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length)
//       )
//     }
//   }
//   return fmt
// }
var fecha = {};
var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigits = '\\d\\d?';
var threeDigits = '\\d{3}';
var fourDigits = '\\d{4}';
var word = '[^\\s]+';
var literal = /\[([^]*?)\]/gm;

var noop$1 = function noop() {};

function regexEscape(str) {
  return str.replace(/[|\\{()[^$+*?.-]/g, '\\$&');
}

function shorten(arr, sLen) {
  var newArr = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }

  return newArr;
}

function monthUpdate(arrName) {
  return function (d, v, i18n) {
    var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());

    if (~index) {
      d.month = index;
    }
  };
}

function pad(val, len) {
  val = String(val);
  len = len || 2;

  while (val.length < len) {
    val = '0' + val;
  }

  return val;
}

var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
fecha.i18n = {
  dayNamesShort: dayNamesShort,
  dayNames: dayNames,
  monthNamesShort: monthNamesShort,
  monthNames: monthNames,
  amPm: ['am', 'pm'],
  DoFn: function DoFn(D) {
    return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
  }
};
var formatFlags = {
  D: function D(dateObj) {
    return dateObj.getDay();
  },
  DD: function DD(dateObj) {
    return pad(dateObj.getDay());
  },
  Do: function Do(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function d(dateObj) {
    return dateObj.getDate();
  },
  dd: function dd(dateObj) {
    return pad(dateObj.getDate());
  },
  ddd: function ddd(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function dddd(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function M(dateObj) {
    return dateObj.getMonth() + 1;
  },
  MM: function MM(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function MMM(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function MMMM(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  yy: function yy(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  yyyy: function yyyy(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function h(dateObj) {
    return dateObj.getHours() % 12 || 12;
  },
  hh: function hh(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function H(dateObj) {
    return dateObj.getHours();
  },
  HH: function HH(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function m(dateObj) {
    return dateObj.getMinutes();
  },
  mm: function mm(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function s(dateObj) {
    return dateObj.getSeconds();
  },
  ss: function ss(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function S(dateObj) {
    return Math.round(dateObj.getMilliseconds() / 100);
  },
  SS: function SS(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function SSS(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function a(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function A(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function ZZ(dateObj) {
    var o = dateObj.getTimezoneOffset();
    return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
  }
};
var parseFlags = {
  d: [twoDigits, function (d, v) {
    d.day = v;
  }],
  Do: [twoDigits + word, function (d, v) {
    d.day = parseInt(v, 10);
  }],
  M: [twoDigits, function (d, v) {
    d.month = v - 1;
  }],
  yy: [twoDigits, function (d, v) {
    var da = new Date(),
        cent = +('' + da.getFullYear()).substr(0, 2);
    d.year = '' + (v > 68 ? cent - 1 : cent) + v;
  }],
  h: [twoDigits, function (d, v) {
    d.hour = v;
  }],
  m: [twoDigits, function (d, v) {
    d.minute = v;
  }],
  s: [twoDigits, function (d, v) {
    d.second = v;
  }],
  yyyy: [fourDigits, function (d, v) {
    d.year = v;
  }],
  S: ['\\d', function (d, v) {
    d.millisecond = v * 100;
  }],
  SS: ['\\d{2}', function (d, v) {
    d.millisecond = v * 10;
  }],
  SSS: [threeDigits, function (d, v) {
    d.millisecond = v;
  }],
  D: [twoDigits, noop$1],
  ddd: [word, noop$1],
  MMM: [word, monthUpdate('monthNamesShort')],
  MMMM: [word, monthUpdate('monthNames')],
  a: [word, function (d, v, i18n) {
    var val = v.toLowerCase();

    if (val === i18n.amPm[0]) {
      d.isPm = false;
    } else if (val === i18n.amPm[1]) {
      d.isPm = true;
    }
  }],
  ZZ: ['[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z', function (d, v) {
    var parts = (v + '').match(/([+-]|\d\d)/gi),
        minutes;

    if (parts) {
      minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
      d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
    }
  }]
};
parseFlags.dd = parseFlags.d;
parseFlags.dddd = parseFlags.ddd;
parseFlags.DD = parseFlags.D;
parseFlags.mm = parseFlags.m;
parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
parseFlags.MM = parseFlags.M;
parseFlags.ss = parseFlags.s;
parseFlags.A = parseFlags.a; // Some common format strings

fecha.masks = {
  normal: 'yyyy-MM-dd HH:mm:ss',
  default: 'ddd MMM dd yyyy HH:mm:ss',
  shortDate: 'M/D/yy',
  mediumDate: 'MMM d, yyyy',
  longDate: 'MMMM d, yyyy',
  fullDate: 'dddd, MMMM d, yyyy',
  shortTime: 'HH:mm',
  mediumTime: 'HH:mm:ss',
  longTime: 'HH:mm:ss.SSS'
};
/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 */

var format = function format(dateObj, mask, i18nSettings) {
  var i18n = i18nSettings || fecha.i18n;

  if (typeof dateObj === 'number') {
    dateObj = new Date(dateObj);
  }

  if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
    throw new Error('Invalid Date in fecha.format');
  }

  mask = fecha.masks[mask] || mask || fecha.masks['default'];
  var literals = []; // Make literals inactive by replacing them with ??

  mask = mask.replace(literal, function ($0, $1) {
    literals.push($1);
    return '@@@';
  }); // Apply formatting rules

  mask = mask.replace(token, function ($0) {
    return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
  }); // Inline literal values back into the formatted value

  return mask.replace(/@@@/g, function () {
    return literals.shift();
  });
};
/**
 * Parse a date string into an object, changes - into /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @returns {Date|boolean}
 */

var parse = function parse(dateStr, format, i18nSettings) {
  var i18n = i18nSettings || fecha.i18n;

  if (typeof format !== 'string') {
    throw new Error('Invalid format in fecha.parse ' + format);
  }

  format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings
  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS

  if (dateStr.length > 1000) {
    return null;
  }

  var dateInfo = {};
  var parseInfo = [];
  var literals = [];
  format = format.replace(literal, function ($0, $1) {
    literals.push($1);
    return '@@@';
  });
  var newFormat = regexEscape(format).replace(token, function ($0) {
    if (parseFlags[$0]) {
      var info = parseFlags[$0];
      parseInfo.push(info[1]);
      return '(' + info[0] + ')';
    }

    return $0;
  });
  newFormat = newFormat.replace(/@@@/g, function () {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, 'i'));

  if (!matches) {
    return null;
  }

  for (var i = 1; i < matches.length; i++) {
    parseInfo[i - 1](dateInfo, matches[i], i18n);
  }

  var today = new Date();

  if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }

  var date;

  if (dateInfo.timezoneOffset != null) {
    dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
    date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
  } else {
    date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
  }

  return date;
};
function formatDate$1(value) {
  var fmt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'normal';

  if (!value) {
    return null;
  }

  if ('number' === typeof value) {
    return new Date(value);
  }

  if ('string' === typeof value) {
    return parse(value, fmt);
  }

  if (value instanceof Date) {
    return value;
  }

  return null;
}
function timeFmt() {
  var fmt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  if (!fmt) return date;
  date = formatDate$1(date, fmt);
  if (!date) return '';
  return format(date, fmt);
}

var script$19 = {
  name: 'ui-date-time-picker-panel',
  props: {
    value: {
      type: [Number, String, Date, Array],
      default: ''
    },
    type: {
      type: String,
      default: 'date' // daterange datetime datetimerange

    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    size: {
      type: String,
      default: 'normal'
    },
    format: {
      type: String,
      default: 'yyyy-MM-dd'
    },
    hasFooter: {
      type: Boolean,
      default: true
    },
    disabledDate: Function,
    multipleRange: {
      type: Boolean,
      default: false
    },
    showMultipleToggle: {
      type: Boolean,
      default: false
    }
  },
  components: {
    Calendar: __vue_component__$1b,
    Clock: __vue_component__$1a,
    UiRippleInk: __vue_component__$1A,
    UiButton: __vue_component__$1v
  },
  data: function data() {
    return {
      isActive: false,
      date: new Date(),
      isShowTime: false,
      selectType: 'date',
      previewRange: null,
      firstDate: null
    };
  },
  computed: {
    elClass: function elClass() {
      return [{
        'ui-date-time-picker-panel--small': this.size === 'small'
      }, {
        'ui-date-time-picker-panel--large': this.size === 'large'
      }];
    },
    nextDate: function nextDate() {
      var date = this.date;

      if (this.selectType === 'year') {
        return new Date(date.getFullYear() + 10, date.getMonth());
      }

      if (this.selectType === 'month') {
        return new Date(date.getFullYear() + 1, date.getMonth());
      }

      return new Date(date.getFullYear(), date.getMonth() + 1);
    },
    valueParsed: function valueParsed() {
      if (this.value) {
        var format = this.format || (this.hasTime ? 'yyyy-MM-dd' : 'yyyy-MM-dd HH:mm:ss');

        if (this.isRange) {
          if (this.multipleRange && Array.isArray(this.value[0])) {
            var ranges = this.value.map(function (range) {
              return range.map(function (val) {
                return formatDate$1(val, format);
              }).filter(Boolean);
            }).filter(function (range) {
              return range.length === 2;
            });
            this._value = ranges;

            if (this.previewRange) {
              var previewFormatted = this.previewRange.map(function (val) {
                return formatDate$1(val, format);
              });
              var allRanges = [].concat(toConsumableArray(ranges), [previewFormatted]);
              var mergedRanges = this.mergeRanges(allRanges);
              return mergedRanges;
            }

            return ranges;
          }

          this._value = this.value.map(function (val) {
            return formatDate$1(val, format);
          }).filter(Boolean);
          return this._value;
        }

        this._value = formatDate$1(this.value, format);
        return this._value;
      }

      if (this.isRange) {
        return [new Date()];
      }

      return new Date();
    },
    rangeValue: function rangeValue() {
      if (!this.isRange) {
        return [];
      }

      if (!this.value || !this.value.length) {
        var date = new Date();
        return [new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0), new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59)];
      }

      var format = this.format || (this.hasTime ? 'yyyy-MM-dd' : 'yyyy-MM-dd HH:mm:ss');

      if (this.multipleRange && Array.isArray(this.value[0])) {
        return this.value.length > 0 ? this.value[0].map(function (val) {
          return formatDate$1(val, format);
        }) : [new Date(), new Date()];
      }

      return this.value.map(function (val) {
        return formatDate$1(val, format);
      });
    },
    isRange: function isRange() {
      return /range$/.test(this.type);
    },
    isMonth: function isMonth() {
      return /month/.test(this.type);
    },
    isYear: function isYear() {
      return /year/.test(this.type);
    },
    hasTime: function hasTime() {
      return /time/.test(this.type);
    }
  },
  watch: {
    format: function format() {
      if (this._value) {
        this.$emit('input', this._value);
      }
    }
  },
  methods: {
    // æ¸é¤é¢è§ç¶æ
    clearPreview: function clearPreview() {
      if (this.multipleRange) {
        this.previewRange = null;
      }
    },
    // æ£æ¥æ¥ææ¯å¦å¨æä¸ªèå´å
    isDateInExistingRange: function isDateInExistingRange(date, ranges) {
      if (!ranges || ranges.length === 0) return false;
      var checkDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      var checkTime = checkDate.getTime();
      return ranges.some(function (range) {
        if (!Array.isArray(range) || range.length !== 2) return false;
        var startDate = new Date(range[0]);
        var endDate = new Date(range[1]);
        var startTime = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate()).getTime();
        var endTime = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate()).getTime();
        return checkTime >= startTime && checkTime <= endTime;
      });
    },
    // å é¤åå«æå®æ¥æçèå´
    removeRangeContainingDate: function removeRangeContainingDate(date, ranges) {
      if (!ranges || ranges.length === 0) return ranges;
      var checkDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      var checkTime = checkDate.getTime();
      return ranges.filter(function (range) {
        if (!Array.isArray(range) || range.length !== 2) return true;
        var startDate = new Date(range[0]);
        var endDate = new Date(range[1]);
        var startTime = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate()).getTime();
        var endTime = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate()).getTime(); // å¦ææ¥æå¨è¿ä¸ªèå´åï¼åè¿æ»¤æï¼å é¤ï¼è¿ä¸ªèå´

        return !(checkTime >= startTime && checkTime <= endTime);
      });
    },
    // å¤éæ¨¡å¼ç¡®è®¤æ¹æ³
    onMultipleRangeConfirm: function onMultipleRangeConfirm() {
      // æ¸é¤é¢è§ç¶æ
      this.previewRange = null;
      this.firstDate = null;
      this.$emit('multiple-range-confirm');
    },
    // å¤éæ¨¡å¼æ¸ç©ºæ¹æ³
    onMultipleRangeClear: function onMultipleRangeClear() {
      // æ¸ç©ºææéæ©çèå´
      this.$emit('input', []); // æ¸é¤é¢è§ç¶æåéæ©ç¶æ

      this.previewRange = null;
      this.firstDate = null;
    },
    // åæ¢ä¸ºå¤éæ¨¡å¼
    onToggleToMultiple: function onToggleToMultiple() {
      this.$emit('toggle-to-multiple');
    },
    // åå¹¶éå çæ¥æèå´
    mergeRanges: function mergeRanges(ranges) {
      if (!ranges || ranges.length === 0) return [];
      var sortedRanges = ranges.sort(function (a, b) {
        return new Date(a[0]).getTime() - new Date(b[0]).getTime();
      });
      var merged = [sortedRanges[0]];

      for (var i = 1; i < sortedRanges.length; i++) {
        var current = sortedRanges[i];
        var lastMerged = merged[merged.length - 1];
        var lastEnd = new Date(lastMerged[1]).getTime();
        var currentStart = new Date(current[0]).getTime();
        var oneDayMs = 24 * 60 * 60 * 1000; // åå¹¶éå æç¸é»çèå´ï¼å·®è·å°äºç­äº1å¤©ï¼

        if (currentStart <= lastEnd + oneDayMs) {
          var newEnd = new Date(Math.max(lastEnd, new Date(current[1]).getTime()));
          merged[merged.length - 1][1] = newEnd;
        } else {
          merged.push(current);
        }
      }

      return merged;
    },
    onCalendarClick: function onCalendarClick(date, type) {
      if (this.isRange) {
        if (type === 'year' && !this.isYear) {
          this.date = new Date(date.getFullYear(), this.date.getMonth());
          this.selectType = 'month';
          return;
        }

        if (type === 'month' && !this.isMonth) {
          this.date = date;
          this.selectType = 'date';
          return;
        }

        if (this.multipleRange) {
          // é¦åæ£æ¥ç¹å»çæ¥ææ¯å¦å¨å·²æèå´å
          var currentRanges = [];

          if (this.value && Array.isArray(this.value)) {
            if (this.value.length > 0 && Array.isArray(this.value[0])) {
              // å¤ç»´æ°ç»æ ¼å¼
              currentRanges = toConsumableArray(this.value);
            } else if (this.value.length === 2) {
              // åä¸ªèå´æ ¼å¼
              currentRanges = [this.value];
            }
          } // å¦æç¹å»çæ¥æå¨å·²æèå´åï¼åå é¤è¯¥èå´


          if (currentRanges.length > 0 && this.isDateInExistingRange(date, currentRanges)) {
            var updatedRanges = this.removeRangeContainingDate(date, currentRanges);
            this.$emit('input', updatedRanges); // æ¸é¤éæ©ç¶æ

            this.firstDate = null;
            this.previewRange = null;
            return;
          }

          if (this.firstDate) {
            // å®æä¸ä¸ªèå´çéæ©
            var newRange = [this.firstDate, date].sort(function (a, b) {
              return a.setHours(0, 0, 0, 0) - b.setHours(0, 0, 0, 0);
            });
            newRange = newRange.map(function (d, i) {
              return new Date(d.setHours.apply(d, toConsumableArray(i == 0 ? [0, 0, 0, 0] : [23, 59, 59, 0])));
            }); // å¦ææ¯åä¸å¤©ï¼åå»ºåå¤©èå´

            if (this.firstDate.getFullYear() === date.getFullYear() && this.firstDate.getMonth() === date.getMonth() && this.firstDate.getDate() === date.getDate()) {
              var singleDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
              newRange = [new Date(singleDay.setHours(0, 0, 0, 0)), new Date(singleDay.setHours(23, 59, 59, 0))];
            }

            currentRanges.push(newRange);
            var mergedRanges = this.mergeRanges(currentRanges); // å¤éæ¨¡å¼ä¸ä¸åé'end'ç±»åï¼é¿åèªå¨å³é­é¢æ¿

            this.$emit('input', mergedRanges);
            this.firstDate = null;
            this.previewRange = null; // æ¸é¤é¢è§ç¶æ

            return;
          }

          this.firstDate = date;
          this.onCalendarMouseEnter(date, 'start');
          return;
        }

        if (this.firstDate) {
          this.onCalendarMouseEnter(date, 'end');
          this.firstDate = null;
          return;
        }

        this.firstDate = date;
        this.onCalendarMouseEnter(date, 'start');
        return;
      }

      if (type === 'year') {
        if (this.isYear) {
          this.$emit('input', date);
          return;
        }

        this.selectType = 'month';
      }

      if (type === 'month') {
        if (this.isMonth) {
          this.$emit('input', date);
          return;
        }

        this.selectType = 'date';
      }

      var lastDate = new Date(this.date || date);
      this.date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), lastDate.getHours(), lastDate.getMinutes(), lastDate.getSeconds());
      this.$emit('input', this.date);
    },
    onCalendarMouseEnter: function onCalendarMouseEnter(date, type) {
      if (!this.firstDate) return;
      var value = [this.firstDate, date].sort(function (a, b) {
        return a.setHours(0, 0, 0, 0) - b.setHours(0, 0, 0, 0);
      });
      value = value.map(function (d, i) {
        return new Date(d.setHours.apply(d, toConsumableArray(i == 0 ? [0, 0, 0, 0] : [23, 59, 59, 0])));
      });

      if (this.multipleRange) {
        // å¤éæ¨¡å¼ä¸åªè®¾ç½®é¢è§ç¶æï¼ä¸ä¿®æ¹å®éå¼
        this.previewRange = value;
      } else {
        this.$emit('input', value, type);
      }
    },
    onDateChange: function onDateChange(y, m) {
      this.date = new Date(this.date.getFullYear() + y, this.date.getMonth() + m);
    },
    onClickOption: function onClickOption(item) {
      this.$emit('input', 'function' === typeof item.value ? item.value() : item.value, 'end');
    },
    onClockInp: function onClockInp(date, i) {
      var value = this.rangeValue;
      value[i] = date;
      this.$emit('input', value);
    },
    onSelectTypeChange: function onSelectTypeChange(type) {
      if (!this.isMonth && !this.isYear) {
        this.selectType = type;
      }

      if (type === 'year' && this.isMonth) {
        this.selectType = type;
      }
    },
    initDate: function initDate() {
      var date = new Date();

      if (this.isRange) {
        if (this.multipleRange && Array.isArray(this.valueParsed[0])) {
          date = this.valueParsed.length > 0 && this.valueParsed[0].length > 0 ? this.valueParsed[0][0] : new Date();
        } else {
          date = this.valueParsed[0] || new Date();
        }
      } else {
        date = this.valueParsed;
      }

      this.date = date;
    }
  },
  mounted: function mounted() {
    this.initDate();
    this.selectType = 'date';

    switch (true) {
      case this.isMonth:
        this.selectType = 'month';
        break;

      case this.isYear:
        this.selectType = 'year';
        break;
    }
  }
};

/* script */
var __vue_script__$19 = script$19;
/* template */

var __vue_render__$11 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-date-time-picker-panel",
    class: _vm.elClass
  }, [_vm.options.length ? _c('ul', {
    staticClass: "ui-date-time-picker-panel__options"
  }, _vm._l(_vm.options, function (item, i) {
    return _c('li', {
      key: i,
      on: {
        "click": function click($event) {
          return _vm.onClickOption(item);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(item.label))]), _vm._v(" "), _c('ui-ripple-ink')], 1);
  }), 0) : _vm._e(), _vm._v(" "), _c('div', [_c('div', {
    staticClass: "ui-date-time-picker-panel__content"
  }, [!_vm.isRange ? [_c('div', {
    staticClass: "ui-date-time-picker-panel__left"
  }, [_c('div', {
    staticClass: "ui-date-time-picker-panel__calendar"
  }, [_c('calendar', {
    attrs: {
      "size": _vm.size,
      "date": _vm.date,
      "value": _vm.valueParsed,
      "select-type": _vm.selectType,
      "disabled-date": _vm.disabledDate,
      "multiple-range": _vm.multipleRange,
      "first-date": _vm.firstDate,
      "left-visible": "",
      "right-visible": ""
    },
    on: {
      "click": _vm.onCalendarClick,
      "mouseenter": _vm.onCalendarMouseEnter,
      "update-date": _vm.onDateChange,
      "open-select": _vm.onSelectTypeChange
    }
  })], 1)])] : [_c('div', {
    staticClass: "ui-date-time-picker-panel__left"
  }, [_c('div', {
    staticClass: "ui-date-time-picker-panel__calendar"
  }, [_c('calendar', {
    attrs: {
      "size": _vm.size,
      "date": _vm.date,
      "value": _vm.valueParsed,
      "select-type": _vm.selectType,
      "disabled-date": _vm.disabledDate,
      "multiple-range": _vm.multipleRange,
      "first-date": _vm.firstDate,
      "range": "",
      "left-visible": ""
    },
    on: {
      "click": _vm.onCalendarClick,
      "mouseenter": _vm.onCalendarMouseEnter,
      "update-date": _vm.onDateChange,
      "open-select": _vm.onSelectTypeChange
    }
  })], 1)]), _vm._v(" "), _c('div', {
    staticClass: "ui-date-time-picker-panel__right"
  }, [_c('div', {
    staticClass: "ui-date-time-picker-panel__calendar"
  }, [_c('calendar', {
    attrs: {
      "size": _vm.size,
      "date": _vm.nextDate,
      "value": _vm.valueParsed,
      "select-type": _vm.selectType,
      "disabled-date": _vm.disabledDate,
      "multiple-range": _vm.multipleRange,
      "first-date": _vm.firstDate,
      "range": "",
      "right-visible": ""
    },
    on: {
      "click": _vm.onCalendarClick,
      "mouseenter": _vm.onCalendarMouseEnter,
      "update-date": _vm.onDateChange,
      "open-select": _vm.onSelectTypeChange
    }
  })], 1)])]], 2), _vm._v(" "), _vm.hasFooter ? _c('div', {
    staticClass: "ui-date-time-picker-panel__footer"
  }, [_c('div', {
    staticClass: "ui-date-time-picker-panel__footer-time"
  }, [_vm.hasTime ? [_vm.isRange ? [_c('clock', {
    attrs: {
      "size": _vm.size,
      "value": _vm.rangeValue[0],
      "max": _vm.rangeValue[1]
    },
    on: {
      "input": function input($event) {
        return _vm.onClockInp($event, 0);
      }
    }
  }), _vm._v(" "), _c('span', [_vm._v("è³")]), _vm._v(" "), _c('clock', {
    attrs: {
      "value": _vm.rangeValue[1],
      "size": _vm.size,
      "min": _vm.rangeValue[0]
    },
    on: {
      "input": function input($event) {
        return _vm.onClockInp($event, 1);
      }
    }
  })] : _c('clock', {
    attrs: {
      "size": _vm.size,
      "value": _vm.valueParsed
    },
    on: {
      "input": function input($event) {
        return _vm.$emit('input', $event);
      }
    }
  })] : _vm._e()], 2), _vm._v(" "), _vm.multipleRange && _vm.isRange ? _c('ui-button', {
    attrs: {
      "size": _vm.size,
      "color": "primary"
    },
    on: {
      "click": _vm.onMultipleRangeConfirm
    }
  }, [_vm._v("ç¡®è®¤éæ©")]) : _vm._e(), _vm._v(" "), _vm.multipleRange && _vm.isRange ? _c('ui-button', {
    attrs: {
      "size": _vm.size
    },
    on: {
      "click": _vm.onMultipleRangeClear
    }
  }, [_vm._v("æ¸ç©º")]) : _vm._e(), _vm._v(" "), !_vm.multipleRange && _vm.isRange && _vm.showMultipleToggle ? _c('ui-button', {
    attrs: {
      "size": _vm.size
    },
    on: {
      "click": _vm.onToggleToMultiple
    }
  }, [_vm._v("åæ¢ä¸ºå¤é")]) : _vm._e(), _vm._v(" "), _vm._t("default")], 2) : _vm._e()])]);
};

var __vue_staticRenderFns__$11 = [];
/* style */

var __vue_inject_styles__$19 = undefined;
/* scoped */

var __vue_scope_id__$19 = undefined;
/* module identifier */

var __vue_module_identifier__$19 = undefined;
/* functional template */

var __vue_is_functional_template__$19 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$19 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$11,
  staticRenderFns: __vue_staticRenderFns__$11
}, __vue_inject_styles__$19, __vue_script__$19, __vue_scope_id__$19, __vue_is_functional_template__$19, __vue_module_identifier__$19, false, undefined, undefined, undefined);

var script$18 = {
  name: 'ui-date-time-picker',
  props: {
    name: String,
    label: String,
    placeholder: String,
    placement: {
      type: String,
      default: 'bottom-start'
    },
    value: {
      type: [Number, String, Date, Array],
      default: ''
    },
    type: {
      type: String,
      default: 'date' // daterange datetime datetimerange month year monthrange yearrange

    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    floatingLabel: Boolean,
    size: {
      type: String,
      default: 'normal'
    },
    format: {
      type: String,
      default: ''
    },
    outputType: {
      type: String,
      default: 'String'
    },
    trigger: {
      type: String,
      default: 'input' // input or click

    },
    clearable: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    help: String,
    error: String,
    disabledDate: Function,
    showMultipleToggle: {
      type: Boolean,
      default: false
    },
    multipleRange: {
      type: Boolean,
      default: false
    }
  },
  components: {
    VPopover: VPopover,
    Panel: __vue_component__$19,
    UiIcon: __vue_component__$1B,
    UiTextbox: __vue_component__$1r
  },
  data: function data() {
    return {
      innerValue: this.value,
      isActive: false,
      internalMultipleRange: this.multipleRange
    };
  },
  computed: {
    elClass: function elClass() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-date-time-picker--".concat(this.type || 'date'), this.type || 'date'), defineProperty$2(_ref, "ui-date-time-picker--".concat(this.size), this.size), defineProperty$2(_ref, 'ui-date-time-picker--error', this.error), defineProperty$2(_ref, 'is-disabled', this.disabled), defineProperty$2(_ref, 'has-clear', this.hasClear), _ref;
    },
    valueFormated: function valueFormated() {
      var _this = this;

      if (this.floatingLabel && !this.isActive && !this.value) {
        return '';
      }

      if (!this.value) {
        return '';
      }

      var format = this.format || (this.hasTime ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd');

      try {
        if (this.isRange) {
          if (!this.value.length) {
            return '';
          }

          if (this.internalMultipleRange && Array.isArray(this.value[0])) {
            return this.value.map(function (range) {
              if (Array.isArray(range) && range.length === 2) {
                var start = timeFmt(format, range[0]);
                var end = timeFmt(format, range[1]);

                var isSameDay = _this.isSameDay(range[0], range[1]);

                return isSameDay ? start : "".concat(start, "\u81F3").concat(end);
              }

              return timeFmt(format, range);
            }).join(';');
          }

          return this.value.map(function (item) {
            return timeFmt(format, item);
          }).join(' è³ ');
        }

        return timeFmt(format, this.value);
      } catch (error) {}
    },
    isRange: function isRange() {
      return /range$/.test(this.type);
    },
    hasTime: function hasTime() {
      return /time/.test(this.type);
    },
    hasClear: function hasClear() {
      return this.clearable && !this.disabled && !this.readonly && [].concat(this.value).filter(Boolean).length > 0;
    }
  },
  watch: {
    format: function format() {
      if (this.innerValue) {
        this.onInput(this.innerValue);
      }
    },
    multipleRange: function multipleRange(newVal) {
      this.internalMultipleRange = newVal;
    },
    value: {
      handler: function handler(newVal) {
        this.innerValue = newVal;
        this.autoDetectMultipleRange();
      },
      immediate: true
    }
  },
  methods: {
    isSameDay: function isSameDay(date1, date2) {
      if (!date1 || !date2) return false;
      var d1 = new Date(date1);
      var d2 = new Date(date2);
      return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();
    },
    onClose: function onClose() {
      this.isActive = false;
    },
    onOpen: function onOpen() {
      this.innerValue = this.value;
      this.isActive = true;

      if (this.$refs.panel && this.$refs.panel.clearPreview) {
        this.$refs.panel.clearPreview();
      }

      this.$emit('focus');
    },
    onInput: function onInput(date, type) {
      this.innerValue = date;
      this.onTrigger('input');

      if ('input' === this.trigger) {
        if (this.hasTime) return;
        if (this.internalMultipleRange && this.isRange) return;
        if (this.isRange && 'end' !== type) return;
        this.$refs.dropdown.hide();
      }
    },
    onClear: function onClear() {
      this.innerValue = this.isRange ? [] : '';

      if (this.$refs.panel && this.$refs.panel.clearPreview) {
        this.$refs.panel.clearPreview();
      }

      this.onTrigger(this.trigger);
    },
    onConfirm: function onConfirm() {
      this.onTrigger('click');
      this.$refs.dropdown.hide();
    },
    onMultipleRangeConfirm: function onMultipleRangeConfirm() {
      this.$refs.dropdown.hide();
    },
    onToggleToMultiple: function onToggleToMultiple() {
      // å°å½åæ¨¡å¼åæ¢ä¸ºå¤éæ¨¡å¼
      this.internalMultipleRange = true; // å¦æå½åæåéçå¼ï¼å°å¶è½¬æ¢ä¸ºå¤éæ ¼å¼

      if (this.innerValue && Array.isArray(this.innerValue) && this.innerValue.length === 2) {
        this.innerValue = [this.innerValue];
        this.onTrigger('input');
      } // åéå¤éæ¨¡å¼ååäºä»¶ï¼è®©ç¶ç»ä»¶ç¥éæ¨¡å¼å·²åæ¢


      this.$emit('multiple-range-changed', true);
    },
    onTrigger: function onTrigger(trigger) {
      if (trigger !== this.trigger) return;
      var format = this.outputType === 'Date' ? '' : this.format;

      if (this.isRange) {
        if (this.internalMultipleRange && Array.isArray(this.innerValue[0])) {
          // å¤éæ¨¡å¼ï¼å¤çå¤ç»´æ°ç»
          this.$emit('input', this.innerValue.map(function (range) {
            return range.map(function (item) {
              return timeFmt(format, item);
            });
          }));
        } else {
          // åéæ¨¡å¼ï¼åæé»è¾
          this.$emit('input', this.innerValue.map(function (item) {
            return timeFmt(format, item);
          }));
        }
      } else {
        this.$emit('input', timeFmt(format, this.innerValue));
      }
    },
    autoDetectMultipleRange: function autoDetectMultipleRange() {
      // åªæå¨èå´éæ©æ¨¡å¼ä¸æè¿è¡æ£æµ
      if (!this.isRange) {
        return;
      } // å¦ææ°æ®ä¸ºç©ºï¼ä¸è¿è¡æ¨¡å¼åæ¢ï¼ä¿æå½åæ¨¡å¼


      if (!this.value || !Array.isArray(this.value) || this.value.length === 0) {
        return;
      } // æ£æµæ¯å¦ä¸ºäºç»´æ°ç»ï¼å¤éæ ¼å¼ï¼


      var isMultiDimensional = Array.isArray(this.value[0]);

      if (isMultiDimensional && !this.internalMultipleRange) {
        // å¦ææ£æµå°äºç»´æ°ç»ä½å½åæ¯åéæ¨¡å¼ï¼èªå¨åæ¢ä¸ºå¤é
        this.internalMultipleRange = true;
        this.$emit('multiple-range-changed', true);
      } // ç§»é¤èªå¨åååéçé»è¾ï¼ä¸æ¦åæ¢ä¸ºå¤éæ¨¡å¼å°±ä¿æå¤éæ¨¡å¼

    }
  },
  mounted: function mounted() {
    this.autoDetectMultipleRange();
  }
};

/* script */
var __vue_script__$18 = script$18;
/* template */

var __vue_render__$10 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-date-time-picker",
    class: _vm.elClass
  }, [_c('v-popover', {
    ref: "dropdown",
    staticClass: "ui-date-time-picker__popover",
    attrs: {
      "popover-class": "ui-date-time-picker__dropdown",
      "placement": _vm.placement,
      "disabled": _vm.disabled
    },
    on: {
      "show": _vm.onOpen,
      "hide": _vm.onClose
    }
  }, [_vm.isActive ? _c('panel', {
    ref: "panel",
    attrs: {
      "slot": "popover",
      "type": _vm.type,
      "size": _vm.size,
      "value": _vm.innerValue,
      "options": _vm.options,
      "format": _vm.format,
      "has-footer": 'click' === _vm.trigger || _vm.hasTime || _vm.internalMultipleRange && _vm.isRange || !_vm.internalMultipleRange && _vm.isRange && _vm.showMultipleToggle,
      "disabled-date": _vm.disabledDate,
      "multiple-range": _vm.internalMultipleRange,
      "show-multiple-toggle": _vm.showMultipleToggle
    },
    on: {
      "input": _vm.onInput,
      "multiple-range-confirm": _vm.onMultipleRangeConfirm,
      "toggle-to-multiple": _vm.onToggleToMultiple
    },
    slot: "popover"
  }, ['click' === _vm.trigger || _vm.hasTime ? _c('ui-button', {
    attrs: {
      "size": _vm.size,
      "color": "primary"
    },
    on: {
      "click": _vm.onConfirm
    }
  }, [_vm._v("ç¡®å®")]) : _vm._e()], 1) : _vm._e(), _vm._v(" "), _c('ui-textbox', {
    staticClass: "ui-date-time-picker__content",
    attrs: {
      "value": _vm.valueFormated,
      "label": _vm.label,
      "floatingLabel": _vm.floatingLabel,
      "placeholder": _vm.placeholder,
      "readonly": true,
      "disabled": _vm.disabled,
      "size": _vm.size,
      "name": _vm.name
    }
  }, [_c('template', {
    slot: "append"
  }, [_vm.hasClear ? _c('ui-icon', {
    staticClass: "ui-date-time-picker__clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.onClear($event);
      }
    }
  }) : _vm._e(), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-date-time-picker__input-arrow"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M6.984 9.984h10.03L12 15z"
    }
  })])])], 1)], 2)], 1)], 1);
};

var __vue_staticRenderFns__$10 = [];
/* style */

var __vue_inject_styles__$18 = undefined;
/* scoped */

var __vue_scope_id__$18 = undefined;
/* module identifier */

var __vue_module_identifier__$18 = undefined;
/* functional template */

var __vue_is_functional_template__$18 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$18 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$10,
  staticRenderFns: __vue_staticRenderFns__$10
}, __vue_inject_styles__$18, __vue_script__$18, __vue_scope_id__$18, __vue_is_functional_template__$18, __vue_module_identifier__$18, false, undefined, undefined, undefined);

/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    });
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var version = "1.10.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !!
    /*@__PURE__*/
    navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on$1(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index$1(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend$1(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle$1(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone$1(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread$e({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults$1) {
      if (defaults$1.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults$1[option];
      }
    }

    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread$e({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread$e({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread$e({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, ["evt"]);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread$e({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread$e({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    if (lastChild(sortable)) return;
    var rect = getRect(sortable),
        threshold = sortable[expando].options.emptyInsertThreshold,
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (threshold && insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof$2(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on$1(el, 'pointerdown', this._onTapStart);
  } else {
    on$1(el, 'mousedown', this._onTapStart);
    on$1(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on$1(el, 'dragover', this);
    on$1(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on$1(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, 'mouseup', _this._onDrop);
      on$1(ownerDocument, 'touchend', _this._onDrop);
      on$1(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on$1(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on$1(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on$1(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on$1(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on$1(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on$1(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on$1(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on$1(document, 'touchmove', this._onTouchMove);
      } else {
        on$1(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on$1(dragEl, 'dragend', this);
      on$1(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on$1(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone$1(dragEl);
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on$1(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on$1(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread$e({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // assign target only if condition is true


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index$1(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (rootEl.contains(dragEl) && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on$1(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on$1,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend$1,
  throttle: throttle$1,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone$1,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread$e({}, Sortable.utils, plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on$1(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on$1(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on$1(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on$1(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle$1(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index$1(n1);
  i2 = index$1(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (sortable.options.supportPointer) {
      on$1(document, 'pointerup', this._deselectMultiDrag);
    } else {
      on$1(document, 'mouseup', this._deselectMultiDrag);
      on$1(document, 'touchend', this._deselectMultiDrag);
    }

    on$1(document, 'keydown', this._checkKeyDown);
    on$1(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone$1(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      _ref5.sortable;
          var cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index$1(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvt: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index$1(lastMultiDragSelect),
                currentIndex = index$1(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvt: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvt: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index$1(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index$1(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index$1(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvt: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index$1(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index$1(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray$1(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

var sortable_esm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	'default': Sortable,
	MultiDrag: MultiDragPlugin,
	Sortable: Sortable,
	Swap: SwapPlugin
});

var require$$0 = getCjsExportFromNamespace(sortable_esm);

var vuedraggable_umd = createCommonjsModule(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory(require$$0);
})((typeof self !== 'undefined' ? self : commonjsGlobal), function(__WEBPACK_EXTERNAL_MODULE_a352__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "01f9":
/***/ (function(module, exports, __webpack_require__) {

var LIBRARY = __webpack_require__("2d00");
var $export = __webpack_require__("5ca1");
var redefine = __webpack_require__("2aba");
var hide = __webpack_require__("32e9");
var Iterators = __webpack_require__("84f2");
var $iterCreate = __webpack_require__("41a0");
var setToStringTag = __webpack_require__("7f20");
var getPrototypeOf = __webpack_require__("38fd");
var ITERATOR = __webpack_require__("2b4c")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "02f4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var defined = __webpack_require__("be13");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "0390":
/***/ (function(module, exports, __webpack_require__) {

var at = __webpack_require__("02f4")(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ "0bfb":
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__("cb7c");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "0d58":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("ce10");
var enumBugKeys = __webpack_require__("e11e");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "1495":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc");
var anObject = __webpack_require__("cb7c");
var getKeys = __webpack_require__("0d58");

module.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "214f":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("b0c5");
var redefine = __webpack_require__("2aba");
var hide = __webpack_require__("32e9");
var fails = __webpack_require__("79e5");
var defined = __webpack_require__("be13");
var wks = __webpack_require__("2b4c");
var regexpExec = __webpack_require__("520a");

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "230e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
var document = __webpack_require__("7726").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "23c6":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("2d95");
var TAG = __webpack_require__("2b4c")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "2621":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "2aba":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var has = __webpack_require__("69a8");
var SRC = __webpack_require__("ca5a")('src');
var $toString = __webpack_require__("fa5b");
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__("8378").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "2aeb":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("cb7c");
var dPs = __webpack_require__("1495");
var enumBugKeys = __webpack_require__("e11e");
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("230e")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("fab2").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "2b4c":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("5537")('wks');
var uid = __webpack_require__("ca5a");
var Symbol = __webpack_require__("7726").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "2d00":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "2d95":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "2fdb":
/***/ (function(module, exports, __webpack_require__) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__("5ca1");
var context = __webpack_require__("d2c8");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "32e9":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("86cc");
var createDesc = __webpack_require__("4630");
module.exports = __webpack_require__("9e1e") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "38fd":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("69a8");
var toObject = __webpack_require__("4bf8");
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "41a0":
/***/ (function(module, exports, __webpack_require__) {

var create = __webpack_require__("2aeb");
var descriptor = __webpack_require__("4630");
var setToStringTag = __webpack_require__("7f20");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "456d":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__("4bf8");
var $keys = __webpack_require__("0d58");

__webpack_require__("5eda")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "4588":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "4630":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "4bf8":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "5147":
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "520a":
/***/ (function(module, exports, __webpack_require__) {


var regexpFlags = __webpack_require__("0bfb");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "52a7":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "5537":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("8378");
var global = __webpack_require__("7726");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("2d00") ? 'pure' : 'global',
  copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "5ca1":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7726");
var core = __webpack_require__("8378");
var hide = __webpack_require__("32e9");
var redefine = __webpack_require__("2aba");
var ctx = __webpack_require__("9b43");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "5eda":
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__("5ca1");
var core = __webpack_require__("8378");
var fails = __webpack_require__("79e5");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "5f1b":
/***/ (function(module, exports, __webpack_require__) {


var classof = __webpack_require__("23c6");
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ "613b":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5537")('keys');
var uid = __webpack_require__("ca5a");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "626a":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("2d95");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "6762":
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__("5ca1");
var $includes = __webpack_require__("c366")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__("9c6c")('includes');


/***/ }),

/***/ "6821":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("626a");
var defined = __webpack_require__("be13");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "69a8":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "6a99":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("d3f4");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "7333":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__("0d58");
var gOPS = __webpack_require__("2621");
var pIE = __webpack_require__("52a7");
var toObject = __webpack_require__("4bf8");
var IObject = __webpack_require__("626a");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("79e5")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "7726":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "77f1":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("4588");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "79e5":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "7f20":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("86cc").f;
var has = __webpack_require__("69a8");
var TAG = __webpack_require__("2b4c")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "8378":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "84f2":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "86cc":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("cb7c");
var IE8_DOM_DEFINE = __webpack_require__("c69a");
var toPrimitive = __webpack_require__("6a99");
var dP = Object.defineProperty;

exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9b43":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("d8e8");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "9c6c":
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__("2b4c")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "9def":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("4588");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "9e1e":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("79e5")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "a352":
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_a352__;

/***/ }),

/***/ "a481":
/***/ (function(module, exports, __webpack_require__) {


var anObject = __webpack_require__("cb7c");
var toObject = __webpack_require__("4bf8");
var toLength = __webpack_require__("9def");
var toInteger = __webpack_require__("4588");
var advanceStringIndex = __webpack_require__("0390");
var regExpExec = __webpack_require__("5f1b");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__("214f")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "aae3":
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__("d3f4");
var cof = __webpack_require__("2d95");
var MATCH = __webpack_require__("2b4c")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "ac6a":
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__("cadf");
var getKeys = __webpack_require__("0d58");
var redefine = __webpack_require__("2aba");
var global = __webpack_require__("7726");
var hide = __webpack_require__("32e9");
var Iterators = __webpack_require__("84f2");
var wks = __webpack_require__("2b4c");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "b0c5":
/***/ (function(module, exports, __webpack_require__) {

var regexpExec = __webpack_require__("520a");
__webpack_require__("5ca1")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ "be13":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "c366":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("6821");
var toLength = __webpack_require__("9def");
var toAbsoluteIndex = __webpack_require__("77f1");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "c649":
/***/ (function(module, __webpack_exports__, __webpack_require__) {
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return insertNodeAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return console; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeNode; });
/* harmony import */ __webpack_require__("a481");


function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }

  return global.console;
}

var console = getConsole();

function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

var regex = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(regex, function (_, c) {
    return c ? c.toUpperCase() : "";
  });
});

function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}

function insertNodeAt(fatherNode, node, position) {
  var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")));

/***/ }),

/***/ "c69a":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function () {
  return Object.defineProperty(__webpack_require__("230e")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "ca5a":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "cadf":
/***/ (function(module, exports, __webpack_require__) {

var addToUnscopables = __webpack_require__("9c6c");
var step = __webpack_require__("d53b");
var Iterators = __webpack_require__("84f2");
var toIObject = __webpack_require__("6821");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__("01f9")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "cb7c":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("d3f4");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "ce10":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("69a8");
var toIObject = __webpack_require__("6821");
var arrayIndexOf = __webpack_require__("c366")(false);
var IE_PROTO = __webpack_require__("613b")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "d2c8":
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__("aae3");
var defined = __webpack_require__("be13");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "d3f4":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "d53b":
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "d8e8":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "e11e":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "f559":
/***/ (function(module, exports, __webpack_require__) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__("5ca1");
var toLength = __webpack_require__("9def");
var context = __webpack_require__("d2c8");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__("5147")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "f6fd":
/***/ (function(module, exports) {

// document.currentScript polyfill by Adam Miller

// MIT license

(function(document){
  var currentScript = "currentScript",
      scripts = document.getElementsByTagName('script'); // Live NodeList collection

  // If browser needs currentScript polyfill, add get currentScript() to the document object
  if (!(currentScript in document)) {
    Object.defineProperty(document, currentScript, {
      get: function(){

        // IE 6-10 supports script readyState
        // IE 10+ support stack trace
        try { throw new Error(); }
        catch (err) {

          // Find the second match for the "at" string to get file src url from stack.
          // Specifically works with the format of stack traces in IE.
          var i, res = ((/.*at [^\(]*\((.*):.+:.+\)$/ig).exec(err.stack) || [false])[1];

          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag
          for(i in scripts){
            if(scripts[i].src == res || scripts[i].readyState == "interactive"){
              return scripts[i];
            }
          }

          // If no match, return null
          return null;
        }
      }
    });
  }
})(document);


/***/ }),

/***/ "f751":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("5ca1");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("7333") });


/***/ }),

/***/ "fa5b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("5537")('native-function-to-string', Function.toString);


/***/ }),

/***/ "fab2":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("7726").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  {
    __webpack_require__("f6fd");
  }

  var setPublicPath_i;
  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
    __webpack_require__.p = setPublicPath_i[1]; // eslint-disable-line
  }
}

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.assign.js
__webpack_require__("f751");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.starts-with.js
__webpack_require__("f559");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js
__webpack_require__("ac6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.array.iterator.js
__webpack_require__("cadf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.object.keys.js
__webpack_require__("456d");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es7.array.includes.js
__webpack_require__("6762");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.string.includes.js
__webpack_require__("2fdb");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// EXTERNAL MODULE: external {"commonjs":"sortablejs","commonjs2":"sortablejs","amd":"sortablejs","root":"Sortable"}
var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);

// EXTERNAL MODULE: ./src/util/helper.js
var helper = __webpack_require__("c649");

// CONCATENATED MODULE: ./src/vuedraggable.js












function buildAttribute(object, propName, value) {
  if (value === undefined) {
    return object;
  }

  object = object || {};
  object[propName] = value;
  return object;
}

function computeVmIndex(vnodes, element) {
  return vnodes.map(function (elt) {
    return elt.elm;
  }).indexOf(element);
}

function _computeIndexes(slots, children, isTransition, footerOffset) {
  if (!slots) {
    return [];
  }

  var elmFromNodes = slots.map(function (elt) {
    return elt.elm;
  });
  var footerIndex = children.length - footerOffset;

  var rawIndexes = _toConsumableArray(children).map(function (elt, idx) {
    return idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt);
  });

  return isTransition ? rawIndexes.filter(function (ind) {
    return ind !== -1;
  }) : rawIndexes;
}

function emit(evtName, evtData) {
  var _this = this;

  this.$nextTick(function () {
    return _this.$emit(evtName.toLowerCase(), evtData);
  });
}

function delegateAndEmit(evtName) {
  var _this2 = this;

  return function (evtData) {
    if (_this2.realList !== null) {
      _this2["onDrag" + evtName](evtData);
    }

    emit.call(_this2, evtName, evtData);
  };
}

function isTransitionName(name) {
  return ["transition-group", "TransitionGroup"].includes(name);
}

function vuedraggable_isTransition(slots) {
  if (!slots || slots.length !== 1) {
    return false;
  }

  var _slots = _slicedToArray(slots, 1),
      componentOptions = _slots[0].componentOptions;

  if (!componentOptions) {
    return false;
  }

  return isTransitionName(componentOptions.tag);
}

function getSlot(slot, scopedSlot, key) {
  return slot[key] || (scopedSlot[key] ? scopedSlot[key]() : undefined);
}

function computeChildrenAndOffsets(children, slot, scopedSlot) {
  var headerOffset = 0;
  var footerOffset = 0;
  var header = getSlot(slot, scopedSlot, "header");

  if (header) {
    headerOffset = header.length;
    children = children ? [].concat(_toConsumableArray(header), _toConsumableArray(children)) : _toConsumableArray(header);
  }

  var footer = getSlot(slot, scopedSlot, "footer");

  if (footer) {
    footerOffset = footer.length;
    children = children ? [].concat(_toConsumableArray(children), _toConsumableArray(footer)) : _toConsumableArray(footer);
  }

  return {
    children: children,
    headerOffset: headerOffset,
    footerOffset: footerOffset
  };
}

function getComponentAttributes($attrs, componentData) {
  var attributes = null;

  var update = function update(name, value) {
    attributes = buildAttribute(attributes, name, value);
  };

  var attrs = Object.keys($attrs).filter(function (key) {
    return key === "id" || key.startsWith("data-");
  }).reduce(function (res, key) {
    res[key] = $attrs[key];
    return res;
  }, {});
  update("attrs", attrs);

  if (!componentData) {
    return attributes;
  }

  var on = componentData.on,
      props = componentData.props,
      componentDataAttrs = componentData.attrs;
  update("on", on);
  update("props", props);
  Object.assign(attributes.attrs, componentDataAttrs);
  return attributes;
}

var eventsListened = ["Start", "Add", "Remove", "Update", "End"];
var eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
var readonlyProperties = ["Move"].concat(eventsListened, eventsToEmit).map(function (evt) {
  return "on" + evt;
});
var draggingElement = null;
var props = {
  options: Object,
  list: {
    type: Array,
    required: false,
    default: null
  },
  value: {
    type: Array,
    required: false,
    default: null
  },
  noTransitionOnDrag: {
    type: Boolean,
    default: false
  },
  clone: {
    type: Function,
    default: function _default(original) {
      return original;
    }
  },
  element: {
    type: String,
    default: "div"
  },
  tag: {
    type: String,
    default: null
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
var draggableComponent = {
  name: "draggable",
  inheritAttrs: false,
  props: props,
  data: function data() {
    return {
      transitionMode: false,
      noneFunctionalComponentMode: false
    };
  },
  render: function render(h) {
    var slots = this.$slots.default;
    this.transitionMode = vuedraggable_isTransition(slots);

    var _computeChildrenAndOf = computeChildrenAndOffsets(slots, this.$slots, this.$scopedSlots),
        children = _computeChildrenAndOf.children,
        headerOffset = _computeChildrenAndOf.headerOffset,
        footerOffset = _computeChildrenAndOf.footerOffset;

    this.headerOffset = headerOffset;
    this.footerOffset = footerOffset;
    var attributes = getComponentAttributes(this.$attrs, this.componentData);
    return h(this.getTag(), attributes, children);
  },
  created: function created() {
    if (this.list !== null && this.value !== null) {
      helper["b" /* console */].error("Value and list props are mutually exclusive! Please set one or another.");
    }

    if (this.element !== "div") {
      helper["b" /* console */].warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props");
    }

    if (this.options !== undefined) {
      helper["b" /* console */].warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
    }
  },
  mounted: function mounted() {
    var _this3 = this;

    this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional();

    if (this.noneFunctionalComponentMode && this.transitionMode) {
      throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
    }

    var optionsAdded = {};
    eventsListened.forEach(function (elt) {
      optionsAdded["on" + elt] = delegateAndEmit.call(_this3, elt);
    });
    eventsToEmit.forEach(function (elt) {
      optionsAdded["on" + elt] = emit.bind(_this3, elt);
    });
    var attributes = Object.keys(this.$attrs).reduce(function (res, key) {
      res[Object(helper["a" /* camelize */])(key)] = _this3.$attrs[key];
      return res;
    }, {});
    var options = Object.assign({}, this.options, attributes, optionsAdded, {
      onMove: function onMove(evt, originalEvent) {
        return _this3.onDragMove(evt, originalEvent);
      }
    });
    !("draggable" in options) && (options.draggable = ">*");
    this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(this.rootContainer, options);
    this.computeIndexes();
  },
  beforeDestroy: function beforeDestroy() {
    if (this._sortable !== undefined) this._sortable.destroy();
  },
  computed: {
    rootContainer: function rootContainer() {
      return this.transitionMode ? this.$el.children[0] : this.$el;
    },
    realList: function realList() {
      return this.list ? this.list : this.value;
    }
  },
  watch: {
    options: {
      handler: function handler(newOptionValue) {
        this.updateOptions(newOptionValue);
      },
      deep: true
    },
    $attrs: {
      handler: function handler(newOptionValue) {
        this.updateOptions(newOptionValue);
      },
      deep: true
    },
    realList: function realList() {
      this.computeIndexes();
    }
  },
  methods: {
    getIsFunctional: function getIsFunctional() {
      var fnOptions = this._vnode.fnOptions;
      return fnOptions && fnOptions.functional;
    },
    getTag: function getTag() {
      return this.tag || this.element;
    },
    updateOptions: function updateOptions(newOptionValue) {
      for (var property in newOptionValue) {
        var value = Object(helper["a" /* camelize */])(property);

        if (readonlyProperties.indexOf(value) === -1) {
          this._sortable.option(value, newOptionValue[property]);
        }
      }
    },
    getChildrenNodes: function getChildrenNodes() {
      if (this.noneFunctionalComponentMode) {
        return this.$children[0].$slots.default;
      }

      var rawNodes = this.$slots.default;
      return this.transitionMode ? rawNodes[0].child.$slots.default : rawNodes;
    },
    computeIndexes: function computeIndexes() {
      var _this4 = this;

      this.$nextTick(function () {
        _this4.visibleIndexes = _computeIndexes(_this4.getChildrenNodes(), _this4.rootContainer.children, _this4.transitionMode, _this4.footerOffset);
      });
    },
    getUnderlyingVm: function getUnderlyingVm(htmlElt) {
      var index = computeVmIndex(this.getChildrenNodes() || [], htmlElt);

      if (index === -1) {
        //Edge case during move callback: related element might be
        //an element different from collection
        return null;
      }

      var element = this.realList[index];
      return {
        index: index,
        element: element
      };
    },
    getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(_ref) {
      var vue = _ref.__vue__;

      if (!vue || !vue.$options || !isTransitionName(vue.$options._componentTag)) {
        if (!("realList" in vue) && vue.$children.length === 1 && "realList" in vue.$children[0]) return vue.$children[0];
        return vue;
      }

      return vue.$parent;
    },
    emitChanges: function emitChanges(evt) {
      var _this5 = this;

      this.$nextTick(function () {
        _this5.$emit("change", evt);
      });
    },
    alterList: function alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }

      var newList = _toConsumableArray(this.value);

      onList(newList);
      this.$emit("input", newList);
    },
    spliceList: function spliceList() {
      var _arguments = arguments;

      var spliceList = function spliceList(list) {
        return list.splice.apply(list, _toConsumableArray(_arguments));
      };

      this.alterList(spliceList);
    },
    updatePosition: function updatePosition(oldIndex, newIndex) {
      var updatePosition = function updatePosition(list) {
        return list.splice(newIndex, 0, list.splice(oldIndex, 1)[0]);
      };

      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref2) {
      var to = _ref2.to,
          related = _ref2.related;
      var component = this.getUnderlyingPotencialDraggableComponent(to);

      if (!component) {
        return {
          component: component
        };
      }

      var list = component.realList;
      var context = {
        list: list,
        component: component
      };

      if (to !== related && list && component.getUnderlyingVm) {
        var destination = component.getUnderlyingVm(related);

        if (destination) {
          return Object.assign(destination, context);
        }
      }

      return context;
    },
    getVmIndex: function getVmIndex(domIndex) {
      var indexes = this.visibleIndexes;
      var numberIndexes = indexes.length;
      return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
    },
    getComponent: function getComponent() {
      return this.$slots.default[0].componentInstance;
    },
    resetTransitionData: function resetTransitionData(index) {
      if (!this.noTransitionOnDrag || !this.transitionMode) {
        return;
      }

      var nodes = this.getChildrenNodes();
      nodes[index].data = null;
      var transitionContainer = this.getComponent();
      transitionContainer.children = [];
      transitionContainer.kept = undefined;
    },
    onDragStart: function onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd: function onDragAdd(evt) {
      var element = evt.item._underlying_vm_;

      if (element === undefined) {
        return;
      }

      Object(helper["d" /* removeNode */])(evt.item);
      var newIndex = this.getVmIndex(evt.newIndex);
      this.spliceList(newIndex, 0, element);
      this.computeIndexes();
      var added = {
        element: element,
        newIndex: newIndex
      };
      this.emitChanges({
        added: added
      });
    },
    onDragRemove: function onDragRemove(evt) {
      Object(helper["c" /* insertNodeAt */])(this.rootContainer, evt.item, evt.oldIndex);

      if (evt.pullMode === "clone") {
        Object(helper["d" /* removeNode */])(evt.clone);
        return;
      }

      var oldIndex = this.context.index;
      this.spliceList(oldIndex, 1);
      var removed = {
        element: this.context.element,
        oldIndex: oldIndex
      };
      this.resetTransitionData(oldIndex);
      this.emitChanges({
        removed: removed
      });
    },
    onDragUpdate: function onDragUpdate(evt) {
      Object(helper["d" /* removeNode */])(evt.item);
      Object(helper["c" /* insertNodeAt */])(evt.from, evt.item, evt.oldIndex);
      var oldIndex = this.context.index;
      var newIndex = this.getVmIndex(evt.newIndex);
      this.updatePosition(oldIndex, newIndex);
      var moved = {
        element: this.context.element,
        oldIndex: oldIndex,
        newIndex: newIndex
      };
      this.emitChanges({
        moved: moved
      });
    },
    updateProperty: function updateProperty(evt, propertyName) {
      evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
    },
    computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }

      var domChildren = _toConsumableArray(evt.to.children).filter(function (el) {
        return el.style["display"] !== "none";
      });

      var currentDOMIndex = domChildren.indexOf(evt.related);
      var currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
      var draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove: function onDragMove(evt, originalEvent) {
      var onMove = this.move;

      if (!onMove || !this.realList) {
        return true;
      }

      var relatedContext = this.getRelatedContextFromMoveEvent(evt);
      var draggedContext = this.context;
      var futureIndex = this.computeFutureIndex(relatedContext, evt);
      Object.assign(draggedContext, {
        futureIndex: futureIndex
      });
      var sendEvt = Object.assign({}, evt, {
        relatedContext: relatedContext,
        draggedContext: draggedContext
      });
      return onMove(sendEvt, originalEvent);
    },
    onDragEnd: function onDragEnd() {
      this.computeIndexes();
      draggingElement = null;
    }
  }
};

if (typeof window !== "undefined" && "Vue" in window) {
  window.Vue.component("draggable", draggableComponent);
}

/* harmony default export */ var vuedraggable = (draggableComponent);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ __webpack_exports__["default"] = (vuedraggable);



/***/ })

/******/ })["default"];
});

});

var Draggable = unwrapExports(vuedraggable_umd);

function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$17 = {
  name: 'ui-draggable',
  components: {
    Draggable: Draggable
  },
  props: {
    keys: {
      type: Object,
      default: function _default() {
        return {
          value: 'value',
          label: 'label',
          disabled: 'disabled'
        };
      }
    },
    tag: {
      type: String,
      default: 'div'
    },
    componentData: {
      type: Object,
      default: null
    },
    group: {
      type: String,
      default: UUID.short('ui-draggable-')
    },
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return ['ui-draggable', {
        'is-grab': !this.disabled
      }, {
        'is-disabled': this.disabled
      }];
    }
  },

  /* methods: {
        /**
         * @param evt.draggedContext context linked to dragged element
            -- index: dragged element index
            -- element: dragged element underlying view model element
            -- futureIndex: potential index of the dragged element if the drop operation is accepted
         * @param evt.relatedContext context linked to current drag operation
            - index: target element index
            - element: target element view model element
            - list: target list
            - component: target VueComponent
        onMoveCallback(evt, originalEvent) {
            console.log(evt, originalEvent)
            return !evt.draggedContext.element.disabled;
        }
    }, */
  render: function render(h) {
    var _this = this;

    return h('draggable', {
      class: this.classes,
      attrs: _objectSpread$d(_objectSpread$d({
        animation: 200,
        ghostClass: 'ghost',
        filter: '.is-disabled'
      }, this.$props), this.$attrs),
      on: this.$listeners
    }, [this.$slots.header, this.$slots.footer].filter(Boolean).concat(this.value.map(function (item, index) {
      return _this.$scopedSlots.default ? _this.$scopedSlots.default({
        item: item,
        index: index
      }) : h('div', {
        staticClass: 'ui-draggable__item',
        class: {
          'is-disabled': _this.disabled || item[_this.keys.disabled]
        },
        key: item[_this.keys.value]
      }, item[_this.keys.label]);
    })));
  }
};

/* script */
var __vue_script__$17 = script$17;
/* template */

/* style */

var __vue_inject_styles__$17 = undefined;
/* scoped */

var __vue_scope_id__$17 = undefined;
/* module identifier */

var __vue_module_identifier__$17 = undefined;
/* functional template */

var __vue_is_functional_template__$17 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$17 = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$17, __vue_script__$17, __vue_scope_id__$17, __vue_is_functional_template__$17, __vue_module_identifier__$17, false, undefined, undefined, undefined);

var script$16 = {
  name: 'ui-drawer',
  components: {
    UiIcon: __vue_component__$1B,
    UiFocusContainer: __vue_component__$1f
  },
  props: {
    appendToBody: {
      type: Boolean,
      default: true
    },
    beforeClose: {
      type: Function
    },
    customClass: {
      type: String,
      default: ''
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    destroyOnClose: {
      type: Boolean,
      default: false
    },
    modal: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: 'rtl',
      validator: function validator(val) {
        return ['ltr', 'rtl', 'ttb', 'btt'].indexOf(val) !== -1;
      }
    },
    modalAppendToBody: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: '30%'
    },
    title: {
      type: String,
      default: ''
    },
    visible: {
      type: Boolean
    },
    wrapperClosable: {
      type: Boolean,
      default: true
    },
    withHeader: {
      type: Boolean,
      default: true
    },
    isFullMask: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    isHorizontal: function isHorizontal() {
      return this.direction === 'rtl' || this.direction === 'ltr';
    },
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, this.customClass, this.customClass), defineProperty$2(_ref, 'is-open', this.visible), defineProperty$2(_ref, "is-".concat(this.direction), this.direction), defineProperty$2(_ref, 'is-full-mask', this.isFullMask), _ref;
    }
  },
  data: function data() {
    return {
      closed: false,
      prevActiveElement: null
    };
  },
  watch: {
    visible: function visible(val) {
      var _this = this;

      if (val) {
        this.closed = false;
        this.$emit('open');

        if (this.appendToBody) {
          document.body.appendChild(this.$el);
        }

        this.prevActiveElement = document.activeElement;
      } else {
        if (!this.closed) this.$emit('close');
        this.$nextTick(function () {
          if (_this.prevActiveElement) {
            _this.prevActiveElement.focus();
          }
        });
      }

      if (this.isFullMask) {
        // äºä»¶å¹¿æ­
        EventHub.$emit('nui:fullMask', val);
      }
    }
  },
  methods: {
    afterEnter: function afterEnter() {
      this.$emit('opened');
    },
    afterLeave: function afterLeave() {
      this.$emit('closed');
    },
    hide: function hide(cancel) {
      if (cancel !== false) {
        this.$emit('update:visible', false);
        this.$emit('close');
        this.closed = true;
      }
    },
    handleWrapperClick: function handleWrapperClick() {
      if (this.wrapperClosable) {
        this.closeDrawer();
      }
    },
    closeDrawer: function closeDrawer() {
      if (typeof this.beforeClose === 'function') {
        this.beforeClose(this.hide);
      } else {
        this.hide();
      }
    },
    handleClose: function handleClose() {
      // This method here will be called by PopupManger, when the `closeOnPressEscape` was set to true
      // pressing `ESC` will call this method, and also close the drawer.
      // This method also calls `beforeClose` if there was one.
      this.closeDrawer();
    }
  },
  mounted: function mounted() {
    if (this.visible) {
      this.open();
    }
  },
  destroyed: function destroyed() {
    // if appendToBody is true, remove DOM node after destroy
    if (this.appendToBody && this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el);
    }
  }
};

/* script */
var __vue_script__$16 = script$16;
/* template */

var __vue_render__$$ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": "ui-drawer--fade"
    },
    on: {
      "after-enter": _vm.afterEnter,
      "after-leave": _vm.afterLeave
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.visible,
      expression: "visible"
    }],
    staticClass: "ui-drawer__wrapper",
    attrs: {
      "tabindex": "-1"
    }
  }, [_c('ui-focus-container', {
    staticClass: "ui-drawer__container",
    attrs: {
      "role": "document",
      "tabindex": "-1"
    },
    nativeOn: {
      "click": function click($event) {
        if ($event.target !== $event.currentTarget) {
          return null;
        }

        return _vm.handleWrapperClick($event);
      }
    }
  }, [_c('div', {
    ref: "drawer",
    staticClass: "ui-drawer",
    class: _vm.classes,
    style: _vm.isHorizontal ? "width: " + _vm.size : "height: " + _vm.size,
    attrs: {
      "aria-modal": "true",
      "aria-labelledby": "ui-drawer__title",
      "aria-label": _vm.title,
      "role": "dialog",
      "tabindex": "-1"
    }
  }, [_vm.withHeader ? _c('header', {
    staticClass: "ui-drawer__header",
    attrs: {
      "id": "ui-drawer__title"
    }
  }, [_vm._t("title", [_c('span', {
    attrs: {
      "role": "heading",
      "tabindex": "0",
      "title": _vm.title
    }
  }, [_vm._v(_vm._s(_vm.title))])]), _vm._v(" "), _vm.showClose ? _c('button', {
    staticClass: "ui-drawer__close-btn",
    attrs: {
      "aria-label": "close " + (_vm.title || 'drawer'),
      "type": "button"
    },
    on: {
      "click": _vm.closeDrawer
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "close"
    }
  })], 1) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _c('section', {
    staticClass: "ui-drawer__body"
  }, [_vm._t("default")], 2)])])], 1)]);
};

var __vue_staticRenderFns__$$ = [];
/* style */

var __vue_inject_styles__$16 = undefined;
/* scoped */

var __vue_scope_id__$16 = undefined;
/* module identifier */

var __vue_module_identifier__$16 = undefined;
/* functional template */

var __vue_is_functional_template__$16 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$16 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$$,
  staticRenderFns: __vue_staticRenderFns__$$
}, __vue_inject_styles__$16, __vue_script__$16, __vue_scope_id__$16, __vue_is_functional_template__$16, __vue_module_identifier__$16, false, undefined, undefined, undefined);

//
var script$15 = {
  name: 'ui-dropdown',
  props: {
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary'

    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    trigger: {
      type: String,
      default: 'click' // 'click', 'hover', 'focus'

    },
    hasArrow: {
      type: Boolean,
      default: false
    },
    dropdownPosition: {
      type: String,
      default: 'bottom-start'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    open: {
      type: Boolean,
      default: false
    },
    delay: {
      type: Object,
      default: function _default() {}
    }
  },
  computed: {
    classes: function classes() {
      return {
        'ui-dropdown': true
      };
    }
  },
  components: {
    VPopover: VPopover,
    UiButton: __vue_component__$1v
  },
  methods: {
    onDropdownOpen: function onDropdownOpen() {
      this.$emit('dropdown-open');
      this.$emit('open');
    },
    onDropdownClose: function onDropdownClose() {
      this.$emit('dropdown-close');
      this.$emit('close');
    }
  }
};

/* script */
var __vue_script__$15 = script$15;
/* template */

var __vue_render__$_ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('v-popover', {
    staticClass: "ui-dropdown",
    attrs: {
      "popover-class": "ui-dropdown__popover",
      "placement": _vm.dropdownPosition,
      "trigger": _vm.trigger,
      "open": _vm.open,
      "delay": _vm.delay
    },
    on: {
      "show": _vm.onDropdownOpen,
      "hide": _vm.onDropdownClose
    }
  }, [_vm._t("dropdown", null, {
    "slot": "popover"
  }), _vm._v(" "), _c('ui-button', _vm._b({}, 'ui-button', _vm.$props, false), [_vm._t("default"), _vm._v(" "), _vm.hasArrow ? _c('ui-icon', {
    staticClass: "ui-dropdown__icon",
    attrs: {
      "icon": "expand_more"
    }
  }) : _vm._e()], 2)], 2);
};

var __vue_staticRenderFns__$_ = [];
/* style */

var __vue_inject_styles__$15 = undefined;
/* scoped */

var __vue_scope_id__$15 = undefined;
/* module identifier */

var __vue_module_identifier__$15 = undefined;
/* functional template */

var __vue_is_functional_template__$15 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$15 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$_,
  staticRenderFns: __vue_staticRenderFns__$_
}, __vue_inject_styles__$15, __vue_script__$15, __vue_scope_id__$15, __vue_is_functional_template__$15, __vue_module_identifier__$15, false, undefined, undefined, undefined);

var script$14 = {
  name: 'UiUploadDrag',
  props: {
    accept: String,
    disabled: Boolean,
    width: {
      type: [String, Number],
      default: '100%'
    },
    height: {
      type: [String, Number],
      default: '100%'
    }
  },
  data: function data() {
    return {
      dragover: false
    };
  },
  computed: {
    classes: function classes() {
      return ['ui-upload-drag', {
        'is-disabled': this.disabled
      }, {
        'is-dragover': this.dragover
      }];
    },
    dragStyle: function dragStyle() {
      return {
        width: numToPx(this.width),
        height: numToPx(this.height)
      };
    }
  },
  methods: {
    onDragover: function onDragover() {
      if (!this.disabled) {
        this.dragover = true;
      }
    },
    onDrop: function onDrop(e) {
      var _this = this;

      if (this.disabled) return;
      this.dragover = false;

      if (!this.accept) {
        this.$emit('change', e.dataTransfer.files, e);
        return;
      }

      this.$emit('change', [].slice.call(e.dataTransfer.files).filter(function (file) {
        var type = file.type,
            name = file.name;
        var extension = name.indexOf('.') > -1 ? ".".concat(name.split('.').pop()) : '';
        var baseType = type.replace(/\/.*$/, '');
        return _this.accept.split(',').map(function (type) {
          return type.trim();
        }).filter(function (type) {
          return type;
        }).some(function (acceptedType) {
          if (/\..+$/.test(acceptedType)) {
            return extension === acceptedType;
          }

          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, '');
          }

          if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
            return type === acceptedType;
          }

          return false;
        });
      }), e);
    }
  }
};

/* script */
var __vue_script__$14 = script$14;
/* template */

var __vue_render__$Z = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes,
    style: _vm.dragStyle,
    on: {
      "drop": function drop($event) {
        $event.preventDefault();
        return _vm.onDrop($event);
      },
      "dragover": function dragover($event) {
        $event.preventDefault();
        return _vm.onDragover($event);
      },
      "dragleave": function dragleave($event) {
        $event.preventDefault();
        _vm.dragover = false;
      }
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$Z = [];
/* style */

var __vue_inject_styles__$14 = undefined;
/* scoped */

var __vue_scope_id__$14 = undefined;
/* module identifier */

var __vue_module_identifier__$14 = undefined;
/* functional template */

var __vue_is_functional_template__$14 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$14 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$Z,
  staticRenderFns: __vue_staticRenderFns__$Z
}, __vue_inject_styles__$14, __vue_script__$14, __vue_scope_id__$14, __vue_is_functional_template__$14, __vue_module_identifier__$14, false, undefined, undefined, undefined);

var script$13 = {
  name: 'ui-fileupload',
  components: {
    UiIcon: __vue_component__$1B,
    UiUploadDrag: __vue_component__$14,
    UiRippleInk: __vue_component__$1A
  },
  props: {
    name: {
      type: String,
      required: true
    },
    label: String,
    tabindex: [String, Number],

    /**
     * @name æ¯å¦å¯ææ½
     * @prop { boolean } drag
     */
    drag: Boolean,
    dragWidth: {
      type: [String, Number]
    },
    dragHeight: {
      type: [String, Number]
    },
    accept: String,
    multiple: {
      type: Boolean,
      default: false
    },
    required: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary'

    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    raised: {
      type: Boolean,
      default: false
    },
    iconPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    disableRipple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      hasSelection: false,
      hasMultiple: false,
      displayText: ''
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-fileupload--type-".concat(this.type), "ui-fileupload--color-".concat(this.color), "ui-fileupload--icon-position-".concat(this.iconPosition), "ui-fileupload--size-".concat(this.size), {
        'is-active': this.isActive
      }, {
        'is-multiple': this.hasMultiple
      }, {
        'is-raised': this.raised
      }, {
        'is-disabled': this.disabled
      }, {
        'is-drag': this.drag
      }, {
        'has-selection': this.hasSelection
      }];
    },
    placeholder: function placeholder() {
      if (this.label) {
        return this.label;
      }

      return this.multiple ? 'éæ©æä»¶' : 'éæ©æä»¶';
    }
  },
  methods: {
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    },
    onInput: function onInput(files, e) {
      this.$emit('input', files, e);
    },
    onChange: function onChange(files, e) {
      this.updateDisplayText(e);
      this.$emit('change', files, e);
    },
    updateDisplayText: function updateDisplayText(e) {
      var displayText;
      var input = this.$refs.input;

      if (input.files && input.files.length > 1) {
        displayText = "\u9009\u62E9\u4E86".concat(input.files.length, "\u4E2A\u6587\u4EF6");
      } else {
        displayText = e.target.value.split('\\').pop();
      }

      if (displayText) {
        this.hasSelection = true;
        this.displayText = displayText;
        this.hasMultiple = input.files.length > 1;
      }
    },
    focus: function focus() {
      this.$refs.input.focus();
    },
    openPicker: function openPicker() {
      this.$refs.input.click();
    },
    clear: function clear() {
      // Clear the file input by removing the element and re-rendering (via v-if)
      this.$refs.input.value = '';
      this.hasSelection = false;
      this.displayText = '';
      this.hasMultiple = false;
    }
  }
};

/* script */
var __vue_script__$13 = script$13;
/* template */

var __vue_render__$Y = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('label', {
    staticClass: "ui-fileupload",
    class: _vm.classes
  }, [_c('input', {
    ref: "input",
    staticClass: "ui-fileupload__input",
    attrs: {
      "type": "file",
      "accept": _vm.accept,
      "disabled": _vm.disabled,
      "multiple": _vm.multiple,
      "name": _vm.name,
      "required": _vm.required,
      "tabindex": _vm.tabindex
    },
    on: {
      "blur": _vm.onBlur,
      "input": function input($event) {
        return _vm.onInput($event.target.files, $event);
      },
      "change": function change($event) {
        return _vm.onChange($event.target.files, $event);
      },
      "focus": _vm.onFocus
    }
  }), _vm._v(" "), _c(_vm.drag ? 'ui-upload-drag' : 'div', {
    tag: "component",
    staticClass: "ui-fileupload__content",
    attrs: {
      "accept": _vm.accept,
      "disabled": _vm.disabled
    },
    on: {
      "input": _vm.onInput,
      "change": _vm.onChange
    }
  }, [_c('div', {
    staticClass: "ui-fileupload__icon"
  }, [_vm._t("icon", [_c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M5.016 18h13.969v2.016H5.016V18zM9 15.984v-6H5.016L12 3l6.984 6.984H15v6H9z"
    }
  })])])])], 2), _vm._v(" "), _vm.hasSelection ? _c('span', {
    staticClass: "ui-fileupload__display-text"
  }, [_vm._v(_vm._s(_vm.displayText))]) : _vm._t("default", [_vm._v(_vm._s(_vm.placeholder))])], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-fileupload__focus-ring"
  }), _vm._v(" "), !_vm.disableRipple && !_vm.disabled ? _c('ui-ripple-ink') : _vm._e()], 1);
};

var __vue_staticRenderFns__$Y = [];
/* style */

var __vue_inject_styles__$13 = undefined;
/* scoped */

var __vue_scope_id__$13 = undefined;
/* module identifier */

var __vue_module_identifier__$13 = undefined;
/* functional template */

var __vue_is_functional_template__$13 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$13 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$Y,
  staticRenderFns: __vue_staticRenderFns__$Y
}, __vue_inject_styles__$13, __vue_script__$13, __vue_scope_id__$13, __vue_is_functional_template__$13, __vue_module_identifier__$13, false, undefined, undefined, undefined);

//
//
//
//
//
//
var script$12 = {
  name: 'ui-footer',
  componentName: 'UiFooter',
  props: {
    height: {
      type: String,
      default: '48px'
    }
  }
};

/* script */
var __vue_script__$12 = script$12;
/* template */

var __vue_render__$X = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('footer', {
    staticClass: "ui-footer",
    style: {
      height: _vm.height
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$X = [];
/* style */

var __vue_inject_styles__$12 = undefined;
/* scoped */

var __vue_scope_id__$12 = undefined;
/* module identifier */

var __vue_module_identifier__$12 = undefined;
/* functional template */

var __vue_is_functional_template__$12 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$12 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$X,
  staticRenderFns: __vue_staticRenderFns__$X
}, __vue_inject_styles__$12, __vue_script__$12, __vue_scope_id__$12, __vue_is_functional_template__$12, __vue_module_identifier__$12, false, undefined, undefined, undefined);

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var regenerator = runtime_1;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var asyncToGenerator = _asyncToGenerator;

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

_export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = _stringContext(this, searchString, STARTS_WITH);
    var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
var EXPIRY_TIME = 1000 * 60 * 60 * 24; // 1 day

var script$11 = {
  name: 'ui-form',
  provide: function provide() {
    return {
      UiForm: this
    };
  },
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    required: Boolean,
    disabled: Boolean,
    auto: Boolean,
    labelWidth: [Number, String],
    align: {
      type: String,
      default: 'center' // top or bottom

    },
    col: {
      type: [Number, String],
      default: ''
    },
    rules: {
      type: [String, Array, Function],
      default: null
    },
    //èªå¨ä¿å­å¯ä¸id
    autoSaveId: {
      type: String,
      default: ''
    },
    //è¡¨åç»å®çkey
    autoSaveKey: {
      type: Object,
      default: function _default() {}
    }
  },
  data: function data() {
    return {
      fields: [],
      ERROR_CLASS: 'is-error',
      LABEL_CLASS: 'ui-form-item__label',
      ERROR_TIP_CLASS: 'ui-form-item__error',
      errorText: ''
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.getAllLocalStorage();
    var localStorageForm = this.getLocalStorage();

    if (localStorageForm) {
      NUI.$confirm('æ£æµå°æ¨æç¼è¾è®°å½ï¼æ¯å¦ç»§ç»­ä¸æ¬¡çç¼è¾ï¼', 'æç¤º').then(function () {
        _this.$emit('update-autosave', localStorageForm.data);
      }).catch(function () {
        _this.delStorageFromAutosave();
      });
    }
  },
  computed: {
    localStorageKey: function localStorageKey() {
      return "autoSaveForm_kkkplat_".concat(this.autoSaveId);
    }
  },
  watch: {
    autoSaveKey: {
      handler: function handler(val) {
        this.emitAutoSaveForm(val);
      },
      deep: true
    }
  },
  methods: {
    setLocalStorage: function setLocalStorage(data) {
      var now = new Date();
      var item = {
        data: data,
        expiry: now.getTime() + EXPIRY_TIME
      };
      localStorage.setItem(this.localStorageKey, JSON.stringify(item));
    },
    getAllLocalStorage: function getAllLocalStorage() {
      for (var i = 0; i < window.localStorage.length; i++) {
        var key = localStorage.key(i);
        var prefix = 'autoSaveForm_kkkplat';
        var isStartsWith = key.startsWith(prefix);

        if (isStartsWith) {
          var value = localStorage.getItem(key);
          var item = JSON.parse(value);
          var now = new Date();

          if (now.getTime() > item.expiry) {
            localStorage.removeItem(key);
            return null;
          }
        }
      }
    },
    getLocalStorage: function getLocalStorage() {
      return JSON.parse(localStorage.getItem(this.localStorageKey));
    },
    delStorageFromAutosave: function delStorageFromAutosave() {
      localStorage.removeItem(this.localStorageKey);
    },
    isEmptyObject: function isEmptyObject(obj) {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          return false;
        }
      }

      return true;
    },
    emitAutoSaveForm: function emitAutoSaveForm(data) {
      if (this.isEmptyObject(data)) return;
      this.setLocalStorage(data);
    },
    validate: function validate() {
      var _this2 = this;

      if (this.fields.length === 0) {
        console.warn('fields is empty');
        return;
      }

      this.$nextTick(function () {
        _this2.checkFieldsForErrors();
      });
      return this.fields.filter(function (field) {
        return field.validate();
      }).length === this.fields.length;
    },
    checkFieldsForErrors: function checkFieldsForErrors() {
      var _this3 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var errors, _iterator, _step, field;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                errors = [];
                _iterator = _createForOfIteratorHelper$2(_this3.fields);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    field = _step.value;

                    if (typeof field.validate !== 'function' || !field.validate()) {
                      console.warn('Field validation failed:', field);
                      errors.push(field);
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                if (!(errors.length > 0)) {
                  _context.next = 7;
                  break;
                }

                _context.next = 6;
                return _this3.scrollErrorsIntoView(errors);

              case 6:
                _this3.showErrorMessage(errors);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    scrollErrorsIntoView: function scrollErrorsIntoView(errors) {
      var el = errors[0].$el;

      if (el) {
        el.scrollIntoView({
          behavior: 'smooth',
          block: 'start',
          inline: 'nearest'
        });
      }
    },
    showErrorMessage: function showErrorMessage(errors) {
      var _this4 = this;

      var errorTexts = errors.map(function (error) {
        var errorLabel = error.$el.querySelector(".".concat(_this4.LABEL_CLASS));
        var errorTip = error.$el.querySelector(".".concat(_this4.ERROR_TIP_CLASS));

        if (errorLabel && errorTip) {
          return errorLabel.innerText == '' ? errorTip.innerText : "\u3010".concat(errorLabel.innerText, "\u3011").concat(errorTip.innerText);
        } else {
          return '';
        }
      });

      if (errorTexts.length > 0) {
        var errorLabelEle = errors[0].$el.querySelector(".".concat(this.LABEL_CLASS));
        var groupEle = this.getParentsWithClass(errorLabelEle, 'ui-form-item-group');
        var groupLabel = '';
        groupEle.reverse().forEach(function (item) {
          var label = item.getAttribute('group-label');

          if (label && label != '') {
            groupLabel += label + '->';
          }
        });
        this.$toast.error("".concat(groupLabel).concat(errorTexts[0], "\uFF08\u6821\u9A8C\u5931\u8D25\u603B\u6570\uFF1A").concat(errors.length, "\u6761\uFF09"));
      }
    },
    getParentsWithClass: function getParentsWithClass(element, className) {
      var parents = [];
      var parent = element.parentNode; // éå½å½æ°æ¥æ£æ¥æ¯ä¸ªç¶åç´ 

      function checkParent(p) {
        // å¦æç¶åç´ å­å¨ä¸åå«æå®ç±»å
        if (p && p.classList && p.classList.contains(className)) {
          parents.push(p); // å°ç¶åç´ æ·»å å°æ°ç»ä¸­
        } // éå½è°ç¨ï¼ç»§ç»­æ£æ¥æ´ä¸ä¸çº§çç¶åç´ 


        if (p && p.parentNode) {
          checkParent(p.parentNode);
        }
      } // ä»æä¾çåç´ å¼å§æ£æ¥


      checkParent(parent);
      return parents;
    },
    validateField: function validateField(field) {
      return field.validate();
    },

    /* resetFields() {
            this.fields.forEach(field => field.resetField());
        }, */
    clearValidate: function clearValidate() {
      this.fields.forEach(function (field) {
        return field.clearValidate();
      });
    },
    addItem: function addItem(field) {
      this.fields.push(field);
    },
    removeItem: function removeItem(field) {
      this.fields.splice(this.fields.indexOf(field), 1);
    }
  }
};

/* script */
var __vue_script__$11 = script$11;
/* template */

var __vue_render__$W = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c(_vm.tag, {
    tag: "component",
    staticClass: "ui-form",
    class: {
      'is-disabled': _vm.disabled
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$W = [];
/* style */

var __vue_inject_styles__$11 = undefined;
/* scoped */

var __vue_scope_id__$11 = undefined;
/* module identifier */

var __vue_module_identifier__$11 = undefined;
/* functional template */

var __vue_is_functional_template__$11 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$11 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$W,
  staticRenderFns: __vue_staticRenderFns__$W
}, __vue_inject_styles__$11, __vue_script__$11, __vue_scope_id__$11, __vue_is_functional_template__$11, __vue_module_identifier__$11, false, undefined, undefined, undefined);

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var RULES = {
  required: {
    message: 'ä¸è½ä¸ºç©º',
    validator: function validator(val) {
      return '' !== val && null !== val && 'undefined' !== typeof val;
    }
  },
  email: {
    message: 'è¯·è¾å¥æ­£ç¡®çé®ç®±å°å',
    validator: function validator(val) {
      return /^(\w-*\.*)+@(\w-?)+(\.\w{2,})+$/.test(val);
    }
  },
  phone: {
    message: 'è¯·è¾å¥æ­£ç¡®çææºå·ç ',
    validator: function validator(val) {
      return /^[1][0-9]{10}$/.test(val);
    }
  },
  int: {
    message: 'åªå¯è¾å¥æ´æ°',
    validator: function validator(val) {
      return /^(\+|-)?[\d]+$/.test(val);
    }
  },
  number: {
    message: 'åªå¯è¾å¥æ°å­',
    validator: function validator(val) {
      return /^(\+|-)?\d+($|\.\d+$)/.test(val);
    }
  },
  min: {
    message: 'æ°å¼ä¸è½å°äº{0}',
    validator: function validator(val, n) {
      return +val >= +n;
    }
  },
  max: {
    message: 'æ°å¼ä¸è½å¤§äº{0}',
    validator: function validator(val, n) {
      return +val <= +n;
    }
  },
  range: {
    message: 'æ°å¼èå´å¿é¡»å¨{0}~{1}',
    validator: function validator(val, m, n) {
      return +val >= +m && +val <= +n;
    }
  },
  minlength: {
    message: 'ä¸è½å°äº{0}ä¸ªå­ç¬¦',
    validator: function validator(val, n) {
      return String(val).length >= +n;
    }
  },
  maxlength: {
    message: 'ä¸è½å¤§äº{0}ä¸ªå­ç¬¦',
    validator: function validator(val, n) {
      return String(val).length <= +n;
    }
  },
  regex: {
    message: 'è¯·è¾å¥æ­£ç¡®çæ ¼å¼',
    validator: function validator(val) {
      var r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return new RegExp(r).test(val);
    }
  }
};
var script$10 = {
  name: 'ui-form-item',
  componentName: 'UiFormItem',
  inject: ['UiForm'],
  props: {
    label: String,
    required: Boolean,
    disabled: Boolean,
    labelWidth: [Number, String],
    align: {
      type: String,
      default: '' // top or bottom

    },
    col: {
      type: [Number, String],
      default: ''
    },
    rules: {
      type: [String, Array, Function],
      default: null
    }
  },
  data: function data() {
    return {
      initValue: '',
      validateValue: '',
      validateMessage: '',
      validateState: '',
      validateElm: null
    };
  },
  computed: {
    form: function form() {
      return this.UiForm || {};
    },
    formAlign: function formAlign() {
      return this.align || this.form.align;
    },
    formCol: function formCol() {
      return this.col || this.form.col;
    },
    isDisabled: function isDisabled() {
      return this.disabled || this.form.disabled;
    },
    isRequired: function isRequired() {
      return this.getRules().some(function (r) {
        return 'required' === r || 'required' === r.validator;
      });
    },
    labelStyle: function labelStyle() {
      var labelWidth = this.labelWidth || this.form.labelWidth;
      return labelWidth ? {
        width: isNaN(Number(labelWidth)) ? labelWidth : "".concat(labelWidth, "px")
      } : {};
    }
  },
  watch: {
    validateValue: function validateValue() {
      if (this.validateState == 'validating' || this.form.auto) {
        this.validate();
      }
    }
  },
  mounted: function mounted() {
    this.UiForm.addItem(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.UiForm.removeItem(this);
  },
  methods: {
    _addControl: function _addControl(el) {
      this.validateElm = el;
    },
    _removeControl: function _removeControl() {
      this.validateElm = null;
    },
    _updateValue: function _updateValue(val) {
      if (val === this.validator && this.validateState != 'validating' || val === this.validateValue && this.validateState == 'validating' && this.form.auto) {
        // å½å¼ç¸ç­æ¯ï¼å¦æè¿æªæ£æ¥è¿æèç¶æä¸ºæ ¡éªä¸­ï¼ä¸æ¯èªå¨æ£æ¥ï¼åéè¦æ£æ¥ä¸é
        this.validate();
      }

      this.validateValue = val;

      if (Array.isArray(this.validateValue) && this.validateValue.length == 0) {
        this.clearValidate();
        this.validate();
      }
    },
    validate: function validate() {
      // å¦ææçå¬èï¼æéè¦æ ¡éª
      if (!this.validateElm) return true;
      this.validateState = 'validating';
      var rules = this.getRules();

      if (rules.length > 0) {
        var _iterator = _createForOfIteratorHelper$1(rules),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var r = _step.value;
            var message = void 0,
                validator = void 0;

            if ('function' === typeof r) {
              this.validateMessage = r(this.validateValue);
              if (this.validateMessage) return false;else continue;
            } else if ('string' === typeof r) {
              ;

              var _this$getExpression = this.getExpression(r);

              var _this$getExpression2 = slicedToArray(_this$getExpression, 2);

              message = _this$getExpression2[0];
              validator = _this$getExpression2[1];
            } else if ('string' === typeof r.validator) {
              ;

              var _this$getExpression3 = this.getExpression(r.validator, r.message);

              var _this$getExpression4 = slicedToArray(_this$getExpression3, 2);

              message = _this$getExpression4[0];
              validator = _this$getExpression4[1];
            } else if ('function' === typeof r.validator) {
              ;
              var _ref = [r.message, r.validator];
              message = _ref[0];
              validator = _ref[1];
            } else {
              continue;
            }

            if (validator === 'unknow') continue;

            if (!validator(this.validateValue)) {
              this.validateMessage = message;
              return false;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      this.validateMessage = '';
      return true;
    },

    /* resetField() {
            this.validateValue = this.initValue;
        }, */
    clearValidate: function clearValidate() {
      this.validateValue = '';
      this.validateState = '';
      this.validateMessage = '';
    },
    getRules: function getRules() {
      var requiredRule = this.required || this.form.required ? {
        message: RULES.required.message,
        validator: 'required'
      } : [];
      var selfRules = this.transformRules(this.rules);
      var formRules = this.transformRules(this.form.rules);
      return [].concat(selfRules || formRules || []).concat(requiredRule);
    },
    getExpression: function getExpression(expression) {
      var defaultMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var _$exec = /^([^\(]*)(\(([^\)]*)\))?$/.exec(expression),
          _$exec2 = slicedToArray(_$exec, 4),
          name = _$exec2[1],
          _$exec2$ = _$exec2[3],
          params = _$exec2$ === void 0 ? '' : _$exec2$; // æå¡ç«¯è¦æ±å¦æä¸å­å¨name åè·³è¿æ ¡éªï¼éªæä½ï¼
      // if (!RULES[name]) throw `UiFormItemä¸å­å¨[${name}]åç½®æ¹æ³`


      if (!RULES[name]) return ['unknow', 'unknow'];
      params = Function.prototype.constructor("return [".concat(params, "].concat(0,256)"))(); // å° '1, 2, 3' => [1,2,3] å¹¶å»æç©ºæ ¼

      var validator = function validator(val) {
        var _RULES$name;

        return (_RULES$name = RULES[name]).validator.apply(_RULES$name, [val].concat(toConsumableArray(params)));
      };

      var message = (defaultMsg || RULES[name].message).replace(/\{([\d]+)\}/g, function (a, b) {
        return params[b];
      });
      return [message, validator];
    },
    transformRules: function transformRules(rules) {
      if (!rules) return;
      if ('string' === typeof rules) return rules.split('|');
      return [].concat(rules);
    }
  }
};

/* script */
var __vue_script__$10 = script$10;
/* template */

var __vue_render__$V = function __vue_render__() {
  var _obj;

  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-form-item ui-grid-cell",
    class: (_obj = {}, _obj["col-" + _vm.formCol] = _vm.formCol, _obj["is-align-" + _vm.formAlign] = _vm.formAlign, _obj['is-required'] = _vm.isRequired, _obj['is-disabled'] = _vm.isDisabled, _obj['is-error'] = !_vm.isDisabled && _vm.validateMessage, _obj)
  }, [_vm.label || _vm.$slots.label ? _c('label', {
    staticClass: "ui-form-item__label",
    style: _vm.labelStyle
  }, [_vm._t("label", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-form-item__control"
  }, [_vm._t("default"), _vm._v(" "), _vm.validateMessage ? _c('span', {
    staticClass: "ui-form-item__error"
  }, [_vm._v(_vm._s(_vm.validateMessage))]) : _vm._e()], 2)]);
};

var __vue_staticRenderFns__$V = [];
/* style */

var __vue_inject_styles__$10 = undefined;
/* scoped */

var __vue_scope_id__$10 = undefined;
/* module identifier */

var __vue_module_identifier__$10 = undefined;
/* functional template */

var __vue_is_functional_template__$10 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$10 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$V,
  staticRenderFns: __vue_staticRenderFns__$V
}, __vue_inject_styles__$10, __vue_script__$10, __vue_scope_id__$10, __vue_is_functional_template__$10, __vue_module_identifier__$10, false, undefined, undefined, undefined);

//
//
//
//
//
//
var script$$ = {
  name: 'ui-form-item-group',
  componentName: 'UiFormItemGroup',
  inject: ['UiForm'],
  props: {
    label: String
  }
};

/* script */
var __vue_script__$$ = script$$;
/* template */

var __vue_render__$U = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-form-item-group ui-grid-cell",
    attrs: {
      "group-label": _vm.label
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$U = [];
/* style */

var __vue_inject_styles__$$ = undefined;
/* scoped */

var __vue_scope_id__$$ = "data-v-5a77783e";
/* module identifier */

var __vue_module_identifier__$$ = undefined;
/* functional template */

var __vue_is_functional_template__$$ = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$$ = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$U,
  staticRenderFns: __vue_staticRenderFns__$U
}, __vue_inject_styles__$$, __vue_script__$$, __vue_scope_id__$$, __vue_is_functional_template__$$, __vue_module_identifier__$$, false, undefined, undefined, undefined);

//
//
//
//
//
//
var script$_ = {
  name: 'ui-header',
  componentName: 'UiHeader',
  props: {
    height: {
      type: String,
      default: '48px'
    }
  }
};

/* script */
var __vue_script__$_ = script$_;
/* template */

var __vue_render__$T = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('header', {
    staticClass: "ui-header",
    style: {
      height: _vm.height
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$T = [];
/* style */

var __vue_inject_styles__$_ = undefined;
/* scoped */

var __vue_scope_id__$_ = undefined;
/* module identifier */

var __vue_module_identifier__$_ = undefined;
/* functional template */

var __vue_is_functional_template__$_ = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$_ = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$T,
  staticRenderFns: __vue_staticRenderFns__$T
}, __vue_inject_styles__$_, __vue_script__$_, __vue_scope_id__$_, __vue_is_functional_template__$_, __vue_module_identifier__$_, false, undefined, undefined, undefined);

var _stringRepeat = function repeat(count) {
  var str = String(_defined(this));
  var res = '';
  var n = _toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

_export(_export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: _stringRepeat
});

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$Z = {
  name: 'ui-input-number',
  props: {
    placeholder: String,
    value: {
      type: [Number, String],
      default: ''
    },
    step: {
      type: Number,
      default: 1
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {};
  },
  methods: {
    onInput: function onInput(e) {
      var value = Number(e.target.value);

      if (isNaN(value)) {
        e.target.value = this.value;
        return;
      } else if (value < this.min) {
        e.target.value = this.min;
      } else if (value > this.max) {
        e.target.value = this.max;
      }

      this.update(e.target.value);
    },

    /**@param {KeyboardEvent} e */
    onKeyDown: function onKeyDown(e) {
      {
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          !e.repeat && this.autoUpdate();
        }
      }

      {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          !e.repeat && this.autoUpdate(-1);
        }
      }
    },

    /**@param {KeyboardEvent} e */
    onKeyUp: function onKeyUp(e) {
      clearTimeout(this.timeout);
      /**@type {HTMLInputElement} */

      var inp = e.target;

      handle_sub: {
        if (e.key !== '-') {
          break handle_sub;
        }

        if (e.target.value && e.target.value !== '0') {
          break handle_sub;
        }

        e.preventDefault();
        inp.value = '-0';
        inp.setSelectionRange(1, 2);
      }

      handle_rm: {
        if (e.key !== 'Backspace') {
          break handle_rm;
        }

        if (/^-\d$/.test(inp.value)) {
          inp.value = '-0';
          inp.setSelectionRange(1, 2);
        }
      }
    },
    onMouseDown: function onMouseDown() {
      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.autoUpdate(i);
    },
    onMouseUp: function onMouseUp() {
      clearTimeout(this.timeout);
    },

    /**@param {WheelEvent} e*/
    onWheel: function onWheel(e) {
      if (e.deltaY === 0) {
        return;
      }

      e.preventDefault();
      var i = e.deltaY / Math.abs(e.deltaY);
      var value = Number(this.value);
      var len = (String(value).split('.')[1] || []).length;
      value += i * this.step;
      this.update(value.toFixed(len));
    },
    onBlur: function onBlur(e) {
      e.target.value = this.value;
      this.$emit('change', this.value);
    },
    autoUpdate: function autoUpdate() {
      var _this = this;

      var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var handle = function handle(i) {
        // clearTimeout(this.timeout)
        var value = _this.calculate(Number(_this.value), _this.step, i);

        _this.update(value); // this.timeout = setTimeout(() => {
        //   t -= 50
        //   if (t < 16) t = 16
        //   handle(i)
        // }, t)

      };

      handle(i);
    },
    getPosition: function getPosition(value) {
      var valueString = value.toString();
      var dotPosition = valueString.indexOf('.');
      var precision = 0;

      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }

      return precision;
    },
    calculate: function calculate(value, step, sign) {
      var valuePosition = this.getPosition(value);
      var stepPosition = this.getPosition(step);
      var precisionFactor = Math.pow(10, Math.max(valuePosition, stepPosition));
      return (Math.round(value * precisionFactor) + Math.round(sign * step * precisionFactor)) / precisionFactor;
    },
    update: function update(value) {
      value = parseFloat(value || 0);

      if (value < this.min) {
        value = this.min;
      } else if (value > this.max) {
        value = this.max;
      }

      this.$emit('input', value);
    }
  }
};

/* script */
var __vue_script__$Z = script$Z;
/* template */

var __vue_render__$S = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-input-number",
    class: {
      'is-disabled': _vm.disabled
    }
  }, [_vm._t("before"), _vm._v(" "), _c('div', {
    staticClass: "ui-input-number__warp"
  }, [_c('input', {
    staticClass: "ui-input-number__input",
    attrs: {
      "type": "text",
      "disabled": _vm.disabled
    },
    domProps: {
      "value": _vm.value
    },
    on: {
      "input": _vm.onInput,
      "keydown": _vm.onKeyDown,
      "keyup": _vm.onKeyUp,
      "mousewheel": _vm.onWheel,
      "blur": _vm.onBlur
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "ui-input-number__btns"
  }, [_c('button', {
    staticClass: "ui-input-number__btn-add",
    attrs: {
      "disabled": _vm.disabled || _vm.value >= _vm.max
    },
    on: {
      "mousedown": function mousedown($event) {
        return _vm.onMouseDown();
      },
      "mouseup": function mouseup($event) {
        return _vm.onMouseUp();
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "expand_less"
    }
  })], 1), _vm._v(" "), _c('button', {
    staticClass: "ui-input-number__btn-sub",
    attrs: {
      "disabled": _vm.disabled || _vm.value <= _vm.min
    },
    on: {
      "mousedown": function mousedown($event) {
        return _vm.onMouseDown(-1);
      },
      "mouseup": function mouseup($event) {
        return _vm.onMouseUp(-1);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "expand_more"
    }
  })], 1)]), _vm._v(" "), _vm._t("after")], 2);
};

var __vue_staticRenderFns__$S = [];
/* style */

var __vue_inject_styles__$Z = undefined;
/* scoped */

var __vue_scope_id__$Z = undefined;
/* module identifier */

var __vue_module_identifier__$Z = undefined;
/* functional template */

var __vue_is_functional_template__$Z = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$Z = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$S,
  staticRenderFns: __vue_staticRenderFns__$S
}, __vue_inject_styles__$Z, __vue_script__$Z, __vue_scope_id__$Z, __vue_is_functional_template__$Z, __vue_module_identifier__$Z, false, undefined, undefined, undefined);

//
//
//
//
//
//
var script$Y = {
  name: 'ui-main',
  componentName: 'UiMain'
};

/* script */
var __vue_script__$Y = script$Y;
/* template */

var __vue_render__$R = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('main', {
    staticClass: "ui-main"
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$R = [];
/* style */

var __vue_inject_styles__$Y = undefined;
/* scoped */

var __vue_scope_id__$Y = undefined;
/* module identifier */

var __vue_module_identifier__$Y = undefined;
/* functional template */

var __vue_is_functional_template__$Y = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$Y = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$R,
  staticRenderFns: __vue_staticRenderFns__$R
}, __vue_inject_styles__$Y, __vue_script__$Y, __vue_scope_id__$Y, __vue_is_functional_template__$Y, __vue_module_identifier__$Y, false, undefined, undefined, undefined);

// https://github.com/tc39/proposal-string-pad-start-end




var _stringPad = function (that, maxLength, fillString, left) {
  var S = String(_defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = _toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

// https://github.com/tc39/proposal-string-pad-start-end




// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(_userAgent);

_export(_export.P + _export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var createFileSvg = function createFileSvg() {
  var ext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '?';
  var bgColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#000';
  var txtColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#fff';
  return 'data:image/svg+xml;base64,' + btoa("<svg width=\"1024\" height=\"1024\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path fill=\"".concat(bgColor, "\" d=\"m354.40128,0c-87.04,0 -157.44,70.55872 -157.44,157.59872l0,275.68128l-118.24128,0c-21.6576,0 -39.36256,17.69984 -39.36256,39.36256l0,236.31872c0,21.6576 17.69984,39.35744 39.36256,39.35744l118.24128,0l0,118.08256c0,87.04 70.4,157.59872 157.44,157.59872l472.63744,0c87.04,0 157.59872,-70.55872 157.59872,-157.59872l0,-551.36768c0,-41.74848 -38.9888,-81.93024 -107.52,-149.27872l-29.11744,-29.12256l-29.12256,-29.11232c-67.33824,-68.5312 -107.48416,-107.52 -149.27872,-107.52l-315.19232,0l-0.00512,0zm0.00512,78.72l287.20128,0c28.35456,7.0912 27.99616,42.1376 27.99616,76.8l0,120.16128c0,21.6576 17.69984,39.35744 39.36256,39.35744l118.07744,0c39.38816,0 78.87872,-0.0256 78.87872,39.36256l0,512c0,43.32032 -35.55328,78.87872 -78.87872,78.87872l-472.63744,0c-43.32544,0 -78.72,-35.5584 -78.72,-78.87872l0,-118.08256l393.91744,0c21.66272,0 39.36256,-17.69472 39.36256,-39.35744l0,-236.31872c0,-21.66272 -17.69984,-39.36256 -39.36256,-39.36256l-393.92256,0l0,-275.68128c0,-43.32032 35.39456,-78.87872 78.72,-78.87872l0.00512,0z\"/>\n      <text font-size=\"250\" x=\"376\" y=\"610\" fill=\"").concat(txtColor, "\" text-anchor=\"middle\" dominant-baseline=\"middle\">").concat(ext, "</text>\n    </svg>").replace(/>\s+</g, '><'));
};

var createLinkSvg = function createLinkSvg() {
  var bgColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#ddd';
  return 'data:image/svg+xml;base64,' + btoa("<svg class=\"icon\" style=\"vertical-align: middle;fill: ".concat(bgColor, ";overflow: hidden;\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1792\"><path d=\"M618.24 439.381333a152.746667 152.746667 0 0 1 0 216l-135.893333 135.893334a163.370667 163.370667 0 1 1-231.04-231.04l66.922666-66.944 45.269334 45.269333-66.944 66.944a99.370667 99.370667 0 1 0 140.522666 140.522667l135.893334-135.893334a88.746667 88.746667 0 0 0 0-125.482666z m182.528-197.589333a163.370667 163.370667 0 0 1 0 231.04L733.866667 539.776l-45.269334-45.248 66.944-66.944a99.370667 99.370667 0 1 0-140.522666-140.522667l-135.893334 135.893334a88.746667 88.746667 0 0 0 0 125.482666l-45.269333 45.269334a152.746667 152.746667 0 0 1 0-216l135.893333-135.893334a163.370667 163.370667 0 0 1 231.04 0z\" p-id=\"1793\"></path></svg>"));
};

var script$X = {
  name: 'ui-media',
  components: {
    VPopover: VPopover
  },
  props: {
    /**
     * @name åªä½ç±»å
     * @property {String} type
     * @option unknow - æªç¥ï¼ä¼ä»¥ä¸ä¸ªæä»¶iconå±ç¤º
     * @option img - å¾çï¼å±ç¤ºä¸ºå¾ç
     * @option video - è§é¢ï¼å±ç¤ºä¸ºè§é¢
     * @option carousel - å¾çè½®æ­ï¼å±ç¤ºä¸ºå¾çè½®æ­
     */
    type: {
      type: String,
      default: 'unknow' // unknow | img | video | carousel

    },
    // æªç¥åªä½ç±»åæ¾ç¤ºçicon file|link
    icon: {
      type: String,
      default: 'file'
    },

    /**
     * @name ç»ä»¶é«åº¦
     * @property {Number, String} height
     * @description ç»ä»¶é«åº¦
     */
    width: {
      type: [Number, String],
      default: 50
    },

    /**
     * @name ç»ä»¶å®½åº¦
     * @property {Number, String} height
     * @description ç»ä»¶å®½åº¦
     */
    height: {
      type: [Number, String],
      default: 50
    },

    /**
     * @name åªä½æº
     * @property {String|File} src
     * @description åªä½æºï¼å¯ä»¥ä¸ºè·¯å¾æèFileå¯¹è±¡
     */
    src: {
      type: [String, File, Array],
      default: ''
    },

    /**
     * @name è§é¢å°é¢å¾
     * @property {String} poster
     * @description å½typeä¸ºè§é¢æ¶é»è®¤å±ç¤ºçå¾ç
     */
    poster: {
      type: String,
      default: ''
    },
    audio: {
      type: String,
      default: ''
    },

    /**
     * @name èæ¯é¢è²
     * @property {String} backgroundColor
     * @description ç¨äºå¡«åéæé¨åçé¢è²
     */
    backgroundColor: {
      type: String,
      default: '#dfdfdf'
    },

    /**
     * @name å±ç¤ºææ
     * @property {String} showEffect
     * @option contain - å®å¨éåºèæ¯åºåï¼é»è®¤
     * @option cover - å®å¨è¦çèæ¯åºå
     * @option overflow - å®½åº¦å®å¨éåºåå®¹åºåï¼é«åº¦åºç°æ»å¨
     */
    showEffect: {
      type: String,
      default: 'contain' // contain or cover or overflow

    },

    /**
     * @name é¼ æ ç§»å¥ææ
     * @property {String} hoverEffect
     * @option none - æ ææ
     * @option popover - å¼¹åºæ¡å±ç¤º
     * @option play - å½.typeä¸ºvideoæ¶ï¼ç§»å¥æ­æ¾
     */
    hoverEffect: {
      type: String,
      default: 'none'
    },

    /**
     * @name æµ®æ¡å®½åº¦
     * @property {Number, String} popoverWidth
     */
    popoverWidth: {
      type: [Number, String],
      default: 200
    },
    showGroupTip: {
      type: Boolean,
      default: true
    },

    /**
     * @name æ¯å¦æ¾ç¤ºè§é¢æ¶é¿
     * @property {Boolean} showDuration
     * @description å½typeä¸ºvideoæ¶æ¯å¦æ¾ç¤ºè§é¢æ¶é¿
     */
    showDuration: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    content: function content() {
      var _this = this;

      switch (this.type) {
        case 'img':
          return {
            tag: 'img',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              loading: 'lazy',
              src: this.url
            }
          };

        case 'video':
          return this.poster ? {
            tag: 'video',
            ref: 'posterVideo',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              preload: 'metadata',
              loop: true,
              poster: this.poster
            },
            on: {
              mouseenter: function mouseenter() {
                return _this.onPlayVideo('posterVideo');
              },
              mouseleave: function mouseleave() {
                return _this.onPauseVideo('posterVideo');
              },
              loadedmetadata: function loadedmetadata(e) {
                return _this.onVideoLoaded(e, 'posterVideo');
              }
            }
          } : {
            tag: 'video',
            ref: 'displayVideo',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              preload: 'metadata',
              src: this.url,
              loop: true
            },
            on: {
              mouseenter: function mouseenter() {
                return _this.onPlayVideo('displayVideo');
              },
              mouseleave: function mouseleave() {
                return _this.onPauseVideo('displayVideo');
              },
              loadedmetadata: function loadedmetadata(e) {
                return _this.onVideoLoaded(e, 'displayVideo');
              }
            }
          };

        case 'carousel':
          return {
            tag: 'img',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              loading: 'lazy',
              src: this.poster
            },
            on: 'play' === this.hoverEffect ? {
              mouseenter: function mouseenter() {
                return _this.onPlayVideo('bgm');
              },
              mouseleave: function mouseleave() {
                return _this.onPauseVideo('bgm');
              }
            } : {}
          };

        case 'group':
          return {
            tag: 'img',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              loading: 'lazy',
              src: this.poster
            }
          };

        default:
          var src = this.src instanceof File ? this.src.name : this.src.toString();

          var _ref = /\.([^\.]+)$/.exec(src) || [],
              _ref2 = slicedToArray(_ref, 2),
              _ref2$ = _ref2[1],
              ext = _ref2$ === void 0 ? '???' : _ref2$;

          return {
            tag: 'img',
            class: ['ui-media__display'],
            style: this.displayStyle,
            attrs: {
              loading: 'lazy',
              src: this.icon == 'file' ? createFileSvg(ext) : createLinkSvg(ext)
            }
          };
      }
    },
    popoverStyle: function popoverStyle() {
      return {
        maxWidth: numToPx(this.popoverWidth)
      };
    },
    mediaStyle: function mediaStyle() {
      return !this.$scopedSlots.default && _objectSpread$c({
        width: numToPx(this.width),
        height: numToPx(this.height),
        backgroundColor: this.backgroundColor
      }, this.showEffect == 'overflow' && this.type !== 'video' ? {
        lineHeight: numToPx(this.height),
        overflowY: 'auto'
      } : void 0);
    },
    displayStyle: function displayStyle() {
      return this.showEffect !== 'overflow' ? {
        height: '100%',
        objectFit: this.showEffect
      } : this.type !== 'video' ? {
        height: 'auto'
      } : {
        height: '100%',
        objectFit: 'contain'
      };
    }
  },
  watch: {
    src: {
      handler: function handler(val) {
        var _this2 = this;

        if (val instanceof File) {
          if (!this.fr) {
            this.fr = new FileReader();

            this.fr.onload = function () {
              return _this2.url = _this2.fr.result;
            };
          }

          this.fr.abort();
          this.fr.readAsDataURL(val);
          return;
        }

        if (this.fr) {
          this.fr.abort();
        }

        this.url = val;
      },
      immediate: true
    }
  },
  data: function data() {
    return {
      fr: null,
      url: '',
      videoDuration: 0 // æ·»å è§é¢æ¶é¿æ°æ®

    };
  },
  methods: {
    numberToChinese: function numberToChinese(num) {
      var chineseNumbers = ['é¶', 'ä¸', 'äº', 'ä¸', 'å', 'äº', 'å­', 'ä¸', 'å«', 'ä¹', 'å'];
      if (num <= 10) return chineseNumbers[num];
      if (num < 20) return 'å' + (num % 10 === 0 ? '' : chineseNumbers[num % 10]);
      var tens = Math.floor(num / 10);
      return chineseNumbers[tens] + 'å' + (num % 10 === 0 ? '' : chineseNumbers[num % 10]);
    },
    onVideoLoaded: function onVideoLoaded(e, refName) {
      var video = this.$refs[refName];

      if (video && video.duration) {
        this.videoDuration = video.duration;
      }
    },
    onPlayVideo: function onPlayVideo(refName) {
      var _this3 = this;

      var target = null;

      try {
        if (refName == 'bgm' && 'carousel' === this.type && this.$refs.popoverSwiper) {
          target = this.$refs.popoverSwiper.$refs[refName];
        } else {
          target = this.$refs[refName];
        } // æ·»å è·åè§é¢æ¶é¿çé»è¾


        if (target && this.type === 'video' && !this.videoDuration) {
          target.onloadedmetadata = function () {
            _this3.videoDuration = target.duration;
          };
        }

        if (target && target.paused) {
          target.src = refName == 'bgm' && 'carousel' === this.type ? this.audio : this.url;
          target.currentTime = 0;
          var fn = target.play();
          fn && fn.catch(function () {});
        }

        if (refName == 'bgm' && 'carousel' === this.type && this.$refs.popoverSwiper) {
          this.$refs.popoverSwiper.resetSwiper();
        }

        if ('group' === this.type && this.$refs.popoverSwiperGroup) {
          this.$refs.popoverSwiperGroup.resetSwiper();
        }
      } catch (e) {
        console.warn('Video play failed:', e);
      }
    },
    onPauseVideo: function onPauseVideo(refName) {
      try {
        var target = refName == 'bgm' && 'carousel' === this.type && this.$refs.popoverSwiper ? this.$refs.popoverSwiper.$refs[refName] : 'group' === this.type && this.$refs.popoverSwiperGroup ? this.$refs.popoverSwiperGroup.$refs[refName] : this.$refs[refName];

        if (target) {
          if (!target.paused) {
            target.currentTime = 0;
            target.pause();
          }
        }
      } catch (e) {
        console.warn('Video pause failed:', e);
      }
    },
    onClick: function onClick() {
      this.$emit('click', {
        url: this.url,
        type: this.type
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.onPauseVideo('popoverVideo');
    this.onPauseVideo('posterVideo');
    this.onPauseVideo('displayVideo');
    this.onPauseVideo('bgm');

    if (this.fr) {
      this.fr.abort();
      this.fr = null;
    }
  },
  render: function render() {
    var _this4 = this;

    var h = arguments[0];
    var display = this.content.tag;
    return h("div", {
      "class": "ui-media",
      "style": this.mediaStyle,
      "on": {
        "click": function click() {
          _this4.onClick();
        }
      }
    }, [[this.$scopedSlots.default ? this.$scopedSlots.default() : this.type == 'group' ? h("div", {
      "class": "group-container",
      "style": "position: relative;width:100%;height:100%"
    }, [this.showGroupTip ? h("div", {
      "class": "posi"
    }, ["1:1(", this.numberToChinese(this.url.length), "\u56FE)"]) : '', h("div", {
      "class": ['all-image-grid', "grid-".concat(this.url.length)]
    }, [this.url.length === 3 ? [].concat(toConsumableArray(this.url.map(function (image, index) {
      return h("div", {
        "class": "all-image-grid-item",
        "key": index
      }, [h("img", {
        "class": "swiper-image",
        "attrs": {
          "loading": "lazy",
          "src": image
        },
        "style": {
          width: '100%',
          height: '100%',
          objectFit: 'contain'
        }
      })]);
    })), [h("div", {
      "class": "all-image-grid-item empty",
      "key": "empty"
    })]) : this.src.map(function (image, index) {
      return h("div", {
        "class": "all-image-grid-item",
        "key": index
      }, [h("img", {
        "class": "swiper-image",
        "attrs": {
          "loading": "lazy",
          "src": image
        },
        "style": {
          width: '100%',
          height: '100%',
          objectFit: 'contain'
        }
      })]);
    })])]) : [h(display, helper([{}, this.content])), // æ¾ç¤ºè§é¢æ¶é¿
    this.type === 'video' && this.showDuration && this.videoDuration ? h("div", {
      "class": "video-duration"
    }, [Math.floor(this.videoDuration / 60), ":", String(Math.floor(this.videoDuration % 60)).padStart(2, '0')]) : null, // ä½¿ç¨ posteré¢è§æ¶ï¼å¢å è¯¥video
    'play' === this.hoverEffect && 'video' === this.type && 'img' === display ? h("video", {
      "ref": "posterVideo",
      "attrs": {
        "preload": "metadate",
        "loop": true
      }
    }) : null], 'popover' === this.hoverEffect ? h("v-popover", {
      "ref": "popoverWrap",
      "attrs": {
        "trigger": "hover",
        "placement": "right-start",
        "boundariesElement": "viewport",
        "popover-class": "ui-media__dropdown"
      },
      "on": {
        "apply-show": function applyShow() {
          _this4.onPlayVideo('popoverVideo');

          _this4.onPlayVideo('bgm');
        },
        "apply-hide": function applyHide() {
          _this4.onPauseVideo('popoverVideo');

          _this4.onPauseVideo('bgm');
        },
        "hide": function hide() {
          !_this4.$refs['popoverWrap'].isOpen && _this4.onPauseVideo('popoverVideo');

          _this4.onPauseVideo('bgm');
        }
      }
    }, [h("div", {
      "slot": "popover",
      "class": "ui-media__popover",
      "style": this.popoverStyle
    }, ['video' === this.type ? h("div", {
      "style": "position: relative;"
    }, [h("video", {
      "ref": "popoverVideo",
      "attrs": {
        "preload": "metadata",
        "loop": true
      },
      "style": {
        width: '100%',
        height: '100%',
        objectFit: 'contain'
      },
      "on": {
        "loadedmetadata": function loadedmetadata(e) {
          return _this4.onVideoLoaded(e, 'popoverVideo');
        }
      }
    }), this.showDuration && this.videoDuration ? h("div", {
      "class": "video-duration"
    }, [Math.floor(this.videoDuration / 60), ":", String(Math.floor(this.videoDuration % 60)).padStart(2, '0')]) : null]) : 'img' === this.type ? h("img", {
      "attrs": {
        "loading": "lazy",
        "src": this.url
      }
    }) : 'carousel' === this.type ? h("div", [h("ui-media-carousel", {
      "key": this.src.toString(),
      "ref": "popoverSwiper",
      "attrs": {
        "src": this.src,
        "audio": this.audio
      }
    })]) : 'group' === this.type ? h("div", [h("ui-media-group", {
      "key": this.src.toString(),
      "ref": "popoverSwiperGroup",
      "attrs": {
        "src": this.src
      }
    })]) : null])]) : null]]);
  }
};

/* script */
var __vue_script__$X = script$X;
/* template */

/* style */

var __vue_inject_styles__$X = undefined;
/* scoped */

var __vue_scope_id__$X = undefined;
/* module identifier */

var __vue_module_identifier__$X = undefined;
/* functional template */

var __vue_is_functional_template__$X = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$X = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$X, __vue_script__$X, __vue_scope_id__$X, __vue_is_functional_template__$X, __vue_module_identifier__$X, false, undefined, undefined, undefined);

//
var script$W = {
  name: 'ui-menu',
  props: {
    hasIcons: {
      type: Boolean,
      default: false
    },
    hasSecondaryText: {
      type: Boolean,
      default: false
    },
    containFocus: {
      type: Boolean,
      default: false
    },
    disableRipple: {
      type: Boolean,
      default: false
    },
    raised: {
      type: Boolean,
      default: false
    },
    collapse: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      menus: [],
      activeId: null
    };
  },
  provide: function provide() {
    return {
      RootMenu: this,
      UiMenu: this
    };
  },
  computed: {
    classes: function classes() {
      return {
        'is-collapse': this.collapse,
        'is-raised': this.raised,
        'is-secondary': this.hasSecondaryText
      };
    }
  },
  methods: {
    addMenu: function addMenu(menu) {
      this.menus.push(menu); // Select the menu if there's no menu selected (i.e. the menu is the only menu)
      // or the menu's selected prop is true

      if (null == this.activeId && menu.selected) {
        this.activeId = menu.id;
      }
    },
    removeMenu: function removeMenu(menu) {
      var index = this.menus.indexOf(menu);

      if (index > -1) {
        this.menus.splice(index, 1);
      }
    },
    onMenuClick: function onMenuClick(menu, event) {
      this.$emit('menu-click', menu, event); // Abort if the menu is disabled or already selected

      if (menu === null || menu.disabled || menu.id === this.activeId) {
        return;
      }

      this.activeId = menu.id;
      this.$emit('menu-change', menu);
    },
    onSubmenuClick: function onSubmenuClick(menu, subment, event) {
      this.$emit('menu-click', menu, event); // Abort if the menu is disabled or already selected

      if (menu === null || menu.disabled || subment === null || subment.disabled || subment.id === this.activeId) {
        return;
      }

      this.activeId = subment.id;
      this.$emit('menu-change', menu);
    },
    closeSubmenus: function closeSubmenus(subment) {
      this.menus.forEach(function (menu) {
        if (menu.$options.componentName === 'UiSubmenu') {
          if (subment && subment.id === menu.id) return;
          menu.toggleCollapsible(false);
        }
      });
    }
  },
  components: {
    UiFocusContainer: __vue_component__$1f
  }
};

/* script */
var __vue_script__$W = script$W;
/* template */

var __vue_render__$Q = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('ui-focus-container', {
    ref: "focusContainer",
    staticClass: "ui-menu",
    class: _vm.classes,
    attrs: {
      "role": "menu",
      "tag": "ul",
      "lazy": "",
      "contain-focus": _vm.containFocus
    }
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$Q = [];
/* style */

var __vue_inject_styles__$W = undefined;
/* scoped */

var __vue_scope_id__$W = undefined;
/* module identifier */

var __vue_module_identifier__$W = undefined;
/* functional template */

var __vue_is_functional_template__$W = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$W = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$Q,
  staticRenderFns: __vue_staticRenderFns__$Q
}, __vue_inject_styles__$W, __vue_script__$W, __vue_scope_id__$W, __vue_is_functional_template__$W, __vue_module_identifier__$W, false, undefined, undefined, undefined);

//
var script$V = {
  name: 'ui-menu-item',
  props: {
    icon: String,
    secondary: String,
    divider: Boolean,
    disabled: Boolean,
    selected: Boolean
  },
  inject: ['RootMenu', 'UiMenu'],
  data: function data() {
    return {
      id: UUID.short('ui-menu-item-')
    };
  },
  watch: {
    selected: {
      // ä¸ºäºå·æ°é¡µé¢æ¶ï¼èªå¨åçº§èåå¯ä»¥é«äº®ï¼å¨èåç»ä»¶åå§åæ¶ä¹è§¦åwatch
      immediate: true,
      handler: function handler(val, oldVal) {
        if (val && !oldVal) {
          if (this.disabled) return;
          this.UiMenu.onMenuClick(this);
        }
      }
    }
  },
  computed: {
    classes: function classes() {
      return {
        'is-collapse': this.UiMenu.collapse,
        'is-divider': this.divider,
        'is-disabled': this.disabled,
        'is-active': this.active
      };
    },
    active: function active() {
      return this.selected || this.UiMenu.activeId === this.id;
    }
  },
  components: {
    UiIcon: __vue_component__$1B,
    UiRippleInk: __vue_component__$1A
  },
  created: function created() {
    this.UiMenu.addMenu(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.UiMenu.removeMenu(this);
  },
  methods: {
    onMenuClick: function onMenuClick($event) {
      if (this.disabled) {
        return;
      }

      this.$emit('click', $event);
      this.UiMenu.onMenuClick(this, $event);
    }
  }
};

/* script */
var __vue_script__$V = script$V;
/* template */

var __vue_render__$P = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('li', {
    staticClass: "ui-menu-item",
    class: _vm.classes,
    attrs: {
      "role": "menu-item",
      "tabindex": _vm.disabled ? null : '0'
    },
    on: {
      "click": _vm.onMenuClick
    }
  }, [_c('div', {
    staticClass: "ui-menu-item__content"
  }, [_vm.$slots.icon ? _vm._t("icon") : _vm.icon ? _c('ui-icon', {
    staticClass: "ui-menu-item__icon",
    attrs: {
      "icon": _vm.icon
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-menu-item__text"
  }, [_vm._t("default")], 2), _vm._v(" "), _vm._t("append"), _vm._v(" "), _vm.secondary ? _c('div', {
    staticClass: "ui-menu-item__secondary-text"
  }, [_vm._v("\n      " + _vm._s(_vm.secondary) + "\n    ")]) : _vm._e()], 2), _vm._v(" "), !_vm.disabled && !_vm.UiMenu.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1);
};

var __vue_staticRenderFns__$P = [];
/* style */

var __vue_inject_styles__$V = undefined;
/* scoped */

var __vue_scope_id__$V = undefined;
/* module identifier */

var __vue_module_identifier__$V = undefined;
/* functional template */

var __vue_is_functional_template__$V = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$V = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$P,
  staticRenderFns: __vue_staticRenderFns__$P
}, __vue_inject_styles__$V, __vue_script__$V, __vue_scope_id__$V, __vue_is_functional_template__$V, __vue_module_identifier__$V, false, undefined, undefined, undefined);

var script$U = {
  name: 'ui-pagination',
  components: {
    UiButton: __vue_component__$1v
  },
  props: {
    total: {
      type: Number,
      default: 0,
      validator: function validator(val) {
        return val >= 0;
      }
    },
    current: {
      type: Number,
      default: 1,
      validator: function validator(val) {
        return val >= 1;
      }
    },
    pageCount: {
      type: Number,
      default: 7,
      validator: function validator(val) {
        return val >= 5 && val <= 21 && val % 2 !== 0;
      }
    },
    pageSize: {
      type: Number,
      default: 10
    },
    raised: Boolean,
    circle: Boolean
  },
  computed: {
    currentNumber: function currentNumber() {
      return Number(this.current);
    },
    showPageCount: function showPageCount() {
      return Number(this.pageCount) - 2;
    },
    totalPage: function totalPage() {
      return Math.ceil(this.total / this.pageSize);
    },
    items: function items() {
      if (this.total === 0) return [];
      var showPageCount = this.showPageCount;
      var arr = [];
      var start = 1;
      var end = this.totalPage;

      if (end <= showPageCount + 2) {
        for (var i = start; i <= end; i++) {
          arr.push({
            text: i,
            value: i
          });
        }

        return arr;
      }

      arr.push({
        text: start,
        value: start
      });

      if (this.current - start >= showPageCount - 1) {
        var go = this.current - showPageCount;
        arr.push({
          text: '...',
          value: go < 1 ? 1 : go
        });
      }

      var listStart = Number(this.current) - Math.floor(showPageCount / 2);
      if (listStart <= 1) listStart = 2;
      var listEnd = listStart + showPageCount - 1;
      if (listEnd >= end) listEnd = end - 1;
      listStart = listEnd - showPageCount + 1;

      for (var _i = listStart; _i <= listEnd; _i++) {
        arr.push({
          text: _i,
          value: _i
        });
      }

      if (end - this.current >= showPageCount - 1) {
        var _go = Number(this.current) + showPageCount;

        arr.push({
          text: '...',
          value: _go > end ? end : _go
        });
      }

      arr.push({
        text: end,
        value: end
      });
      return arr;
    },
    classes: function classes() {
      return {
        'ui-pagination': true,
        'ui-pagination--raised': this.raised,
        'ui-pagination--circle': this.circle
      };
    }
  },
  methods: {
    changePage: function changePage(page) {
      this.$emit('update:current', page);
      this.$emit('change', page);
    }
  }
};

/* script */
var __vue_script__$U = script$U;
/* template */

var __vue_render__$O = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes
  }, [_c('ui-button', {
    staticClass: "ui-pagination__btn",
    attrs: {
      "disabled": _vm.current <= 1,
      "icon": "chevron_left"
    },
    on: {
      "click": function click($event) {
        return _vm.changePage(_vm.currentNumber - 1);
      }
    }
  }), _vm._v(" "), _c('ul', _vm._l(_vm.items, function (item, index) {
    return _c('li', {
      key: index
    }, [_c('ui-button', {
      staticClass: "ui-pagination__item",
      attrs: {
        "color": _vm.currentNumber === item.value ? 'primary' : 'default'
      },
      on: {
        "click": function click($event) {
          return _vm.changePage(item.value);
        }
      }
    }, [item.text === '...' ? _c('ui-icon', {
      attrs: {
        "icon": "more_horiz"
      }
    }) : _c('span', [_vm._v(_vm._s(item.text))])], 1)], 1);
  }), 0), _vm._v(" "), _c('ui-button', {
    staticClass: "ui-pagination__btn",
    attrs: {
      "disabled": _vm.current >= _vm.totalPage,
      "icon": "chevron_right"
    },
    on: {
      "click": function click($event) {
        return _vm.changePage(_vm.currentNumber + 1);
      }
    }
  })], 1);
};

var __vue_staticRenderFns__$O = [];
/* style */

var __vue_inject_styles__$U = undefined;
/* scoped */

var __vue_scope_id__$U = undefined;
/* module identifier */

var __vue_module_identifier__$U = undefined;
/* functional template */

var __vue_is_functional_template__$U = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$U = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$O,
  staticRenderFns: __vue_staticRenderFns__$O
}, __vue_inject_styles__$U, __vue_script__$U, __vue_scope_id__$U, __vue_is_functional_template__$U, __vue_module_identifier__$U, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$T = {
  name: 'ui-progress-linear',
  props: {
    type: {
      type: String,
      default: 'indeterminate' // 'determinate' or 'indeterminate'

    },
    color: {
      type: String,
      default: 'primary' // 'primary', 'accent', 'black' or 'white'

    },
    progress: {
      type: Number,
      default: 0
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-progress-linear--color-".concat(this.color), "ui-progress-linear--type-".concat(this.type)];
    },
    moderatedProgress: function moderatedProgress() {
      if (this.progress < 0) {
        return 0;
      }

      if (this.progress > 100) {
        return 100;
      }

      return this.progress;
    }
  }
};

/* script */
var __vue_script__$T = script$T;
/* template */

var __vue_render__$N = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": "ui-progress-linear--transition-fade"
    }
  }, [_c('div', {
    staticClass: "ui-progress-linear",
    class: _vm.classes
  }, [_vm.type === 'determinate' ? _c('div', {
    staticClass: "ui-progress-linear__progress-bar is-determinate",
    style: {
      transform: "scaleX(" + _vm.moderatedProgress / 100 + ")"
    },
    attrs: {
      "role": "progressbar",
      "aria-valuemax": 100,
      "aria-valuemin": 0,
      "aria-valuenow": _vm.moderatedProgress
    }
  }) : _c('div', {
    staticClass: "ui-progress-linear__progress-bar is-indeterminate",
    attrs: {
      "role": "progressbar",
      "aria-valuemax": 100,
      "aria-valuemin": 0
    }
  })])]);
};

var __vue_staticRenderFns__$N = [];
/* style */

var __vue_inject_styles__$T = undefined;
/* scoped */

var __vue_scope_id__$T = undefined;
/* module identifier */

var __vue_module_identifier__$T = undefined;
/* functional template */

var __vue_is_functional_template__$T = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$T = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$N,
  staticRenderFns: __vue_staticRenderFns__$N
}, __vue_inject_styles__$T, __vue_script__$T, __vue_scope_id__$T, __vue_is_functional_template__$T, __vue_module_identifier__$T, false, undefined, undefined, undefined);

var script$S = {
  name: 'ui-radio-group',
  props: {
    name: {
      type: String,
      required: true
    },
    type: {
      type: String,
      default: 'default' // default or button

    },
    tabindex: [String, Number],
    label: String,
    options: {
      type: Array,
      required: true
    },
    value: {
      type: [Number, String],
      required: true
    },
    keys: {
      type: Object,
      default: function _default() {
        return {
          id: 'id',
          class: 'class',
          label: 'label',
          value: 'value',
          checked: 'checked',
          disabled: 'disabled'
        };
      }
    },
    color: {
      type: String,
      default: 'primary' // 'primary' or 'accent'

    },
    buttonPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    vertical: {
      type: Boolean,
      default: false
    },
    help: String,
    error: String,
    invalid: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      initialValue: this.value,
      selectedOptionValue: this.value
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-radio-group--color-".concat(this.color), "ui-radio-group--button-position-".concat(this.buttonPosition), defineProperty$2({}, "ui-radio-group--type-".concat(this.type), this.type), {
        'is-vertical': this.vertical
      }, {
        'is-active': this.isActive
      }, {
        'is-invalid': this.invalid
      }, {
        'is-disabled': this.disabled
      }];
    },
    hasFeedback: function hasFeedback() {
      return this.showError || this.showHelp;
    },
    showError: function showError() {
      return this.invalid && (Boolean(this.error) || Boolean(this.$slots.error));
    },
    showHelp: function showHelp() {
      return Boolean(this.help) || Boolean(this.$slots.help);
    }
  },
  watch: {
    selectedOptionValue: function selectedOptionValue() {
      this.$emit('input', this.selectedOptionValue);
      this.$emit('change', this.selectedOptionValue);
    },
    value: function value() {
      this.selectedOptionValue = this.value;
    }
  },
  methods: {
    reset: function reset() {
      this.$emit('input', this.initialValue);
    },
    isOptionCheckedByDefault: function isOptionCheckedByDefault(option) {
      // eslint-disable-next-line eqeqeq
      return this.initialValue == option[this.keys.value] || this.initialValue == option || option[this.keys.checked];
    },
    getTrueValue: function getTrueValue(option) {
      if (typeof option === 'string' || typeof option === 'number') {
        return option;
      }

      var value = option[this.keys.value];

      if (value === undefined) {
        console.warn('[UiRadioGroup] option has no `value`: ', option);
        return option;
      }

      return value;
    },
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    }
  },
  components: {
    UiRadio: __vue_component__$1o
  }
};

var __vue_script__$S = script$S;
/* template */

var __vue_render__$M = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-radio-group",
    class: _vm.classes
  }, [_vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-radio-group__label-text"
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-radio-group__radios"
  }, _vm._l(_vm.options, function (option) {
    return _c('ui-radio', {
      key: option[_vm.keys.id],
      staticClass: "ui-radio-group__radio",
      class: option[_vm.keys.class],
      attrs: {
        "button-position": _vm.buttonPosition,
        "checked": _vm.isOptionCheckedByDefault(option),
        "color": _vm.color,
        "disabled": _vm.disabled || option[_vm.keys.disabled],
        "id": option[_vm.keys.id],
        "name": _vm.name,
        "tabindex": _vm.tabindex,
        "true-value": _vm.getTrueValue(option)
      },
      on: {
        "blur": _vm.onBlur,
        "focus": _vm.onFocus
      },
      model: {
        value: _vm.selectedOptionValue,
        callback: function callback($$v) {
          _vm.selectedOptionValue = $$v;
        },
        expression: "selectedOptionValue"
      }
    }, [_vm._t("option", [_vm._v("\n        " + _vm._s(option[_vm.keys.label] || option) + "\n      ")], {
      "disabled": _vm.disabled || option[_vm.keys.disabled],
      "checked": _vm.isOptionCheckedByDefault(option),
      "value": _vm.selectedOptionValue,
      "option": option
    })], 2);
  }), 1), _vm._v(" "), _vm.hasFeedback ? _c('div', {
    staticClass: "ui-radio-group__feedback"
  }, [_vm.showError ? _c('div', {
    staticClass: "ui-radio-group__feedback-text"
  }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _c('div', {
    staticClass: "ui-radio-group__feedback-text"
  }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()]);
};

var __vue_staticRenderFns__$M = [];
/* style */

var __vue_inject_styles__$S = undefined;
/* scoped */

var __vue_scope_id__$S = undefined;
/* module identifier */

var __vue_module_identifier__$S = undefined;
/* functional template */

var __vue_is_functional_template__$S = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$S = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$M,
  staticRenderFns: __vue_staticRenderFns__$M
}, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, false, undefined, undefined, undefined);

var script$R = {
  name: 'ui-select-option',
  props: {
    option: {
      type: [String, Number, Object],
      required: true
    },
    type: {
      type: String,
      default: 'basic' // 'basic' or 'image'

    },
    multiple: {
      type: Boolean,
      default: false
    },
    highlighted: {
      type: Boolean,
      default: false
    },
    selected: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return [this.option.class, {
        // 'is-highlighted': !this.option.disabled && this.highlighted,
        'is-divider': !!this.option.divider,
        'is-disabled': !!this.option.disabled,
        'is-single': !!this.option.single,
        'is-selected': this.selected
      }];
    },
    label: function label() {
      return this.option.label;
    }
  },
  components: {
    UiIcon: __vue_component__$1B
  }
};

/* script */
var __vue_script__$R = script$R;
/* template */

var __vue_render__$L = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-select-option",
    class: _vm.classes,
    attrs: {
      "title": _vm.label
    }
  }, [_vm._t("default", [_c('div', {
    staticClass: "ui-select-option__label"
  }, [_vm._v("\n      " + _vm._s(_vm.label) + "\n    ")]), _vm._v(" "), _vm.multiple && !this.option.single ? _c('div', {
    staticClass: "ui-select-option__checkbox"
  }, [_c('ui-icon', [_vm.selected ? _c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M9.984 17.016l9-9-1.406-1.453-7.594 7.594-3.563-3.563L5.016 12zm9-14.016C20.11 3 21 3.938 21 5.016v13.97C21 20.062 20.11 21 18.984 21H5.014C3.89 21 3 20.064 3 18.986V5.015C3 3.94 3.89 3 5.014 3h13.97z"
    }
  })]) : _c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M18.984 3C20.062 3 21 3.938 21 5.016v13.97C21 20.062 20.062 21 18.984 21H5.014C3.938 21 3 20.064 3 18.986V5.015C3 3.94 3.936 3 5.014 3h13.97zm0 2.016H5.014v13.97h13.97V5.015z"
    }
  })])])], 1) : _vm._e()])], 2);
};

var __vue_staticRenderFns__$L = [];
/* style */

var __vue_inject_styles__$R = undefined;
/* scoped */

var __vue_scope_id__$R = undefined;
/* module identifier */

var __vue_module_identifier__$R = undefined;
/* functional template */

var __vue_is_functional_template__$R = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$R = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$L,
  staticRenderFns: __vue_staticRenderFns__$L
}, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, false, undefined, undefined, undefined);

function on(event, target, callback) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    passive: true
  };
  target.addEventListener(event, callback, options);
  return function () {
    target.removeEventListener(event, callback, options);
  };
} // eslint-disable-next-line max-params

function onKey(key, event, target, callback, options) {
  return on(event, target, function (e) {
    if (!key) {
      // We call back for every key if there's no specific key
      callback(e);
    } else if (key === e.key || key === e.keyCode) {
      // Otherwise we call back only if the key matches
      callback(e);
    }
  }, options);
}

function onKeydown(keys, target, callback, options) {
  return onKey(keys, 'keydown', target, callback, options);
}
function onKeyup(keys, target, callback, options) {
  return onKey(keys, 'keyup', target, callback, options);
}
function onKeypress(keys, target, callback, options) {
  return onKey(keys, 'keypress', target, callback, options);
}
var events = {
  on: on,
  onKeydown: onKeydown,
  onKeyup: onKeyup,
  onKeypress: onKeypress
};

var RespondsToExternalClick = {
  beforeDestroy: function beforeDestroy() {
    if (typeof this.destroyExternalClickListener === 'function') {
      this.removeExternalClickListener();
    }
  },
  methods: {
    addExternalClickListener: function addExternalClickListener() {
      var _this = this;

      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [this.$el];
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        passive: true
      };
      elements = Array.isArray(elements) ? elements : [elements];
      this.destroyExternalClickListener = events.on('click', document, function (e) {
        for (var i = 0; i < elements.length; i++) {
          if (elements[i].contains(e.target)) {
            return; // End early, click was internal
          }
        }

        if (typeof callback === 'function') {
          callback(e);
        } else {
          _this.$emit('external-click', e);
        }
      }, options);
    },
    removeExternalClickListener: function removeExternalClickListener() {
      if (this.destroyExternalClickListener) {
        this.destroyExternalClickListener();
        this.destroyExternalClickListener = null;
      }
    }
  }
};

function inView(element, container) {
  if (!element) {
    return;
  }

  container = container || element.parentElement;
  var top = element.offsetTop;
  var parentTop = container.scrollTop;
  var bottom = top + element.offsetHeight;
  var parentBottom = container.offsetHeight;
  return top >= parentTop && bottom <= parentBottom;
}
function scrollIntoView(element) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    container: null,
    marginTop: 0
  };

  if (!element) {
    return;
  }

  options.container = options.container || element.parentElement;

  if (inView(element, options.container)) {
    return;
  }

  options.container.scrollTop = element.offsetTop - options.marginTop;
}
function resetScroll(element) {
  if (!element) {
    return;
  }

  element.scrollTop = 0;
}

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$Q = {
  name: 'ui-select',
  components: {
    VPopover: VPopover,
    UiTag: __vue_component__$1q,
    UiIcon: __vue_component__$1B,
    UiButton: __vue_component__$1v,
    UiProgressCircular: __vue_component__$1w,
    UiSelectOption: __vue_component__$R // UiVirtualList,

  },

  /* directives: {
    VTooltip
  }, */
  mixins: [RespondsToExternalClick],
  props: {
    mellow: {
      type: Boolean,
      default: true
    },
    name: String,
    tabindex: [String, Number],
    value: {
      type: [String, Number, Object, Array],
      required: true
    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    optionsClass: String,
    placeholder: String,
    icon: String,
    iconPosition: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    label: String,
    floatingLabel: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'basic' // 'basic' or 'tag'

    },
    multiple: {
      type: Boolean,
      default: false
    },
    multipleDelimiter: {
      type: String,
      default: ', '
    },
    multipleLimit: {
      type: Number,
      default: Infinity
    },
    tagsLimit: {
      type: Number,
      default: 1
    },
    hasSearch: {
      type: Boolean,
      default: false
    },
    multipleSearch: {
      type: Boolean,
      default: false
    },
    searchPlaceholder: {
      type: String,
      default: 'æç´¢'
    },
    filter: Function,
    disableFilter: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    noResults: {
      type: Boolean,
      default: false
    },
    showAll: {
      type: Boolean,
      default: false
    },
    keys: {
      type: Object,
      default: function _default() {
        return {
          class: 'class',
          label: 'label',
          value: 'value',
          single: 'single',
          divider: 'divider',
          disabled: 'disabled',
          exclusions: 'exclusions'
        };
      }
    },
    width: {
      type: String,
      default: 'inherit' // inherit: ç»§æ¿ui-selectçå®½åº¦ï¼autoï¼èªå¨å®½åº¦ï¼å¶ä»è¡¨ç¤ºè®¾ç½®çå¼

    },
    invalid: {
      type: Boolean,
      default: false
    },
    help: String,
    error: String,
    disabled: {
      type: Boolean,
      default: false
    },

    /* æ¸é¤æé® */
    clearable: {
      type: Boolean,
      default: false
    },
    zIndex: {
      type: Number,
      default: 99
    },
    placement: {
      type: String,
      default: 'bottom-start'
    },
    boundariesElement: {
      type: String,
      default: 'body'
    },

    /* éä¸­é¡¹ç½®é¡¶ */
    selectTop: {
      type: Boolean,
      default: false
    },
    lazyPageSize: {
      type: Number,
      default: 30
    },
    lazyDistance: {
      type: Number,
      default: 100
    },
    filterRule: {
      type: Function,
      default: function _default() {}
    },
    historyTop: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    return {
      // æå è½½çé¡µç 
      lazyPageVal: 1,
      debouncedScroll: function debouncedScroll() {},
      lastValueMap: {},
      // ç¨äºè®°å½ä¸å¼å§æå¼æ¶éä¸­çå¼ï¼ç¨äºæåºç½®é¡¶çåè½
      query: '',
      isActive: false,
      isTouched: false,
      selectedIndex: -1,
      highlightedIndex: -1,
      initialValue: JSON.stringify(this.value),
      exclusionsArr: [],
      isHasExclusions: false
    };
  },
  computed: {
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-select--type-".concat(this.type), this.type), defineProperty$2(_ref, "ui-select--icon-position-".concat(this.iconPosition), this.iconPosition), defineProperty$2(_ref, "ui-select--mellow", this.mellow), defineProperty$2(_ref, 'is-active', this.isActive), defineProperty$2(_ref, 'is-invalid', this.invalid), defineProperty$2(_ref, 'is-touched', this.isTouched), defineProperty$2(_ref, 'is-disabled', this.disabled), defineProperty$2(_ref, 'is-multiple', this.multiple), defineProperty$2(_ref, 'has-label', this.hasLabel), defineProperty$2(_ref, 'has-clear', this.hasClear), defineProperty$2(_ref, 'has-floating-label', this.hasFloatingLabel), _ref;
    },
    labelClasses: function labelClasses() {
      return {
        'is-inline': this.hasFloatingLabel && this.isLabelInline,
        'is-floating': this.hasFloatingLabel && !this.isLabelInline
      };
    },
    hasLabel: function hasLabel() {
      return Boolean(this.label) || Boolean(this.$slots.default);
    },
    hasFloatingLabel: function hasFloatingLabel() {
      return this.hasLabel && this.floatingLabel;
    },
    hasClear: function hasClear() {
      return this.clearable && !this.disabled && this.hasDisplayText;
    },
    isLabelInline: function isLabelInline() {
      return !this.hasDisplayText && !this.isActive;
    },
    hasFeedback: function hasFeedback() {
      return this.showError || this.showHelp;
    },
    showError: function showError() {
      return this.invalid && (Boolean(this.error) || Boolean(this.$slots.error));
    },
    showHelp: function showHelp() {
      return Boolean(this.help) || Boolean(this.$slots.help);
    },

    /* è§æ ¼åoptionsï¼è¿æ ·åé¨å°±ä¸éè¦çä¼keyçå¼ */
    normalizeOptions: function normalizeOptions() {
      var _this = this;

      var newOptions = this.options.map(function (option) {
        return 'object' === _typeof_1(option) ? Object.keys(_this.keys).reduce(function (obj, key) {
          return Object.assign(obj, defineProperty$2({}, key, option[_this.keys[key]]));
        }, _objectSpread$b(_objectSpread$b({}, option), {}, {
          __org: option // ä¿å­åæ°æ®

        })) : {
          label: option,
          value: option,
          __org: option
        };
      });

      if (this.historyTop && this.historyTop != '') {
        var historys = this.getLocalStorage(this.historyTop);

        if (historys) {
          var getIdxByValue = historys.reduce(function (prev, cur) {
            var curIdx = newOptions.findIndex(function (item) {
              return item.value == cur;
            });

            if (curIdx != -1) {
              prev.push(curIdx);
            }

            return prev;
          }, []);
          var newArray = getIdxByValue.map(function (index) {
            return newOptions[index];
          });
          var filterArr = newOptions.filter(function (item, i) {
            return !getIdxByValue.includes(i);
          });
          var assignArr = [].concat(toConsumableArray(newArray), toConsumableArray(filterArr));
          return assignArr;
        }
      }

      return newOptions;
    },
    filterRuleOptions: function filterRuleOptions() {
      var _this2 = this;

      var newOptions = JSON.parse(JSON.stringify(this.normalizeOptions));
      return newOptions.reduce(function (prev, cur) {
        cur.label = _this2.filterRule(cur.label.toString());
        prev.push(cur);
        return prev;
      }, []);
    },
    filteredOptions: function filteredOptions() {
      var _this3 = this;

      var options = this.normalizeOptions;

      if (!this.disableFilter && this.query) {
        if (this.multipleSearch) {
          var isHas = this.query.includes(',');

          if (isHas) {
            var filterOptions;
            var options2 = [];
            var options1 = [];
            this.query.split(',').forEach(function (item) {
              if (typeof _this3.filterRule == 'function' && _this3.filterRule != 'undefined') {
                filterOptions = _this3.filterRuleOptions;
                var findIndexByLabel = filterOptions.reduce(function (prev, cur, i) {
                  if (cur.label.toString() == item.toString()) {
                    prev.push(i);
                  }

                  return prev;
                }, []);
                options1 = _this3.normalizeOptions.filter(function (option, j) {
                  return findIndexByLabel.includes(j);
                });
              } else {
                options1 = _this3.normalizeOptions.filter(function (option) {
                  return option.label.toString() == item.toString();
                });
              }

              options2 = [].concat(toConsumableArray(options1), toConsumableArray(options2));
            });
            options = options2;
          } else {
            options = this.normalizeOptions.filter(function (option) {
              return _this3.filter ? _this3.filter(option.__org, _this3.query, _this3.defaultFilter) : _this3.defaultFilter(option, _this3.query);
            });
          }
        } else {
          options = this.normalizeOptions.filter(function (option) {
            return _this3.filter ? _this3.filter(option.__org, _this3.query, _this3.defaultFilter) : _this3.defaultFilter(option, _this3.query);
          });
        }
      }

      if (this.selectTop) {
        options = options.sort(function (a, b) {
          return _this3.isOptionLastSelected(a) && !_this3.isOptionLastSelected(b) ? -1 : 1;
        });
      }

      return options;
    },
    lazyOptions: function lazyOptions() {
      return this.filteredOptions.slice(0, this.lazyPageSize * this.lazyPageVal);
    },

    /**
     * ä½¿ç¨è¿ä¸ªå±æ§æ¶ï¼è®°å¾åèµå¼ä¸ºå±é¨åéæä½¿ç¨ï¼å¦åä½¿ç¨thiså¼ç¨æ¶ï¼æ§è½ä¼æå¶çå·®
     * @example
     * bad:
     *     this.normalizeOptionsMap[value];
     * good:
     *     const optionsMap = this.normalizeOptionsMap;
     *     optionsMap[value];
     */
    normalizeOptionsMap: function normalizeOptionsMap() {
      return this.normalizeOptions.reduce(function (obj, option) {
        return Object.assign(obj, defineProperty$2({}, option.value, option));
      }, {});
    },

    /**
     * ä½¿ç¨è¿ä¸ªå±æ§æ¶ï¼è®°å¾åèµå¼ä¸ºå±é¨åéæä½¿ç¨ï¼å¦åä½¿ç¨thiså¼ç¨æ¶ï¼æ§è½ä¼æå¶çå·®
     * @example
     * bad:
     *     this.valueMap[value];
     * good:
     *     const valueMap = this.valueMap;
     *     valueMap[value];
     */
    valueMap: function valueMap() {
      return [].concat(this.value).reduce(function (obj, value, index) {
        return Object.assign(obj, defineProperty$2({}, value, index));
      }, {});
    },
    selectedOptions: function selectedOptions() {
      var optionsMap = this.normalizeOptionsMap;
      var values = [].concat(this.value).map(function (value) {
        var option = optionsMap[value];
        return option && option.__org && option || {};
      });
      return this.multiple ? values : values[0];
    },
    displayText: function displayText() {
      var optionsMap = this.normalizeOptionsMap;
      return [].concat(this.value).map(function (value) {
        var option = optionsMap[value];
        return option ? option.label : '';
      }).join(this.multipleDelimiter);
    },
    hasDisplayText: function hasDisplayText() {
      return Boolean(this.displayText);
    },
    hasNoResults: function hasNoResults() {
      if (this.loading) {
        return false;
      }

      return this.disableFilter ? this.noResults : this.filteredOptions.length === 0;
    },
    submittedValue: function submittedValue() {
      // Assuming that if there is no name or no value,
      // then there's no need to compute the submittedValue
      if (!this.name || !this.value) return;
      return [].concat(this.value).join(',');
    },
    presentTags: function presentTags() {
      var _this4 = this;

      var restCount = this.value.length - this.tagsLimit;
      var width = restCount > 0 ? 100 / (+this.tagsLimit + 1) : 100 / this.value.length;

      var genTag = function genTag(node) {
        return {
          node: node,
          style: {
            maxWidth: "".concat(width, "%")
          },
          key: node.value,
          text: node.label,
          closable: !_this4.disabled && !node.disabled
        };
      };

      var optionsMap = this.normalizeOptionsMap;
      var first = this.value.slice(0, this.tagsLimit);
      var tags = first.map(function (node) {
        return genTag(optionsMap[node]);
      });

      if (restCount > 0) {
        tags.push({
          key: -1,
          style: {
            maxWidth: "".concat(width, "%")
          },
          text: "+ ".concat(restCount),
          closable: false
        });
      }

      return tags;
    }
  },
  watch: {
    query: function query() {
      this.$emit('query-change', this.query);
    },
    isActive: function isActive(value) {
      if (value) {
        this.addExternalClickListener(this.$el, this.onExternalClick);
      } else {
        this.removeExternalClickListener();
      }
    },
    filteredOptions: function filteredOptions() {
      this.lazyPageVal = 1;
      this.highlightedIndex = 0;
      resetScroll(this.$refs.optionsList);
    }
  },
  created: function created() {
    if (this.isEmtpy(this.value)) {
      this.setValue(null);
    }

    this.debouncedScroll = lodash_debounce(this.onOptionsScroll, 300);
  },
  mounted: function mounted() {
    var _this5 = this;

    if (isArray$1(this.value) && this.value.length > 0) {
      this.value.forEach(function (value) {
        _this5.normalizeOptions.forEach(function (item) {
          if (value == item.value && item.exclusions && item.exclusions.length > 0) {
            var _this5$exclusionsArr;

            (_this5$exclusionsArr = _this5.exclusionsArr).push.apply(_this5$exclusionsArr, toConsumableArray(item.exclusions));
          }
        });
      });
      this.normalizeOptions.forEach(function (item) {
        if (item.exclusions && item.exclusions.length > 0) {
          _this5.isHasExclusions = true;
        }

        if (!_this5.exclusionsArr.includes(item.value)) {
          NUI.set(item, 'disabled', false);
        } else {
          NUI.set(item, 'disabled', true);
        }
      });
    }
  },
  methods: {
    optionClass: function optionClass(option, index) {
      return [{
        'is-highlighted': !option.disabled && this.highlightedIndex === index,
        'is-disabled': !!option.disabled
      }];
    },
    setLocalStorage: function setLocalStorage(key, data) {
      var keyStr = "".concat(key, "_local_kkknui");
      localStorage.setItem(keyStr, data);
    },
    getLocalStorage: function getLocalStorage(key) {
      var keyStr = "".concat(key, "_local_kkknui");
      return JSON.parse(localStorage.getItem(keyStr));
    },
    isEmtpy: function isEmtpy(val) {
      return 'undefined' === typeof val || null === val;
    },
    setValue: function setValue(value) {
      value = !this.isEmtpy(value) ? value : this.multiple ? [] : '';
      var isArray = Object.prototype.toString.call(value) === '[object Array]';

      if (this.historyTop && this.historyTop != '') {
        var lastHistory = this.getLocalStorage(this.historyTop) || [];
        var newIdx;

        if (isArray) {
          newIdx = Array.from(new Set([].concat(toConsumableArray(value), toConsumableArray(lastHistory))));
        } else {
          var sigleValue = value.toString().split('');
          newIdx = Array.from(new Set([].concat(toConsumableArray(sigleValue), toConsumableArray(lastHistory))));
        }

        this.setLocalStorage(this.historyTop, JSON.stringify(newIdx));
      }

      this.$emit('input', value);
      this.$emit('change', value);
    },
    highlightOption: function highlightOption(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        autoScroll: true
      };

      if (this.highlightedIndex === index || this.$refs.options.length === 0) {
        return;
      }

      var firstIndex = 0;
      var lastIndex = this.$refs.options.length - 1;

      if (index < firstIndex) {
        index = lastIndex;
      } else if (index > lastIndex) {
        index = firstIndex;
      }

      this.highlightedIndex = index;

      if (options.autoScroll) {
        this.scrollOptionIntoView(this.$refs.options[index].$el);
      }
    },
    selectHighlighted: function selectHighlighted(index, e) {
      if (this.$refs.options.length > 0) {
        e.preventDefault();
        this.selectOption(this.$refs.options[index].option, index);
      }
    },
    selectOption: function selectOption(option, index) {
      var _this6 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        autoClose: true
      };
      if (!!option.disabled || option.__org.disabled) return false; // è¢«ç¦ç¨çä¸åè®¸éæ©

      var shouldSelect = this.multiple && !this.isOptionSelected(option);

      if (this.multiple) {
        if (shouldSelect && this.value.length >= this.multipleLimit) return false; // è¶è¿æå¤éå¶é¡¹æ¶

        this.updateOption(option, {
          select: shouldSelect
        });
      } else {
        this.setValue(option.value);
        this.selectedIndex = index;
      }

      this.$emit('select', option, {
        selected: this.multiple ? shouldSelect : true
      });
      this.highlightedIndex = index;

      if (!this.multiple) {
        this.clearQuery();
      }

      if ((!this.multiple || option.single) && options.autoClose) {
        this.closeDropdown();
      }

      if (option.exclusions && option.exclusions.length > 0) {
        if (!shouldSelect) {
          this.exclusionsArr = this.filterExclusion(this.exclusionsArr, option.exclusions);
        } else {
          var _this$exclusionsArr;

          (_this$exclusionsArr = this.exclusionsArr).push.apply(_this$exclusionsArr, toConsumableArray(option.exclusions));
        }

        this.normalizeOptions.forEach(function (item) {
          var isDisabled = _this6.exclusionsArr.includes(item.value);

          NUI.set(item, 'disabled', isDisabled);
        });
      }
    },
    filterExclusion: function filterExclusion(arr, arr1) {
      var counter = arr1.reduce(function (acc, item) {
        return _objectSpread$b(_objectSpread$b({}, acc), {}, defineProperty$2({}, item, 0));
      }, {}); // ä½¿ç¨filter()æ¹æ³è¿æ»¤arr

      var newArr = arr.filter(function (item) {
        if (arr1.includes(item) && counter[item] < 1) {
          // å¦æitemå¨arr1ä¸­ä¸å°æªç§»é¤è¿ï¼åç§»é¤å¹¶å¢å è®¡æ°
          counter[item]++;
          return false;
        }

        return true;
      });
      return newArr;
    },
    selectAllOption: function selectAllOption() {
      var _this7 = this;

      if (this.multiple) {
        var value = toConsumableArray(this.value);

        var updated = false;
        this.filteredOptions.every(function (option) {
          if (value.length >= _this7.multipleLimit) return false; // è¶è¿æå¤éå¶é¡¹æ¶

          if (!_this7.isOptionSelected(option) && !option.disabled) {
            value.push(option.value);
            updated = true;
          }

          return true;
        });

        if (updated) {
          this.setValue(value);
          this.$emit('check-all', value);
        }
      }
    },
    unselectAllOption: function unselectAllOption() {
      this.clearAllOptionDisableStatus();

      if (this.multiple) {
        var optionsMap = this.normalizeOptionsMap;

        var value = toConsumableArray(this.value);

        var updated = false;

        for (var i = value.length - 1; i >= 0; i--) {
          if (optionsMap[value[i]]) {
            value.splice(i, 1);
            updated = true;
          }
        }

        if (updated) {
          this.setValue(value);
          this.$emit('clear-all');
        }
      }
    },
    clearAllOptionDisableStatus: function clearAllOptionDisableStatus() {
      this.normalizeOptions.forEach(function (item) {
        NUI.set(item, 'disabled', false);
      });
    },
    clearAllOption: function clearAllOption() {
      this.clearAllOptionDisableStatus();

      if (this.multiple) {
        if (this.value.length > 0) this.setValue([]);
        this.$emit('clear-all');
      }
    },
    deleteTag: function deleteTag(index, option) {
      var _this8 = this;

      if (option.exclusions && option.exclusions.length > 0) {
        this.exclusionsArr = this.filterExclusion(this.exclusionsArr, option.exclusions);
        this.normalizeOptions.forEach(function (item) {
          var isDisabled = _this8.exclusionsArr.includes(item.value);

          NUI.set(item, 'disabled', isDisabled);
        });
      }

      if (index > -1) {
        var value = toConsumableArray(this.value);

        value.splice(index, 1);
        this.setValue(value);
        this.$emit('remove-tag', value);
      }
    },
    isOptionSelected: function isOptionSelected(option) {
      return 'undefined' !== typeof this.valueMap[option.value];
    },
    isOptionLastSelected: function isOptionLastSelected(option) {
      return 'undefined' !== typeof this.lastValueMap[option.value];
    },
    updateOption: function updateOption(option, _ref2) {
      var _ref2$select = _ref2.select,
          select = _ref2$select === void 0 ? true : _ref2$select;
      var value = [];
      var updated = false;
      var i = 'undefined' !== typeof this.valueMap[option.value] ? this.valueMap[option.value] : -1;

      if (option.single) {
        if (i != 0) {
          value = [option.value];
          updated = true;
        }
      } else {
        if (select && i < 0) {
          value = [].concat(this.value, option.value);
          updated = true;
        }

        if (!select && i > -1) {
          value = this.value.slice(0, i).concat(this.value.slice(i + 1));
          updated = true;
        }

        if (updated) {
          var optionsMap = this.normalizeOptionsMap;
          value = value.filter(function (val) {
            return optionsMap[val] && !optionsMap[val].single;
          });
        }
      }

      if (updated) {
        this.setValue(value);
      }
    },
    defaultFilter: function defaultFilter(option, query) {
      var text = option.label;

      if (typeof text === 'string') {
        text = text.toLowerCase();
      } // return fuzzysearch(query.toLowerCase(), text)


      return ~String(text).indexOf(query.toLowerCase());
    },
    clearQuery: function clearQuery() {
      this.query = '';
    },
    focus: function focus() {
      this.$refs.label.focus();
    },
    openDropdown: function openDropdown() {
      if (this.disabled) {
        return;
      }

      this.$refs.dropdown.show();
    },
    closeDropdown: function closeDropdown() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        blurAfterClose: false
      };
      this.$refs.dropdown.hide();
      this.$emit('close-dropdown');

      if (!this.isTouched) {
        this.isTouched = true;
        this.$emit('touch');
      }

      if (options.blurAfterClose) {
        this.isActive = false;
      } else {
        this.$refs.label.focus();
      }
    },
    onFocus: function onFocus(e) {
      if (this.isActive) {
        this.$emit('close-dropdown');
        return;
      }

      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);

      if (this.$refs.dropdown.isOpen) {
        this.closeDropdown({
          blurAfterClose: true
        });
      }
    },
    onClear: function onClear(e) {
      this.clearAllOptionDisableStatus();
      this.onBlur(e);
      this.setValue(null);
      this.$emit('clear', e);
    },
    onOpen: function onOpen(evt) {
      var _this9 = this;

      this.isActive = true;
      this.lastValueMap = _objectSpread$b({}, this.valueMap);
      if (this.width === 'inherit') this.$refs.dropdownContent.style.width = this.$refs.label.getBoundingClientRect().width + 'px';else if (this.width !== 'auto') this.$refs.dropdownContent.style.width = this.width;
      setTimeout(function () {
        _this9.$refs[_this9.hasSearch ? 'searchInput' : 'dropdownContent'].focus();

        _this9.scrollOptionIntoView(_this9.$refs.optionsList.querySelector('.is-selected'));
      }, 100);
      this.$emit('dropdown-open', evt);
    },
    onClose: function onClose(evt) {
      this.highlightedIndex = this.multiple ? -1 : this.selectedIndex;
      this.clearQuery();
      this.$emit('dropdown-close', evt);
    },
    onExternalClick: function onExternalClick() {
      if (this.$refs.dropdown.isOpen) {
        this.closeDropdown({
          blurAfterClose: true
        });
      } else if (this.isActive) {
        this.isActive = false;
      }
    },
    onOptionsScroll: function onOptionsScroll() {
      if (!this.$refs.optionsList) return;
      if (this.lazyOptions.length >= this.filteredOptions.length) return;

      var _ref3 = this.$refs.optionsList || {},
          clientHeight = _ref3.clientHeight,
          scrollHeight = _ref3.scrollHeight,
          scrollTop = _ref3.scrollTop;

      if (scrollTop + clientHeight >= scrollHeight - this.lazyDistance) {
        this.lazyPageVal++;
      }
    },
    scrollOptionIntoView: function scrollOptionIntoView(optionEl) {
      scrollIntoView(optionEl, {
        container: this.$refs.optionsList,
        marginTop: 180
      });
    },
    reset: function reset() {
      this.setValue(JSON.parse(this.initialValue));
      this.clearQuery();
      this.resetTouched();
      this.selectedIndex = -1;
      this.highlightedIndex = -1;
    },
    resetTouched: function resetTouched() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        touched: false
      };
      this.isTouched = options.touched;
    }
  }
};

/* script */
var __vue_script__$Q = script$Q;
/* template */

var __vue_render__$K = function __vue_render__() {
  var _obj;

  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-select",
    class: _vm.classes
  }, [_vm.name ? _c('input', {
    staticClass: "ui-select__hidden-input",
    attrs: {
      "type": "hidden",
      "name": _vm.name
    },
    domProps: {
      "value": _vm.submittedValue
    }
  }) : _vm._e(), _vm._v(" "), _vm.icon || _vm.$slots.icon ? _c('div', {
    staticClass: "ui-select__icon-wrapper"
  }, [_vm._t("icon", [_c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  })])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-select__content"
  }, [_c('div', {
    ref: "label",
    staticClass: "ui-select__label",
    attrs: {
      "tabindex": _vm.disabled ? null : _vm.tabindex || '0'
    },
    on: {
      "focus": _vm.onFocus,
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        $event.preventDefault();
        return _vm.openDropdown($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.openDropdown($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
          return null;
        }

        return _vm.onBlur($event);
      }]
    }
  }, [_c('v-popover', {
    ref: "dropdown",
    staticClass: "ui-select__popover",
    attrs: {
      "popover-class": "ui-select__dropdown",
      "boundaries-element": _vm.boundariesElement,
      "placement": _vm.placement,
      "disabled": _vm.disabled
    },
    on: {
      "show": _vm.onOpen,
      "hide": _vm.onClose
    }
  }, [_vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-select__label-text",
    class: _vm.labelClasses
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e(), _vm._v(" "), _vm.$slots.button ? [_vm._t("button")] : [_c('div', {
    staticClass: "ui-select__display"
  }, [_vm.hasClear ? _c('ui-icon', {
    staticClass: "ui-select__clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        $event.preventDefault();
        $event.stopPropagation();
        return _vm.onClear($event);
      }
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-select__display-value",
    class: {
      'is-placeholder': !_vm.hasDisplayText
    }
  }, [_vm.hasDisplayText ? _vm._t("value", [_vm.multiple && _vm.type == 'tag' ? _c('div', {
    staticClass: "ui-select__tags"
  }, _vm._l(_vm.presentTags, function (tag, index) {
    return _c('div', {
      key: tag.key,
      staticClass: "ui-select__tag",
      style: tag.style,
      attrs: {
        "title": tag.text
      }
    }, [_c('ui-tag', {
      attrs: {
        "size": "small",
        "closable": tag.closable
      },
      on: {
        "close": function close($event) {
          return _vm.deleteTag(index, tag.node);
        }
      }
    }, [_c('span', [_vm._v(_vm._s(tag.text))])])], 1);
  }), 0) : _c('span', [_vm._v(_vm._s(_vm.displayText))])], {
    "value": _vm.selectedOptions
  }) : [_vm._v(_vm._s(_vm.hasFloatingLabel && _vm.isLabelInline ? null : _vm.placeholder))]], 2), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-select__dropdown-button"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M6.984 9.984h10.03L12 15z"
    }
  })])])], 1)], _vm._v(" "), _c('div', {
    ref: "dropdownContent",
    staticClass: "ui-select__dropdown-content",
    attrs: {
      "slot": "popover",
      "tabindex": "-1"
    },
    on: {
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.closeDropdown();
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
          return null;
        }

        return _vm.onBlur($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
          return null;
        }

        $event.preventDefault();
        $event.stopPropagation();
        return _vm.selectHighlighted(_vm.highlightedIndex, $event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "down", 40, $event.key, ["Down", "ArrowDown"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.highlightOption(_vm.highlightedIndex + 1);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.highlightOption(_vm.highlightedIndex - 1);
      }]
    },
    slot: "popover"
  }, [_vm.hasSearch ? _c('div', {
    staticClass: "ui-select__search",
    on: {
      "click": function click($event) {
        $event.stopPropagation();
      },
      "keydown": function keydown($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.stopPropagation();
      }
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.query,
      expression: "query"
    }],
    ref: "searchInput",
    staticClass: "ui-select__search-input",
    attrs: {
      "type": "text",
      "autocomplete": "off",
      "placeholder": _vm.searchPlaceholder
    },
    domProps: {
      "value": _vm.query
    },
    on: {
      "input": function input($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.query = $event.target.value;
      }
    }
  }), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-select__search-icon"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M9.516 14.016c2.484 0 4.5-2.016 4.5-4.5s-2.016-4.5-4.5-4.5-4.5 2.016-4.5 4.5 2.016 4.5 4.5 4.5zm6 0l4.97 4.97-1.5 1.5-4.97-4.97v-.797l-.28-.282c-1.126.984-2.626 1.547-4.22 1.547-3.61 0-6.516-2.86-6.516-6.47S5.906 3 9.516 3s6.47 2.906 6.47 6.516c0 1.594-.564 3.094-1.548 4.22l.28.28h.798z"
    }
  })])]), _vm._v(" "), _vm.loading ? _c('ui-progress-circular', {
    staticClass: "ui-select__search-progress",
    class: {
      'ui-select__search-progress--clear': _vm.query
    },
    attrs: {
      "size": 20,
      "stroke": 4
    }
  }) : _vm._e(), _vm._v(" "), _vm.query ? _c('ui-icon', {
    staticClass: "ui-select__search-clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        $event.preventDefault();
        $event.stopPropagation();
        return _vm.clearQuery($event);
      }
    }
  }) : _vm._e()], 1) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "optionsList",
    staticClass: "ui-select__options",
    class: (_obj = {}, _obj[_vm.optionsClass] = _vm.optionsClass, _obj),
    on: {
      "scroll": _vm.debouncedScroll
    }
  }, [_vm._l(_vm.lazyOptions, function (option, index) {
    return [_c('ui-select-option', {
      key: index,
      ref: "options",
      refInFor: true,
      class: _vm.optionClass(option, index),
      attrs: {
        "highlighted": _vm.highlightedIndex === index,
        "multiple": _vm.multiple,
        "option": option,
        "selected": _vm.isOptionSelected(option)
      },
      nativeOn: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.selectOption(option, index);
        },
        "mouseover": function mouseover($event) {
          $event.stopPropagation();
          return _vm.highlightOption(index, {
            autoScroll: false
          });
        }
      }
    }, [_vm._t("option", null, {
      "highlighted": _vm.highlightedIndex === index,
      "index": index,
      "option": option.__org,
      "selected": _vm.isOptionSelected(option)
    })], 2)];
  }), _vm._v(" "), _vm.lazyOptions.length < _vm.filteredOptions.length ? _c('div', {
    staticClass: "ui-select__lazy-loading"
  }, [_c('ui-progress-circular', {
    attrs: {
      "size": 20,
      "stroke": 4
    }
  }), _vm._v("è½½å¥æ´å¤...\n            ")], 1) : _vm._e(), _vm._v(" "), _vm.hasNoResults ? _c('div', {
    staticClass: "ui-select__no-results"
  }, [_vm._t("no-results", [_vm._v("æªæ¾å°ç»æ")])], 2) : _vm._e()], 2), _vm._v(" "), _vm._t("dropdown-extra", [_vm.multiple ? _c('div', {
    staticClass: "ui-select__dropdown-extra"
  }, [_c('span', [_vm.multipleLimit !== Infinity ? [_vm._v("æå¤éæ©\n                  "), _c('strong', [_vm._v(_vm._s(_vm.multipleLimit))]), _vm._v(" é¡¹ç®ï¼")] : _vm._e(), _vm._v("\n                éä¸­ " + _vm._s(_vm.value ? _vm.value.length : 0) + " /\n                " + _vm._s(_vm.normalizeOptions.length) + " é¡¹\n              ")], 2), _vm._v(" "), _vm.showAll && !_vm.isHasExclusions ? _c('div', [_c('ui-button', {
    attrs: {
      "color": "primary"
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.selectAllOption($event);
      }
    }
  }, [_vm._v("å¨é")]), _vm._v(" "), _c('ui-button', {
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.unselectAllOption($event);
      }
    }
  }, [_vm._v("å¨ä¸é")])], 1) : _vm._e()]) : _vm._e()])], 2)], 2)], 1), _vm._v(" "), _vm.hasFeedback ? _c('div', {
    staticClass: "ui-select__feedback"
  }, [_vm.showError ? _c('div', {
    staticClass: "ui-select__feedback-text"
  }, [_vm._t("error", [_vm._v(_vm._s(_vm.error))])], 2) : _vm.showHelp ? _c('div', {
    staticClass: "ui-select__feedback-text"
  }, [_vm._t("help", [_vm._v(_vm._s(_vm.help))])], 2) : _vm._e()]) : _vm._e()])]);
};

var __vue_staticRenderFns__$K = [];
/* style */

var __vue_inject_styles__$Q = undefined;
/* scoped */

var __vue_scope_id__$Q = undefined;
/* module identifier */

var __vue_module_identifier__$Q = undefined;
/* functional template */

var __vue_is_functional_template__$Q = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$Q = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$K,
  staticRenderFns: __vue_staticRenderFns__$K
}, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, false, undefined, undefined, undefined);

var script$P = {
  name: 'ui-slider',
  props: {
    name: String,
    tabindex: [String, Number],
    icon: String,
    value: {
      type: Number,
      required: true
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 10
    },
    snapToSteps: {
      type: Boolean,
      default: false
    },
    showMarker: {
      type: Boolean,
      default: false
    },
    markerValue: [String, Number],
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      initialValue: this.value,
      isActive: false,
      isDragging: false,
      localValue: this.value
    };
  },
  computed: {
    classes: function classes() {
      return [{
        'is-dragging': this.isDragging
      }, {
        'is-disabled': this.disabled
      }, {
        'is-active': this.isActive
      }, {
        'has-icon': this.hasIcon
      }, {
        'has-marker': this.showMarker
      }];
    },
    hasIcon: function hasIcon() {
      return Boolean(this.$slots.icon) || Boolean(this.icon);
    },
    fillStyle: function fillStyle() {
      return {
        transform: 'scaleX(' + this.relativeValue(this.localValue) + ')'
      };
    },
    thumbStyle: function thumbStyle() {
      return {
        left: this.relativeValue(this.localValue) * 100 + '%'
      };
    },
    markerText: function markerText() {
      return this.markerValue === undefined ? this.value : this.markerValue;
    },
    snapPoints: function snapPoints() {
      var points = [];
      var point = this.step * Math.ceil(this.moderatedMin / this.step);

      while (point <= this.moderatedMax) {
        points.push(point);
        point += this.step;
      }

      return points;
    },
    moderatedMin: function moderatedMin() {
      return this.max > this.min ? this.min : 0;
    },
    moderatedMax: function moderatedMax() {
      return this.max > this.min ? this.max : 100;
    }
  },
  watch: {
    value: function value() {
      this.setValue(this.value);
    },
    isDragging: function isDragging() {
      var operation = this.isDragging ? 'add' : 'remove';
      classlist[operation](document.body, 'ui-slider--is-dragging');
    }
  },
  mounted: function mounted() {
    this.initializeSlider();
  },
  beforeDestroy: function beforeDestroy() {
    this.teardownSlider();
  },
  methods: {
    focus: function focus() {
      this.$el.focus();
    },
    reset: function reset() {
      this.setValue(this.initialValue);
    },
    onFocus: function onFocus() {
      this.isActive = true;
      this.$emit('focus');
    },
    onBlur: function onBlur() {
      this.isActive = false;
      this.$emit('blur');
    },
    onExternalClick: function onExternalClick(e) {
      if (!this.$el.contains(e.target)) {
        this.onBlur();
      }
    },
    setValueWithSnap: function setValueWithSnap(value) {
      value = this.moderateValue(value);

      if (this.snapToSteps) {
        value = this.getNearestSnapPoint(value);
      }

      this.setValue(value);
    },
    setValue: function setValue(value) {
      value = this.moderateValue(value);

      if (value === this.localValue) {
        return;
      }

      this.localValue = value;
      this.$emit('input', value);
      this.$emit('change', value);
    },
    incrementValue: function incrementValue() {
      this.setValueWithSnap(this.localValue + this.step);
    },
    decrementValue: function decrementValue() {
      this.setValueWithSnap(this.localValue - this.step);
    },
    getTrackOffset: function getTrackOffset() {
      var el = this.$refs.track;
      var offset = el.offsetLeft;

      while (el.offsetParent) {
        el = el.offsetParent;
        offset += el.offsetLeft;
      }

      return offset;
    },
    getPointStyle: function getPointStyle(point) {
      return {
        left: point + '%'
      };
    },
    initializeSlider: function initializeSlider() {
      document.addEventListener('touchend', this.onDragStop);
      document.addEventListener('mouseup', this.onDragStop);
      document.addEventListener('click', this.onExternalClick);
      this.initializeDrag();
    },
    teardownSlider: function teardownSlider() {
      document.removeEventListener('touchend', this.onDragStop);
      document.removeEventListener('mouseup', this.onDragStop);
      document.removeEventListener('click', this.onExternalClick);
    },
    initializeDrag: function initializeDrag() {
      var value = this.moderateValue(this.localValue ? this.localValue : 0);
      this.setValue(value);
    },
    onDragStart: function onDragStart(e) {
      if (this.disabled) {
        return;
      }

      if (!this.isActive) {
        this.onFocus();
      }

      this.isDragging = true;
      this.dragUpdate(e);
      document.addEventListener('touchmove', this.onDragMove);
      document.addEventListener('mousemove', this.onDragMove);
      this.$emit('dragstart', this.localValue, e);
    },
    onDragMove: function onDragMove(e) {
      this.dragUpdate(e);
    },
    dragUpdate: function dragUpdate(e) {
      var position = e.touches ? e.touches[0].pageX : e.pageX;
      var trackLength = this.$refs.track.offsetWidth;
      var relativeValue = (position - this.getTrackOffset()) / trackLength;
      var value = this.moderateValue(this.moderatedMin + relativeValue * (this.moderatedMax - this.moderatedMin));

      if (this.isDragging) {
        this.setValue(Math.round(value));
      }
    },
    onDragStop: function onDragStop(e) {
      if (this.isDragging) {
        this.isDragging = false;

        if (this.snapToSteps && this.value % this.step !== 0) {
          this.setValueWithSnap(this.value);
        }

        document.removeEventListener('touchmove', this.onDragMove);
        document.removeEventListener('mousemove', this.onDragMove);
        this.$emit('dragend', this.localValue, e);
      }
    },
    getNearestSnapPoint: function getNearestSnapPoint(value) {
      var previousSnapPoint = Math.floor(value / this.step) * this.step;
      var nextSnapPoint = previousSnapPoint + this.step;
      var midpoint = (previousSnapPoint + nextSnapPoint) / 2;

      if (previousSnapPoint < this.moderatedMin) {
        if (nextSnapPoint > this.moderatedMax) {
          return value;
        }

        return nextSnapPoint;
      }

      if (value >= midpoint && nextSnapPoint <= this.moderatedMax) {
        return nextSnapPoint;
      }

      return previousSnapPoint;
    },
    relativeValue: function relativeValue(value) {
      return (value - this.moderatedMin) / (this.moderatedMax - this.moderatedMin);
    },
    moderateValue: function moderateValue(value) {
      if (value < this.moderatedMin) {
        return this.moderatedMin;
      }

      if (value > this.moderatedMax) {
        return this.moderatedMax;
      }

      return value;
    }
  },
  components: {
    UiIcon: __vue_component__$1B
  }
};

/* script */
var __vue_script__$P = script$P;
/* template */

var __vue_render__$J = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-slider",
    class: _vm.classes,
    attrs: {
      "role": "slider",
      "aria-valuemax": _vm.moderatedMax,
      "aria-valuemin": _vm.moderatedMin,
      "aria-valuenow": _vm.localValue,
      "tabindex": _vm.disabled ? null : _vm.tabindex || '0'
    },
    on: {
      "blur": _vm.onBlur,
      "focus": _vm.onFocus,
      "keydown": [function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "down", 40, $event.key, ["Down", "ArrowDown"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.decrementValue($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
          return null;
        }

        if ('button' in $event && $event.button !== 0) {
          return null;
        }

        $event.preventDefault();
        return _vm.decrementValue($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "right", 39, $event.key, ["Right", "ArrowRight"])) {
          return null;
        }

        if ('button' in $event && $event.button !== 2) {
          return null;
        }

        $event.preventDefault();
        return _vm.incrementValue($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"])) {
          return null;
        }

        $event.preventDefault();
        return _vm.incrementValue($event);
      }]
    }
  }, [_vm.name ? _c('input', {
    staticClass: "ui-slider__hidden-input",
    attrs: {
      "type": "hidden",
      "name": _vm.name
    },
    domProps: {
      "value": _vm.value
    }
  }) : _vm._e(), _vm._v(" "), _vm.hasIcon ? _c('div', {
    staticClass: "ui-slider__icon"
  }, [_vm._t("icon", [_c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  })])], 2) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "track",
    staticClass: "ui-slider__track",
    on: {
      "mousedown": _vm.onDragStart,
      "touchstart": _vm.onDragStart
    }
  }, [_c('div', {
    staticClass: "ui-slider__track-background"
  }, _vm._l(_vm.snapPoints, function (point) {
    return _vm.snapToSteps ? _c('span', {
      staticClass: "ui-slider__snap-point",
      style: {
        left: 100 * _vm.relativeValue(point) + '%'
      }
    }) : _vm._e();
  }), 0), _vm._v(" "), _c('div', {
    staticClass: "ui-slider__track-fill",
    style: _vm.fillStyle
  }), _vm._v(" "), _c('div', {
    ref: "thumb",
    staticClass: "ui-slider__thumb",
    style: _vm.thumbStyle
  }, [_vm.showMarker ? _c('div', {
    staticClass: "ui-slider__marker"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 24 24",
      "width": "36",
      "height": "36"
    }
  }, [_c('path', {
    attrs: {
      "d": "M11 .5c-1.7.2-3.4.9-4.7 2-1.1.9-2 2-2.5 3.2-1.2 2.4-1.2 5.1-.1 7.7 1.1 2.6 2.8 5 5.3 7.5 1.2 1.2 2.8 2.7 3 2.7 0 0 .3-.2.6-.5 3.2-2.7 5.6-5.6 7.1-8.5.8-1.5 1.1-2.6 1.3-3.8.2-1.4 0-2.9-.5-4.3-1.2-3.2-4.1-5.4-7.5-5.8-.5-.2-1.5-.2-2-.2z"
    }
  })]), _vm._v(" "), _c('span', {
    staticClass: "ui-slider__marker-text"
  }, [_vm._v(_vm._s(_vm.markerText))])]) : _vm._e()])])]);
};

var __vue_staticRenderFns__$J = [];
/* style */

var __vue_inject_styles__$P = undefined;
/* scoped */

var __vue_scope_id__$P = undefined;
/* module identifier */

var __vue_module_identifier__$P = undefined;
/* functional template */

var __vue_is_functional_template__$P = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$P = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$J,
  staticRenderFns: __vue_staticRenderFns__$J
}, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, false, undefined, undefined, undefined);

var script$O = {
  name: 'ui-step-header',
  components: {
    UiIcon: __vue_component__$1B,
    UiButton: __vue_component__$1v
  },
  props: {
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    id: {
      type: String,
      required: true
    },
    title: String,
    icon: String,
    description: String,
    error: String,
    editable: Boolean,
    done: Boolean,
    active: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  inject: ['UiSteps'],
  computed: {
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-step-header--size-".concat(this.size), this.size), defineProperty$2(_ref, "ui-step-header--type-".concat(this.type), this.type), defineProperty$2(_ref, "ui-step-header--color-".concat(this.color), this.active || this.editable || this.done), defineProperty$2(_ref, 'is-vertical', this.UiSteps.vertical), defineProperty$2(_ref, 'is-active', this.active), defineProperty$2(_ref, 'is-error', this.error), defineProperty$2(_ref, 'is-editable', this.editable), defineProperty$2(_ref, 'is-done', this.done), _ref;
    }
  }
};

/* script */
var __vue_script__$O = script$O;
/* template */

var __vue_render__$I = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-step-header",
    class: _vm.classes
  }, [_c('ui-button', {
    class: {
      'is-vertical': this.UiSteps.vertical
    },
    attrs: {
      "type": "secondary",
      "disabled": _vm.disabled
    }
  }, [_c('div', {
    staticClass: "ui-step-header__icon"
  }, [_vm.error ? _c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "32",
      "height": "32",
      "viewBox": "0 0 1024 1024"
    }
  }, [_c('path', {
    attrs: {
      "d": "M470.13888 0h83.70176c22.56896 0 40.2432 18.3296 39.38304 40.96L567.93088 716.8c-0.4096 11.1616-9.95328 20.48-21.25824 20.48H477.30688c-11.4688 0-20.84864-9.17504-21.25824-20.48L430.75584 40.96C429.91616 18.2272 447.54944 0 470.13888 0zM512 1006.44864a81.92 81.92 0 1 1 0-163.84 81.92 81.92 0 0 1 0 163.84z"
    }
  })])]) : _vm.editable ? _c('ui-icon', {
    attrs: {
      "icon": "edit"
    }
  }) : _vm.done ? _c('ui-icon', {
    attrs: {
      "icon": "done"
    }
  }) : [_vm._v(_vm._s(_vm.UiSteps.getIndexById(_vm.id) + 1))]], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-step-header__text"
  }, [_c('span', {
    staticClass: "ui-step-header__title"
  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _vm.error ? _c('span', {
    staticClass: "ui-step-header__desc"
  }, [_vm._v(_vm._s(_vm.error))]) : _vm.description ? _c('span', {
    staticClass: "ui-step-header__desc"
  }, [_vm._v(_vm._s(_vm.description))]) : _vm._e()])])], 1);
};

var __vue_staticRenderFns__$I = [];
/* style */

var __vue_inject_styles__$O = undefined;
/* scoped */

var __vue_scope_id__$O = undefined;
/* module identifier */

var __vue_module_identifier__$O = undefined;
/* functional template */

var __vue_is_functional_template__$O = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$O = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$I,
  staticRenderFns: __vue_staticRenderFns__$I
}, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, false, undefined, undefined, undefined);

var _props;
var script$N = {
  name: 'ui-step',
  components: {
    UiStepHeader: __vue_component__$O
  },
  props: (_props = {
    id: {
      type: String,
      default: function _default() {
        return UUID.short('ui-steps-');
      }
    },
    title: String,
    done: Boolean,
    error: String,
    editable: Boolean
  }, defineProperty$2(_props, "done", Boolean), defineProperty$2(_props, "description", String), defineProperty$2(_props, "selected", {
    type: Boolean,
    default: false
  }), defineProperty$2(_props, "disabled", {
    type: Boolean,
    default: false
  }), _props),
  inject: ['UiSteps'],
  computed: {
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-step--size-".concat(this.UiSteps.size), this.UiSteps.size), defineProperty$2(_ref, 'is-vertical', this.UiSteps.vertical), defineProperty$2(_ref, 'is-active', this.isActive), _ref;
    }
  },
  data: function data() {
    return {
      isActive: false
    };
  },
  watch: {
    disabled: function disabled() {
      this.UiSteps.onStepDisabledChange(this);
    }
  },
  created: function created() {
    this.UiSteps.addStep(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.UiSteps.removeStep(this);
  },
  methods: {
    onStepClick: function onStepClick($event) {
      this.UiSteps.onStepClick(this, $event);
    },
    activate: function activate() {
      this.isActive = true;
      this.$emit('select', this.id);
    },
    deactivate: function deactivate() {
      this.isActive = false;
      this.$emit('deselect', this.id);
    }
  }
};

/* script */
var __vue_script__$N = script$N;
/* template */

var __vue_render__$H = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-step",
    class: _vm.classes,
    attrs: {
      "role": "steppanel",
      "id": _vm.id,
      "aria-hidden": !_vm.isActive ? 'true' : null,
      "tabindex": _vm.isActive ? '0' : null
    }
  }, [_vm.UiSteps.vertical ? _c('ui-step-header', _vm._b({
    attrs: {
      "size": _vm.UiSteps.size,
      "type": _vm.UiSteps.type,
      "color": _vm.UiSteps.color,
      "active": _vm.UiSteps.activeStepId === _vm.id
    },
    nativeOn: {
      "click": function click($event) {
        return _vm.onStepClick($event);
      }
    }
  }, 'ui-step-header', _vm.$props, false)) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-step__content"
  }, [_vm._t("default")], 2)], 1);
};

var __vue_staticRenderFns__$H = [];
/* style */

var __vue_inject_styles__$N = undefined;
/* scoped */

var __vue_scope_id__$N = undefined;
/* module identifier */

var __vue_module_identifier__$N = undefined;
/* functional template */

var __vue_is_functional_template__$N = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$N = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$H,
  staticRenderFns: __vue_staticRenderFns__$H
}, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, false, undefined, undefined, undefined);

var script$M = {
  name: 'ui-steps',
  components: {
    UiStepHeader: __vue_component__$O
  },
  props: {
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary'

    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    vertical: Boolean
  },
  data: function data() {
    return {
      steps: [],
      activeStepId: null,
      activeStepIndex: -1
    };
  },
  provide: function provide() {
    return {
      UiSteps: this
    };
  },
  computed: {
    classes: function classes() {
      var _ref;

      return _ref = {}, defineProperty$2(_ref, "ui-steps--type-".concat(this.type), this.type), defineProperty$2(_ref, "ui-steps--color-".concat(this.color), this.color), defineProperty$2(_ref, "ui-steps--size-".concat(this.size), this.size), defineProperty$2(_ref, 'is-vertical', this.vertical), _ref;
    }
  },
  watch: {
    activeStepId: function activeStepId() {
      var _this = this;

      this.steps.forEach(function (step, index) {
        if (_this.activeStepId === step.id) {
          step.activate();
          _this.activeStepIndex = index;
        } else if (step.isActive) {
          step.deactivate();
        }
      });
    }
  },
  methods: {
    addStep: function addStep(step) {
      this.steps.push(step); // Select the step if there's no step selected (i.e. the step is the only step)
      // or the step's selected prop is true

      if (this.activeStepId === null || step.selected) {
        this.activeStepId = step.id;
      }
    },
    removeStep: function removeStep(step) {
      var index = this.steps.indexOf(step);

      if (index > -1) {
        this.steps.splice(index, 1); // Switch to the nearest available step if the step being
        // removed is the one currently active

        if (step.id === this.activeStepId) {
          this.selectStep(this.findNearestStep());
        }
      }
    },
    onStepDisabledChange: function onStepDisabledChange(step) {
      // Switch to the nearest available step if the step being disabled is currently active
      if (step.disabled && this.activeStepId === step.id) {
        this.selectStep(this.findNearestStep());
      }
    },
    onStepClick: function onStepClick(step, event) {
      this.$emit('step-click', step, event);
      this.selectStep(step);
    },
    selectStep: function selectStep(step) {
      // Abort if the step is disabled or already selected
      if (step === null || step.disabled || step.id === this.activeStepId) {
        return;
      }

      if (this.confirmStepChange && !this.confirmStepChange(this.steps[this.activeStepIndex], step)) {
        return;
      }

      this.activeStepId = step.id;
      this.$emit('step-change', step);
    },
    selectNextStep: function selectNextStep() {
      var nextStep = this.findNextStep();

      if (nextStep) {
        this.selectStep(nextStep);
        nextStep.$el.focus();
      }
    },
    selectPreviousStep: function selectPreviousStep() {
      var previousStep = this.findPreviousStep();

      if (previousStep) {
        this.selectStep(previousStep);
        previousStep.$el.focus();
      }
    },
    findNextStep: function findNextStep() {
      var step = null;

      for (var i = this.activeStepIndex + 1; i < this.steps.length; i++) {
        if (this.steps[i] && !this.steps[i].disabled) {
          step = this.steps[i];
          break;
        }
      }

      return step;
    },
    findPreviousStep: function findPreviousStep() {
      var step = null;

      for (var i = this.activeStepIndex - 1; i >= 0; i--) {
        if (this.steps[i] && !this.steps[i].disabled) {
          step = this.steps[i];
          break;
        }
      }

      return step;
    },
    findNearestStep: function findNearestStep() {
      return this.findPreviousStep() || this.findNextStep();
    },
    findStepById: function findStepById(id) {
      for (var i = 0; i < this.steps.length; i++) {
        if (id === this.steps[i].id) {
          return this.steps[i];
        }
      }

      return null;
    },
    getIndexById: function getIndexById(id) {
      for (var i = 0; i < this.steps.length; i++) {
        if (id === this.steps[i].id) {
          return i;
        }
      }

      return -1;
    },
    setActiveStep: function setActiveStep(stepId) {
      var step = this.findStepById(stepId);

      if (step && !step.disabled) {
        this.selectStep(step);
      }
    }
  }
};

/* script */
var __vue_script__$M = script$M;
/* template */

var __vue_render__$G = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-steps",
    class: _vm.classes
  }, [!_vm.vertical ? _c('div', {
    staticClass: "ui-steps__navigation"
  }, _vm._l(_vm.steps, function (step, index) {
    return _c('ui-step-header', _vm._b({
      key: index,
      attrs: {
        "size": _vm.size,
        "type": _vm.type,
        "color": _vm.color,
        "active": _vm.activeStepId === step.id
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.onStepClick(step, $event);
        }
      }
    }, 'ui-step-header', step.$props, false));
  }), 1) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-steps__wrapper"
  }, [_c('div', {
    staticClass: "ui-steps__container"
  }, [_vm._t("default")], 2)])]);
};

var __vue_staticRenderFns__$G = [];
/* style */

var __vue_inject_styles__$M = undefined;
/* scoped */

var __vue_scope_id__$M = undefined;
/* module identifier */

var __vue_module_identifier__$M = undefined;
/* functional template */

var __vue_is_functional_template__$M = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$M = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$G,
  staticRenderFns: __vue_staticRenderFns__$G
}, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, false, undefined, undefined, undefined);

//
var script$L = {
  name: 'ui-submenu',
  componentName: 'UiSubmenu',
  components: {
    VPopover: VPopover,
    UiIcon: __vue_component__$1B,
    UiRippleInk: __vue_component__$1A
  },
  directives: {
    VClosePopover: VClosePopover
  },
  props: {
    open: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ''
    },
    title: {
      type: String,
      required: true
    },
    isAccordion: Boolean,
    secondary: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: undefined
    }
  },
  inject: ['RootMenu', 'UiMenu'],
  provide: function provide() {
    return {
      RootMenu: this.RootMenu,
      UiMenu: this
    };
  },
  data: function data() {
    return {
      isOpen: this.open,
      id: UUID.short('ui-submenu-'),
      menus: [],
      activeIndex: -1
    };
  },
  created: function created() {
    this.UiMenu.addMenu(this);
    this.RootMenu.addMenu(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.UiMenu.removeMenu(this);
    this.RootMenu.removeMenu(this);
  },
  computed: {
    classes: function classes() {
      return {
        'ui-submenu': true,
        'is-open': this.isOpen,
        'is-collapse': this.RootMenu.collapse,
        'is-divider': this.divider,
        'is-disabled': this.disabled,
        'is-active': this.active
      };
    },
    active: function active() {
      return this.UiMenu.activeId === this.id;
    },
    activeId: function activeId() {
      return this.active && this.menus[this.activeIndex] ? this.menus[this.activeIndex].id : null;
    }
  },
  methods: {
    addMenu: function addMenu(menu) {
      this.menus.push(menu); // Select the menu if there's no menu selected (i.e. the menu is the only menu)
      // or the menu's selected prop is true

      if (menu.selected) {
        this.activeIndex = this.menus.length - 1;
        this.UiMenu.activeId = this.id;
        this.toggleCollapsible(true);
        this.isAccordion && this.RootMenu.closeSubmenus(this);
      }
    },
    removeMenu: function removeMenu(menu) {
      var index = this.menus.indexOf(menu);

      if (index > -1) {
        this.menus.splice(index, 1);
      }
    },
    onMenuClick: function onMenuClick(menu, event) {
      this.activeIndex = this.menus.indexOf(menu);
      this.UiMenu.onMenuClick(this, event);
      this.toggleCollapsible(true);
      this.isAccordion && this.RootMenu.closeSubmenus(this);
    },
    toggleCollapsible: function toggleCollapsible(bool) {
      if (this.disabled || this.RootMenu.collapse) {
        return;
      }

      this.isOpen = 'boolean' === typeof bool ? bool : !this.isOpen;
    },
    onEnter: function onEnter(el) {
      this.$emit('open');
      this.isAccordion && this.RootMenu.closeSubmenus(this);
      el.style.maxHeight = el.scrollHeight + 'px';
    },
    afterEnter: function afterEnter(el) {
      // Remove the max-height to allow the element to grow
      el.style.maxHeight = 'none';
    },
    beforeLeave: function beforeLeave(el) {
      // Restore max-height for the leave transition
      el.style.maxHeight = el.scrollHeight + 'px'; // Force repaint

      el.offsetHeight; // eslint-disable-line no-unused-expressions
    },
    onLeave: function onLeave(el) {
      el.style.maxHeight = 0;
      this.$emit('close');
    },
    closePopover: function closePopover() {
      if (this.$refs.popover) {
        this.$refs.popover.close();
      }
    }
  }
};

/* script */
var __vue_script__$L = script$L;
/* template */

var __vue_render__$F = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('li', {
    ref: "submenu",
    class: _vm.classes,
    attrs: {
      "tabindex": _vm.disabled ? null : '0'
    }
  }, [_c('div', {
    staticClass: "ui-submenu__header",
    on: {
      "click": _vm.toggleCollapsible
    }
  }, [_c('div', {
    staticClass: "ui-submenu__header-icon"
  }, [_vm.$slots.icon ? _vm._t("icon") : _vm.icon ? _c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  }) : _vm._e()], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-submenu__header-text"
  }, [_vm.$slots.title ? _vm._t("title") : [_vm._v(_vm._s(_vm.title))]], 2), _vm._v(" "), _vm.secondary ? _c('div', {
    staticClass: "ui-submenu__header-secondary"
  }, [_vm._v("\n      " + _vm._s(_vm.secondary) + "\n    ")]) : _vm._e(), _vm._v(" "), _c('ui-icon', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.RootMenu.collapse,
      expression: "!RootMenu.collapse"
    }],
    staticClass: "ui-submenu__header-collapse"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M7.406 7.828L12 12.422l4.594-4.594L18 9.234l-6 6-6-6z"
    }
  })])]), _vm._v(" "), !_vm.disabled && !_vm.RootMenu.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1), _vm._v(" "), _vm.RootMenu.collapse ? _c('v-popover', {
    ref: "popover",
    staticClass: "ui-submenu__popover",
    attrs: {
      "popover-class": "ui-submenu__dropdown",
      "placement": "right-start",
      "boundaries-element": "body"
    }
  }, [_c('div', {
    directives: [{
      name: "close-popover",
      rawName: "v-close-popover"
    }],
    staticClass: "ui-submenu__body-wrapper",
    attrs: {
      "slot": "popover"
    },
    slot: "popover"
  }, [_c('ul', {
    staticClass: "ui-submenu__body"
  }, [_vm._t("default")], 2)]), _vm._v(" "), !_vm.disabled && !_vm.RootMenu.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1) : _c('transition', {
    on: {
      "enter": _vm.onEnter,
      "after-enter": _vm.afterEnter,
      "before-leave": _vm.beforeLeave,
      "leave": _vm.onLeave
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.isOpen,
      expression: "isOpen"
    }],
    staticClass: "ui-submenu__body-wrapper"
  }, [_c('ul', {
    staticClass: "ui-submenu__body is-inline"
  }, [_vm._t("default")], 2)])])], 1);
};

var __vue_staticRenderFns__$F = [];
/* style */

var __vue_inject_styles__$L = undefined;
/* scoped */

var __vue_scope_id__$L = undefined;
/* module identifier */

var __vue_module_identifier__$L = undefined;
/* functional template */

var __vue_is_functional_template__$L = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$L = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$F,
  staticRenderFns: __vue_staticRenderFns__$F
}, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, false, undefined, undefined, undefined);

var IS_TOUCH = typeof window !== 'undefined' && ('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);

var Drag = /*#__PURE__*/function () {
  function Drag(element, onlyTouch) {
    classCallCheck(this, Drag);

    this.el = element;
    this.startPos = {};
    this.endPos = {};
    this.starts = [];
    this.drags = [];
    this.ends = [];
    this.disabled = false;
    this.onlyTouch = onlyTouch;

    if (IS_TOUCH || onlyTouch) {
      this.el.addEventListener('touchstart', this);
    } else {
      this.el.addEventListener('mousedown', this);
    }
  }

  createClass(Drag, [{
    key: "handleEvent",
    value: function handleEvent(event) {
      if (this.disabled) return;

      switch (event.type) {
        case 'touchstart':
          this.touchStart(event);
          break;

        case 'touchmove':
          this.touchMove(event);
          break;

        case 'touchcancel':
        case 'touchend':
          this.touchEnd(event);
          break;

        case 'mousedown':
          this.mouseStart(event);
          break;

        case 'mousemove':
          this.mouseMove(event);
          break;

        case 'mouseleave':
        case 'mouseup':
          this.mouseEnd(event);
          break;
      }
    }
  }, {
    key: "touchStart",
    value: function touchStart(event) {
      var _this = this;

      var touch = event.touches[0];
      this.startPos = {
        // åç¬¬ä¸ä¸ªtouchçåæ å¼
        x: touch.pageX,
        y: touch.pageY,
        time: new Date().getTime()
      };
      this.endPos = {};
      document.addEventListener('touchmove', this, {
        passive: false
      });
      document.addEventListener('touchend', this, {
        passive: false
      });
      document.body.setAttribute('drag', '');
      this.starts.map(function (func) {
        func.call(_this, _this.startPos, event);
      });
    }
  }, {
    key: "touchMove",
    value: function touchMove(event) {
      var _this2 = this;

      if (event.touches.length > 1 || event.scale && event.scale !== 1) return;
      var touch = event.touches[0];
      this.endPos = {
        x: touch.pageX - this.startPos.x,
        y: touch.pageY - this.startPos.y,
        time: new Date().getTime() - this.startPos.time
      };
      this.drags.map(function (func) {
        func.call(_this2, _this2.endPos, event);
      });
    }
  }, {
    key: "touchEnd",
    value: function touchEnd(event) {
      var _this3 = this;

      document.body.removeAttribute('drag');
      document.removeEventListener('touchmove', this);
      document.removeEventListener('touchend', this);
      this.endPos.time = new Date().getTime() - this.startPos.time;
      this.ends.map(function (func) {
        func.call(_this3, _this3.endPos, event);
      });
    }
  }, {
    key: "mouseStart",
    value: function mouseStart(event) {
      var _this4 = this;

      this.startPos = {
        x: event.clientX,
        y: event.clientY,
        time: new Date().getTime()
      };
      this.endPos = {};
      document.addEventListener('mousemove', this);
      document.addEventListener('mouseup', this);
      document.body.setAttribute('drag', '');
      this.starts.map(function (func) {
        func.call(_this4, _this4.startPos, event);
      });
    }
  }, {
    key: "mouseMove",
    value: function mouseMove(event) {
      var _this5 = this;

      this.endPos = {
        x: event.clientX - this.startPos.x,
        y: event.clientY - this.startPos.y
      };
      this.drags.map(function (func) {
        func.call(_this5, _this5.endPos, event);
      });
    }
  }, {
    key: "mouseEnd",
    value: function mouseEnd(event) {
      var _this6 = this;

      document.body.removeAttribute('drag');
      document.removeEventListener('mousemove', this);
      document.removeEventListener('mouseup', this);
      this.endPos.time = new Date().getTime() - this.startPos.time;
      this.ends.map(function (func) {
        func.call(_this6, _this6.endPos, event);
      });
    }
  }, {
    key: "start",
    value: function start(fun) {
      this.starts.push(fun);
      return this;
    }
  }, {
    key: "end",
    value: function end(fun) {
      this.ends.push(fun);
      return this;
    }
  }, {
    key: "drag",
    value: function drag(fun) {
      this.drags.push(fun);
      return this;
    }
  }, {
    key: "reset",
    value: function reset(event) {
      var touch = event.touches ? event.touches[0] : {};
      this.startPos = {
        // åç¬¬ä¸ä¸ªtouchçåæ å¼
        x: touch.pageX || event.clientX,
        y: touch.pageY || event.clientY,
        time: new Date().getTime()
      };
      this.endPos = {
        x: 0,
        y: 0
      };
    }
  }, {
    key: "destory",
    value: function destory() {
      if (IS_TOUCH || this.onlyTouch) {
        this.el.removeEventListener('touchstart', this);
      } else {
        this.el.removeEventListener('mousedown', this);
      }
    }
  }]);

  return Drag;
}();

var instance$7 = 'v-swipe';

function inserted(el, _ref) {
  var value = _ref.value,
      modifiers = _ref.modifiers;
  var drag = new Drag(el, modifiers.touch);
  el[instance$7] = drag;
  drag.start(function (pos, e) {
    value.start && value.start(pos, drag, e);
  });
  drag.drag(function (pos, e) {
    value.move && value.move(pos, drag, e);
  });
  drag.end(function (pos, e) {
    value.end && value.end(pos, drag, e);
    var dirRatio = 0.5;
    var minDistance = 16;

    if (Math.abs(pos.y) < dirRatio * Math.abs(pos.x)) {
      value.left && pos.x < -minDistance && value.left(pos, drag, e);
      value.right && pos.x > minDistance && value.right(pos, e);
    }

    if (Math.abs(pos.x) < dirRatio * Math.abs(pos.y)) {
      value.up && pos.y < -minDistance && value.up(pos, drag, e);
      value.down && pos.y > minDistance && value.down(pos, drag, e);
    }
  });
}

function unbind$1(el) {
  if (el[instance$7]) el[instance$7].destory();
}

var swipe = {
  name: 'swipe',
  inserted: inserted,
  unbind: unbind$1
};

var script$K = {
  name: 'ui-swiper',
  components: {
    UiButton: __vue_component__$1v
  },
  directives: {
    swipe: swipe
  },
  provide: function provide() {
    return {
      Swiper: this
    };
  },
  props: {
    /* size: {
      type: String,
      default: 'normal', // 'small', 'normal', 'large'
    }, */
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    active: {
      type: Number,
      default: 0
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    interval: {
      type: [Number, String],
      default: 6000,
      validator: function validator(value) {
        return value > 0;
      }
    },
    transition: {
      type: String,
      default: 'slide',
      validator: function validator(val) {
        return ['slide', 'fade'].indexOf(val) !== -1;
      }
    },
    hideIndicators: Boolean,
    hideControls: Boolean
  },
  computed: {
    classes: function classes() {
      return defineProperty$2({
        'ui-swiper': true
      }, "ui-swiper--color-".concat(this.color), this.color);
    }
  },
  data: function data() {
    return {
      items: [],
      inverse: false,
      activeIndex: this.active
    };
  },
  mounted: function mounted() {
    this.startAutoNext();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.timer) clearInterval(this.timer);
  },
  methods: {
    getTransition: function getTransition() {
      return this.transition;
    },
    addItem: function addItem(item) {
      var index = this.$children.indexOf(item);
      return index === -1 ? this.items.push(item) : this.items.splice(index, 0, item);
    },
    removeItem: function removeItem(item) {
      var index = this.items.indexOf(item);
      if (index === -1) return;
      this.items.splice(index, 1);
    },
    isActive: function isActive(item) {
      return this.items.indexOf(item) === this.activeIndex;
    },
    startAutoNext: function startAutoNext() {
      var _this = this;

      if (this.timer) clearInterval(this.timer);
      if (!this.autoplay) return;
      this.timer = setInterval(function () {
        return _this.next();
      }, this.interval > 0 ? this.interval : 6000);
    },
    next: function next() {
      var maxIndex = this.items.length - 1;
      var index = this.activeIndex + 1;
      if (index > maxIndex) index = 0;
      this.activeIndex = index;
      this.inverse = false;
    },
    prev: function prev() {
      var index = this.activeIndex - 1;
      if (index < 0) index = this.items.length - 1;
      this.activeIndex = index;
      this.inverse = true;
    },
    changeActiveIndex: function changeActiveIndex(index) {
      if (index !== this.activeIndex) {
        this.inverse = this.activeIndex > index;
        this.activeIndex = index;
      }
    }
  },
  watch: {
    activeIndex: function activeIndex(val) {
      this.startAutoNext();
      this.$emit('change', val);
      this.$emit('update:active', val);
    },
    active: function active(val) {
      this.changeActiveIndex(val);
    },
    autoplay: function autoplay() {
      this.startAutoNext();
    },
    interval: function interval() {
      this.startAutoNext();
    }
  }
};

/* script */
var __vue_script__$K = script$K;
/* template */

var __vue_render__$E = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    directives: [{
      name: "swipe",
      rawName: "v-swipe.touch",
      value: {
        left: _vm.next,
        right: _vm.prev
      },
      expression: "{ left: next, right: prev }",
      modifiers: {
        "touch": true
      }
    }],
    class: _vm.classes
  }, [!_vm.hideControls ? [_vm._t("left", [_c('ui-button', {
    staticClass: "ui-swiper__control ui-swiper__control-left",
    attrs: {
      "icon": "chevron_left",
      "circle": ""
    },
    on: {
      "click": _vm.prev
    }
  })]), _vm._v(" "), _vm._t("right", [_c('ui-button', {
    staticClass: "ui-swiper__control ui-swiper__control-right",
    attrs: {
      "icon": "chevron_right",
      "circle": ""
    },
    on: {
      "click": _vm.next
    }
  })])] : _vm._e(), _vm._v(" "), !_vm.hideIndicators ? _c('div', {
    staticClass: "ui-swiper__indicators"
  }, [_vm._l(_vm.items, function (item, index) {
    return _vm._t("indicator", [_c('ui-button', {
      key: index,
      staticClass: "ui-swiper__indicator-button",
      class: {
        'is-active': index === _vm.activeIndex
      },
      on: {
        "click": function click($event) {
          return _vm.changeActiveIndex(index);
        }
      }
    })], {
      "value": {
        index: index,
        active: index === _vm.activeIndex
      }
    });
  })], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
};

var __vue_staticRenderFns__$E = [];
/* style */

var __vue_inject_styles__$K = undefined;
/* scoped */

var __vue_scope_id__$K = undefined;
/* module identifier */

var __vue_module_identifier__$K = undefined;
/* functional template */

var __vue_is_functional_template__$K = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$K = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$E,
  staticRenderFns: __vue_staticRenderFns__$E
}, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
var script$J = {
  name: 'ui-swiper-item',
  inject: ['Swiper'],
  data: function data() {
    return {};
  },
  computed: {
    classes: function classes() {
      return {
        'ui-swiper-item': true,
        'is-inverse': this.Swiper.inverse
      };
    },
    active: function active() {
      return this.Swiper.isActive(this);
    },
    transition: function transition() {
      return this.Swiper.getTransition();
    }
  },
  created: function created() {
    this.Swiper.addItem(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.Swiper.removeItem(this);
  }
};

/* script */
var __vue_script__$J = script$J;
/* template */

var __vue_render__$D = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": "ui-swiper-item--" + _vm.transition
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.active,
      expression: "active"
    }],
    class: _vm.classes
  }, [_c('div', {
    staticClass: "ui-swiper-item__wrapper"
  }, [_vm._t("default")], 2)])]);
};

var __vue_staticRenderFns__$D = [];
/* style */

var __vue_inject_styles__$J = undefined;
/* scoped */

var __vue_scope_id__$J = undefined;
/* module identifier */

var __vue_module_identifier__$J = undefined;
/* functional template */

var __vue_is_functional_template__$J = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$J = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$D,
  staticRenderFns: __vue_staticRenderFns__$D
}, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, false, undefined, undefined, undefined);

var script$I = {
  name: 'ui-switch',
  props: {
    name: String,
    label: String,
    tabindex: [String, Number],
    value: {
      required: true
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: true
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: false
    },
    submittedValue: {
      type: String,
      default: 'on' // HTML default

    },
    checked: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: 'primary' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    position: {
      type: String,
      default: 'left' // 'left' or 'right'

    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      isChecked: looseEqual$1(this.value, this.trueValue) || this.checked,
      initialValue: this.value
    };
  },
  computed: {
    classes: function classes() {
      return ["ui-switch--color-".concat(this.color), "ui-switch--switch-position-".concat(this.position), {
        'is-active': this.isActive
      }, {
        'is-checked': this.isChecked
      }, {
        'is-disabled': this.disabled
      }];
    }
  },
  watch: {
    value: function value() {
      this.isChecked = looseEqual$1(this.value, this.trueValue);
    }
  },
  created: function created() {
    this.$emit('input', this.isChecked ? this.trueValue : this.falseValue);
  },
  methods: {
    focus: function focus() {
      this.$refs.input.focus();
    },
    onClick: function onClick(e) {
      var isCheckedPrevious = this.isChecked;
      var isChecked = e.target.checked;
      this.$emit('input', isChecked ? this.trueValue : this.falseValue, e);

      if (isCheckedPrevious !== isChecked) {
        e.target.checked = isCheckedPrevious; // å°checkedè¿åï¼ç¡®ä¿åæ¢ç¶ææ¯ç±valueæ¹åï¼èéåçç»ä»¶æ¬èº«åæ¢;

        this.$emit('change', isChecked ? this.trueValue : this.falseValue, e);
      }
    },
    onFocus: function onFocus(e) {
      this.isActive = true;
      this.$emit('focus', e);
    },
    onBlur: function onBlur(e) {
      this.isActive = false;
      this.$emit('blur', e);
    }
  }
};

/* script */
var __vue_script__$I = script$I;
/* template */

var __vue_render__$C = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('label', {
    staticClass: "ui-switch",
    class: _vm.classes
  }, [_c('div', {
    staticClass: "ui-switch__input-wrapper"
  }, [_c('input', {
    ref: "input",
    staticClass: "ui-switch__input",
    attrs: {
      "type": "checkbox",
      "disabled": _vm.disabled,
      "name": _vm.name,
      "tabindex": _vm.tabindex
    },
    domProps: {
      "checked": _vm.isChecked,
      "value": _vm.submittedValue
    },
    on: {
      "blur": _vm.onBlur,
      "click": _vm.onClick,
      "focus": _vm.onFocus
    }
  }), _vm._v(" "), _vm._m(0), _vm._v(" "), _c('div', {
    staticClass: "ui-switch__track"
  })]), _vm._v(" "), _vm.label || _vm.$slots.default ? _c('div', {
    staticClass: "ui-switch__label-text"
  }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
};

var __vue_staticRenderFns__$C = [function () {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-switch__thumb"
  }, [_c('div', {
    staticClass: "ui-switch__focus-ring"
  })]);
}];
/* style */

var __vue_inject_styles__$I = undefined;
/* scoped */

var __vue_scope_id__$I = undefined;
/* module identifier */

var __vue_module_identifier__$I = undefined;
/* functional template */

var __vue_is_functional_template__$I = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$I = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$C,
  staticRenderFns: __vue_staticRenderFns__$C
}, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, false, undefined, undefined, undefined);

var script$H = {
  name: 'ui-table-column',
  components: {},
  props: {
    tag: {
      type: String,
      default: 'th'
    },
    content: {
      type: [String, Number],
      default: ''
    },
    column: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  computed: {
    hasTooltip: function hasTooltip() {
      return this.column.width && false !== this.column.ellipsis && !this.column.type && this.content;
    },
    classes: function classes() {
      var _ref;

      return _ref = {
        'ui-table-column': true
      }, defineProperty$2(_ref, 'is-' + this.column.align, this.column.align), defineProperty$2(_ref, 'is-ellipsis', false !== this.column.ellipsis), _ref;
    }
  },
  methods: {
    numToPx: numToPx
  }
};

/* script */
var __vue_script__$H = script$H;
/* template */

var __vue_render__$B = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return !(_vm.$attrs.rowSpan === 0 || _vm.$attrs.colSpan === 0) ? _c(_vm.tag, _vm._b({
    tag: "component",
    class: !_vm.column.width && _vm.classes
  }, 'component', _vm.$attrs, false), [_vm.column.width ? _c('div', {
    directives: [{
      name: "tooltip",
      rawName: "v-tooltip",
      value: this.hasTooltip ? {
        content: _vm.content,
        classes: 'ui-table-column__tooltip',
        boundariesElement: 'viewport'
      } : '',
      expression: "\n      this.hasTooltip\n        ? {\n            content: content,\n            classes: 'ui-table-column__tooltip',\n            boundariesElement: 'viewport',\n          }\n        : ''\n    "
    }],
    class: _vm.classes,
    style: {
      width: _vm.numToPx(_vm.column.width),
      minWidth: '100%'
    }
  }, [_vm._t("default")], 2) : [_vm._t("default")]], 2) : _vm._e();
};

var __vue_staticRenderFns__$B = [];
/* style */

var __vue_inject_styles__$H = undefined;
/* scoped */

var __vue_scope_id__$H = undefined;
/* module identifier */

var __vue_module_identifier__$H = undefined;
/* functional template */

var __vue_is_functional_template__$H = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$H = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$B,
  staticRenderFns: __vue_staticRenderFns__$B
}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, false, undefined, undefined, undefined);

var script$G = {
  name: 'ui-table-layout',
  inject: ['$table'],
  components: {
    UiTableColumn: __vue_component__$H
  },
  props: {
    isFixed: {
      type: Boolean,
      default: false
    },
    headerRows: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    columns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    leafColumns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    bodyStyle: {
      type: Object,
      default: null
    }
  },
  computed: {
    data: function data() {
      return this.$table.data || [];
    },
    footerData: function footerData() {
      if (!this.$table.footerData) return [];
      return [].concat('function' === typeof this.$table.footerData ? this.$table.footerData(this.data) : this.$table.footerData);
    }
  },
  methods: {
    getHeaderStyle: function getHeaderStyle() {
      if (!this.$table.isStickyHeader) return null;
      var rect = this.$el.getBoundingClientRect();
      return {
        top: numToPx(this.$table.stickyOffset.top),
        left: numToPx(rect.left),
        width: numToPx(rect.width)
      };
    },
    getFooterStyle: function getFooterStyle(body) {
      if (!this.$table.isStickyFooter) return null;
      var rect = this.$el.getBoundingClientRect();
      return {
        bottom: numToPx(this.$table.stickyOffset.bottom),
        left: numToPx(rect.left),
        width: numToPx(rect.width)
      };
    },
    getRowRender: function getRowRender(_ref) {
      var rows = _ref.rows,
          columns = _ref.columns,
          rowsHeight = _ref.rowsHeight,
          cellsWidth = _ref.cellsWidth,
          customRow = _ref.customRow,
          customCell = _ref.customCell,
          slotRender = _ref.slotRender,
          cellBind = _ref.cellBind,
          isFixed = _ref.isFixed;
      var h = this.$createElement;
      isFixed = isFixed || this.isFixed;
      var customRowFn = wrapFn(customRow);
      var customCellFn = wrapFn(customCell);
      var columnsFn = wrapFn(columns);
      return rows.map(function (row, rowIndex) {
        return h("tr", helper([{}, deepmerge_1({
          style: isFixed ? {
            height: numToPx(rowsHeight[rowIndex])
          } : {}
        }, customRowFn({
          row: row,
          rowIndex: rowIndex
        }) || {})]), [columnsFn(row, rowIndex).map(function (column, columnIndex) {
          return h("ui-table-column", helper([{}, deepmerge_1.all([{
            style: isFixed ? {
              width: numToPx(cellsWidth[column.$$id]),
              minWidth: numToPx(cellsWidth[column.$$id])
            } : {}
          }, customCellFn({
            row: row,
            column: column,
            rowIndex: rowIndex,
            columnIndex: columnIndex
          }) || {}, cellBind({
            row: row,
            column: column,
            rowIndex: rowIndex,
            columnIndex: columnIndex
          })])]), [slotRender({
            row: row,
            column: column,
            rowIndex: rowIndex,
            columnIndex: columnIndex
          })]);
        })]);
      });
    },

    /* è¡¨æ ¼-é¡µå¤´ */
    getHeaderRender: function getHeaderRender(isFixed) {
      var h = this.$createElement;
      isFixed = isFixed || this.isFixed;
      return h("thead", [this.getRowRender({
        isFixed: isFixed,
        rows: this.headerRows,
        columns: function columns(row) {
          return row;
        },
        rowsHeight: this.$table.headerRowHeight,
        cellsWidth: this.$table.cellWidth,
        customRow: this.$table.customHeaderRow,
        customCell: this.$table.customHeaderCell,
        slotRender: this.$scopedSlots.headerRender,
        cellBind: function cellBind(_ref2) {
          _ref2.row;
              var column = _ref2.column;
              _ref2.rowIndex;
              _ref2.columnIndex;
          return {
            props: {
              tag: 'th',
              column: column
            },
            attrs: {
              rowSpan: column.rowSpan,
              colSpan: column.colSpan,
              'data-row-key': !isFixed && column.$isLeaf ? column.$$id : void 0
            },
            style: column.width ? {
              width: numToPx(column.width),
              minWidth: numToPx(column.width)
            } : {}
          };
        }
      })]);
    },

    /* è¡¨æ ¼-åå®¹ */
    getBodyRender: function getBodyRender(isFixed) {
      var h = this.$createElement;
      return h("tbody", [this.getRowRender({
        isFixed: isFixed,
        rows: this.data,
        columns: this.leafColumns,
        rowsHeight: this.$table.bodyRowHeight,
        cellsWidth: this.$table.cellWidth,
        customRow: this.$table.customRow,
        customCell: this.$table.customCell,
        slotRender: this.$scopedSlots.cellRender,
        cellBind: function cellBind(_ref3) {
          var row = _ref3.row,
              column = _ref3.column;
              _ref3.rowIndex;
              _ref3.columnIndex;
          return {
            props: {
              tag: 'td',
              column: column,
              content: row[column.dataIndex]
            }
          };
        }
      })]);
    },

    /* è¡¨æ ¼-é¡µè */
    getFooterRender: function getFooterRender(isFixed) {
      var h = this.$createElement;
      return h("tfoot", [this.getRowRender({
        isFixed: isFixed,
        rows: this.footerData,
        columns: this.leafColumns,
        rowsHeight: this.$table.footerRowHeight,
        cellsWidth: this.$table.cellWidth,
        customRow: this.$table.customFooterRow,
        customCell: this.$table.customFooterCell,
        slotRender: this.$scopedSlots.footerRender,
        cellBind: function cellBind(_ref4) {
          var row = _ref4.row,
              column = _ref4.column;
              _ref4.rowIndex;
              _ref4.columnIndex;
          return {
            props: {
              tag: 'td',
              column: column,
              content: row[column.dataIndex]
            }
          };
        }
      })]);
    }
  },
  render: function render() {
    var h = arguments[0];
    return h("div", {
      "class": "ui-table-layout"
    }, [h("div", {
      "ref": "body",
      "class": "ui-table-body",
      "style": this.bodyStyle
    }, [h("table", [[// è¡¨æ ¼-é¡µå¤´
    this.getHeaderRender(), // è¡¨æ ¼-åå®¹
    this.data.length ? this.getBodyRender() : this.$scopedSlots.emptyRender({
      columns: this.leafColumns
    }), // è¡¨æ ¼-é¡µè
    this.footerData.length ? this.getFooterRender() : null]])]), h("div", {
      "ref": "header",
      "class": "ui-table-header",
      "style": this.getHeaderStyle()
    }, [h("table", [this.getHeaderRender(true)])]),
    /* è¡¨æ ¼-é¡µè--åºå®æµ®å¨å¨åºé¨ */
    this.footerData.length ? h("div", {
      "ref": "footer",
      "class": "ui-table-footer",
      "style": this.getFooterStyle()
    }, [h("table", [this.getFooterRender(true)])]) : null]);
  }
};

/* script */
var __vue_script__$G = script$G;
/* template */

/* style */

var __vue_inject_styles__$G = undefined;
/* scoped */

var __vue_scope_id__$G = undefined;
/* module identifier */

var __vue_module_identifier__$G = undefined;
/* functional template */

var __vue_is_functional_template__$G = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$G = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$F = {
  name: 'ui-table-sorter',
  props: {
    value: [String, Boolean]
  },
  methods: {
    onClick: function onClick() {
      if (this.value == 'asc') this.onChange('desc');else if (this.value == 'desc') this.onChange('');else this.onChange('asc');
    },
    onChange: function onChange(val) {
      this.$emit('change', val);
    }
  }
};

/* script */
var __vue_script__$F = script$F;
/* template */

var __vue_render__$A = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-table-sorter",
    on: {
      "click": _vm.onClick
    }
  }, [_vm._t("default"), _vm._v(" "), _c('span', {
    staticClass: "ui-table-sorter__asc",
    class: {
      'is-selected': _vm.value == 'asc'
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.onChange('asc');
      }
    }
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-table-sorter__desc",
    class: {
      'is-selected': _vm.value == 'desc'
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.onChange('desc');
      }
    }
  })], 2);
};

var __vue_staticRenderFns__$A = [];
/* style */

var __vue_inject_styles__$F = undefined;
/* scoped */

var __vue_scope_id__$F = undefined;
/* module identifier */

var __vue_module_identifier__$F = undefined;
/* functional template */

var __vue_is_functional_template__$F = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$F = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$A,
  staticRenderFns: __vue_staticRenderFns__$A
}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$E = {
  name: 'ui-table-filter',
  data: function data() {
    return {
      //éè¦è¿æ»¤çå¼
      filteredValue: [],
      isShow: false,
      prevScrollL: 0,
      prevScrollT: 0,
      scrollBody: null,
      searchPlaceholder: 'æç´¢',
      query: '',
      hasNoResults: false,
      newValue: []
    };
  },
  mounted: function mounted() {
    this.newValue = this.value;
  },
  props: {
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    hasSearch: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    query: function query() {
      var _this = this;

      this.newValue = this.value.filter(function (option) {
        var text = option.label;

        if (typeof text === 'string') {
          text = text.toLowerCase();
        }

        return ~String(text).indexOf(_this.query.toLowerCase());
      });

      if (this.newValue.length > 0) {
        this.hasNoResults = false;
      } else {
        this.hasNoResults = true;
      }
    }
  },
  methods: {
    clearQuery: function clearQuery() {
      this.query = '';
    },
    showHandle: function showHandle() {
      this.isShow = true;
    },
    hideHandle: function hideHandle() {
      this.isShow = false;
    },
    handleConfirm: function handleConfirm() {
      this.onChange();
      this.handleOutsideClick();
      this.clearQuery();
    },
    handleReset: function handleReset() {
      this.filteredValue = [];
      this.onChange();
      this.handleOutsideClick();
      this.clearQuery();
    },
    onChange: function onChange() {
      this.$emit('change', this.filteredValue);
    },
    handleOutsideClick: function handleOutsideClick() {
      var _this2 = this;

      setTimeout(function () {
        _this2.savePrevPos();

        _this2.isShow = false;
      }, 100);
    },
    savePrevPos: function savePrevPos() {
      this.prevScrollL = this.scrollBody.scrollLeft;
      this.prevScrollT = this.scrollBody.scrollTop;
    },
    handleScrollClose: function handleScrollClose(scrollBody) {
      this.scrollBody = scrollBody;

      if (!this.isShow) {
        this.savePrevPos();
        return false;
      }

      if (scrollBody.scrollLeft != this.prevScrollL || scrollBody.scrollTop != this.prevScrollT) this.isShow = false;
    }
  }
};

/* script */
var __vue_script__$E = script$E;
/* template */

var __vue_render__$z = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-table__column-filter"
  }, [_c('ui-dropdown', {
    attrs: {
      "type": "text",
      "has-arrow": "",
      "dropdown-position": "bottom-end",
      "open": _vm.isShow
    },
    on: {
      "open": _vm.showHandle,
      "close": _vm.hideHandle
    }
  }, [_c('div', {
    attrs: {
      "slot": "dropdown"
    },
    slot: "dropdown"
  }, [_vm.hasSearch ? _c('div', {
    staticClass: "ui-select__search",
    on: {
      "click": function click($event) {
        $event.stopPropagation();
      },
      "keydown": function keydown($event) {
        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])) {
          return null;
        }

        $event.stopPropagation();
      }
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.query,
      expression: "query"
    }],
    ref: "searchInput",
    staticClass: "ui-select__search-input",
    attrs: {
      "type": "text",
      "autocomplete": "off",
      "placeholder": _vm.searchPlaceholder
    },
    domProps: {
      "value": _vm.query
    },
    on: {
      "input": function input($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.query = $event.target.value;
      }
    }
  }), _vm._v(" "), _c('ui-icon', {
    staticClass: "ui-select__search-icon"
  }, [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M9.516 14.016c2.484 0 4.5-2.016 4.5-4.5s-2.016-4.5-4.5-4.5-4.5 2.016-4.5 4.5 2.016 4.5 4.5 4.5zm6 0l4.97 4.97-1.5 1.5-4.97-4.97v-.797l-.28-.282c-1.126.984-2.626 1.547-4.22 1.547-3.61 0-6.516-2.86-6.516-6.47S5.906 3 9.516 3s6.47 2.906 6.47 6.516c0 1.594-.564 3.094-1.548 4.22l.28.28h.798z"
    }
  })])]), _vm._v(" "), _vm.query ? _c('ui-icon', {
    staticClass: "ui-select__search-clearable",
    attrs: {
      "icon": "clear"
    },
    nativeOn: {
      "click": function click($event) {
        $event.preventDefault();
        $event.stopPropagation();
        return _vm.clearQuery($event);
      }
    }
  }) : _vm._e()], 1) : _vm._e(), _vm._v(" "), _c('ui-checkbox-group', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.hasNoResults,
      expression: "!hasNoResults"
    }],
    staticClass: "ui-table-filter__menu",
    attrs: {
      "name": "filteredValue",
      "options": _vm.newValue,
      "vertical": ""
    },
    model: {
      value: _vm.filteredValue,
      callback: function callback($$v) {
        _vm.filteredValue = $$v;
      },
      expression: "filteredValue"
    }
  }), _vm._v(" "), _vm.hasNoResults ? _c('div', {
    staticClass: "ui-select__no-results"
  }, [_vm._t("no-results", [_vm._v("æªæ¾å°ç»æ")])], 2) : _c('div', {
    staticClass: "ui-table-filter__bottom"
  }, [_c('ui-button', {
    attrs: {
      "color": "primary",
      "size": "small"
    },
    on: {
      "click": _vm.handleReset
    }
  }, [_vm._v("éç½®")]), _vm._v(" "), _c('ui-button', {
    attrs: {
      "color": "primary",
      "size": "small",
      "disabled": _vm.filteredValue.length === 0
    },
    on: {
      "click": _vm.handleConfirm
    }
  }, [_vm._v("ç­é")])], 1)], 1)])], 1);
};

var __vue_staticRenderFns__$z = [];
/* style */

var __vue_inject_styles__$E = undefined;
/* scoped */

var __vue_scope_id__$E = "data-v-ea3a6580";
/* module identifier */

var __vue_module_identifier__$E = undefined;
/* functional template */

var __vue_is_functional_template__$E = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$E = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$z,
  staticRenderFns: __vue_staticRenderFns__$z
}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, false, undefined, undefined, undefined);

var ColumnRender = {
  /* ç´¢å¼ */
  index: {
    renderHeader: function renderHeader(_ref) {
      _ref.column;
          _ref.columnIndex;
      return 'åºå·';
    },
    renderCell: function renderCell(_ref2) {
      _ref2.row;
          _ref2.column;
          var rowIndex = _ref2.rowIndex;
          _ref2.columnIndex;
      return rowIndex + 1;
    },
    renderFooter: function renderFooter(_ref3) {
      _ref3.row;
          _ref3.column;
          _ref3.rowIndex;
          _ref3.columnIndex;
      return '#';
    }
  },

  /* éæ©æ¡ */
  selection: {
    renderHeader: function renderHeader(_ref4) {
      var _this = this;

      var column = _ref4.column;
          _ref4.columnIndex;
      var h = this.$createElement;
      return h("ui-checkbox", {
        "attrs": {
          "indeterminate": this.selects.length > 0 && this.selects.length < this.data.length - this.filterDisabled().disLength,
          "value": this.selects.length === this.data.length - this.filterDisabled().disLength && this.data.length > 0 && this.filterDisabled().disableds.length > 0
        },
        "on": {
          "change": function change($event) {
            return _this.selectAllChange($event, column.dataIndex);
          }
        }
      });
    },
    renderCell: function renderCell(_ref5) {
      var _this2 = this;

      var row = _ref5.row,
          column = _ref5.column;
          _ref5.rowIndex;
          _ref5.columnIndex;
      var h = this.$createElement;
      return h("ui-checkbox", {
        "attrs": {
          "disabled": row.disabled,
          "value": !!~this.selectIndexOf(row, column.dataIndex)
        },
        "on": {
          "change": function change($event) {
            return _this2.selectChange($event, row, column.dataIndex);
          }
        }
      });
    },
    renderFooter: function renderFooter(_ref6) {
      var _this3 = this;

      _ref6.row;
          var column = _ref6.column;
          _ref6.rowIndex;
          _ref6.columnIndex;
      var h = this.$createElement;
      return h("ui-checkbox", {
        "attrs": {
          "indeterminate": this.selects.length > 0 && this.selects.length < this.data.length - this.filterDisabled().disLength,
          "value": this.selects.length === this.data.length - this.filterDisabled().disLength && this.data.length > 0
        },
        "on": {
          "change": function change($event) {
            return _this3.selectAllChange($event, column.dataIndex);
          }
        }
      });
    }
  },

  /* é»è®¤ */
  default: {
    renderHeader: function renderHeader(_ref7) {
      var column = _ref7.column;
          _ref7.columnIndex;
      var h = this.$createElement;
      return h("span", {
        "domProps": {
          "innerHTML": column.title || '#'
        }
      });
    },
    renderCell: function renderCell(_ref8) {
      var row = _ref8.row,
          column = _ref8.column;
          _ref8.rowIndex;
          _ref8.columnIndex;
      var h = this.$createElement;
      return h("span", {
        "domProps": {
          "innerHTML": row[column.dataIndex] || '-'
        }
      });
    },
    renderFooter: function renderFooter(_ref9) {
      var row = _ref9.row,
          column = _ref9.column;
          _ref9.rowIndex;
          _ref9.columnIndex;
      var h = this.$createElement;
      return h("span", {
        "domProps": {
          "innerHTML": row[column.dataIndex] || '-'
        }
      });
    }
  }
  /* å±å¼è¡ */

  /* expand: {
        renderHeader({}) {
            const h = this.$createElement;
         },
        renderCell({}) {
            const h = this.$createElement;
         },
        renderFooter({ row, column, rowIndex, columnIndex }) {
         }
    }, */

};

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var ColumnManager = /*#__PURE__*/function () {
  function ColumnManager(columns) {
    classCallCheck(this, ColumnManager);

    this._columns = columns;
    this._cached = {};
  }

  createClass(ColumnManager, [{
    key: "isAnyColumnsFixed",
    value: function isAnyColumnsFixed() {
      var _this = this;

      return this._cache('isAnyColumnsFixed', function () {
        return _this._columns.some(function (column) {
          return !!column.fixed;
        });
      });
    }
  }, {
    key: "isAnyColumnsLeftFixed",
    value: function isAnyColumnsLeftFixed() {
      var _this2 = this;

      return this._cache('isAnyColumnsLeftFixed', function () {
        return _this2._columns.some(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    }
  }, {
    key: "isAnyColumnsRightFixed",
    value: function isAnyColumnsRightFixed() {
      var _this3 = this;

      return this._cache('isAnyColumnsRightFixed', function () {
        return _this3._columns.some(function (column) {
          return column.fixed === 'right';
        });
      });
    }
  }, {
    key: "leftColumns",
    value: function leftColumns() {
      var _this4 = this;

      return this._cache('leftColumns', function () {
        return _this4.groupedColumns().filter(function (column) {
          return column.fixed === 'left' || column.fixed === true;
        });
      });
    }
  }, {
    key: "rightColumns",
    value: function rightColumns() {
      var _this5 = this;

      return this._cache('rightColumns', function () {
        return _this5.groupedColumns().filter(function (column) {
          return column.fixed === 'right';
        });
      });
    }
  }, {
    key: "leafColumns",
    value: function leafColumns() {
      var _this6 = this;

      return this._cache('leafColumns', function () {
        return _this6._leafColumns(_this6.groupedColumns());
      });
    }
  }, {
    key: "leftLeafColumns",
    value: function leftLeafColumns() {
      var _this7 = this;

      return this._cache('leftLeafColumns', function () {
        return _this7._leafColumns(_this7.leftColumns());
      });
    }
  }, {
    key: "rightLeafColumns",
    value: function rightLeafColumns() {
      var _this8 = this;

      return this._cache('rightLeafColumns', function () {
        return _this8._leafColumns(_this8.rightColumns());
      });
    } // add appropriate rowspan and colspan to column

  }, {
    key: "headerRows",
    value: function headerRows() {
      var _this9 = this;

      return this._cache('headerRows', function () {
        return _this9._headerRows(_this9.groupedColumns());
      });
    }
  }, {
    key: "leftHeaderRows",
    value: function leftHeaderRows() {
      var _this10 = this;

      return this._cache('leftHeaderRows', function () {
        return _this10._headerRows(_this10.leftColumns());
      });
    }
  }, {
    key: "rightHeaderRows",
    value: function rightHeaderRows() {
      var _this11 = this;

      return this._cache('rightHeaderRows', function () {
        return _this11._headerRows(_this11.rightColumns());
      });
    } // add appropriate rowspan and colspan to column

  }, {
    key: "groupedColumns",
    value: function groupedColumns() {
      var _this12 = this;

      return this._cache('groupedColumns', function () {
        var uuid = 0;

        var _groupColumns = function _groupColumns(columns) {
          var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var parentColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          // track how many rows we got
          rows[currentRow] = rows[currentRow] || [];
          var grouped = [];

          var setRowSpan = function setRowSpan(column) {
            var rowSpan = rows.length - currentRow;

            if (column && !column.children && // parent columns are supposed to be one row
            rowSpan > 1 && (!column.rowSpan || column.rowSpan < rowSpan)) {
              column.rowSpan = rowSpan;
            }
          };

          columns.forEach(function (column, index) {
            if (false === column.visible) return;

            var newColumn = _objectSpread$a(_objectSpread$a({}, column), {}, {
              $$id: "".concat(currentRow, "_").concat(++uuid)
            });

            rows[currentRow].push(newColumn);
            parentColumn.colSpan = parentColumn.colSpan || 0;

            if (newColumn.children && newColumn.children.length > 0) {
              newColumn.children = _groupColumns(newColumn.children, currentRow + 1, newColumn, rows);
              parentColumn.colSpan += newColumn.colSpan;
            } else {
              newColumn.$isLeaf = true;
              parentColumn.colSpan += 1;
            } // update rowspan to all same row columns


            for (var i = 0; i < rows[currentRow].length - 1; i += 1) {
              setRowSpan(rows[currentRow][i]);
            } // last column, update rowspan immediately


            if (index + 1 === columns.length) {
              setRowSpan(newColumn);
            }

            grouped.push(newColumn);
          });
          return grouped;
        };

        return _groupColumns(_this12._columns);
      });
    }
  }, {
    key: "reset",
    value: function reset(columns) {
      this._columns = columns;
      this._cached = {};
    }
  }, {
    key: "_cache",
    value: function _cache(name, fn) {
      if (name in this._cached) {
        return this._cached[name];
      }

      this._cached[name] = fn();
      return this._cached[name];
    }
  }, {
    key: "_leafColumns",
    value: function _leafColumns(columns) {
      var _this13 = this;

      var leafColumns = [];
      columns.forEach(function (column) {
        if (!column.children) {
          leafColumns.push(column);
        } else {
          leafColumns.push.apply(leafColumns, toConsumableArray(_this13._leafColumns(column.children)));
        }
      });
      return leafColumns;
    }
  }, {
    key: "_headerRows",
    value: function _headerRows() {
      var _this14 = this;

      var columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var currentRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var rows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      rows[currentRow] = rows[currentRow] || [];
      columns.forEach(function (column, index) {
        if (column.rowSpan && rows.length < column.rowSpan) {
          while (rows.length < column.rowSpan) {
            rows.push([]);
          }
        }

        if (column.colSpan !== 0) {
          rows[currentRow].push(column);
        }

        if (column.children && column.children.length > 0) {
          _this14._headerRows(column.children, currentRow + 1, rows);
        }
      });
      return rows; //.filter(row => row.length > 0);
    }
  }]);

  return ColumnManager;
}();

function getMutationObserver(callback) {
  var mo;

  if (typeof MutationObserver !== 'undefined') {
    mo = new MutationObserver(callback);
    mo.observe(document, {
      attributes: true,
      childList: true,
      characterData: true,
      subtree: true
    });
  } else {
    document.addEventListener('DOMSubtreeModified', callback);
    mo = {
      disconnect: function disconnect() {
        document.removeEventListener('DOMSubtreeModified', callback);
      }
    };
  }

  return mo;
}

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$D = {
  name: 'ui-table',
  provide: function provide() {
    return {
      $table: this
    };
  },
  components: {
    UiProgressLinear: __vue_component__$T,
    UiCheckbox: __vue_component__$1p,
    UiTableLayout: __vue_component__$G,
    UiTableSorter: __vue_component__$F,
    UiTableFilter: __vue_component__$E
  },
  props: {
    loading: Boolean,
    columns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    footerData: {
      type: [Function, Object, Array],
      default: null
    },

    /* å¤éæ¡ */
    selects: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /* æåº */
    sorts: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /* è¡¨æ ¼çé«åº¦ */
    height: {
      type: String,
      default: '80vh'
    },
    customHeaderRow: {
      type: [Function, Object],
      default: null
    },
    customHeaderCell: {
      type: [Function, Object],
      default: null
    },
    customRow: {
      type: [Function, Object],
      default: null
    },
    customCell: {
      type: [Function, Object],
      default: null
    },
    customFooterRow: {
      type: [Function, Object],
      default: null
    },
    customFooterCell: {
      type: [Function, Object],
      default: null
    },

    /* å¸é¡¶è·ç¦» */
    stickyContainer: {
      type: String,
      default: 'window' // ä½¿ç¨æ¶æ ¹æ®æ»å¨ä½ç½®è®¾ç½®ï¼ä¾å¦#app

    },
    stickyOffset: {
      type: Object,
      default: null
    },
    hasSearch: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      columnManager: new ColumnManager(this.columns),
      scrollPosition: 'hidden',
      isStickyHeader: false,
      isStickyFooter: false,
      stickyElem: null,
      mutation: null,
      debouncedResize: function debouncedResize() {},
      cellWidth: {},
      headerRowHeight: [],
      bodyRowHeight: [],
      footerRowHeight: []
    };
  },
  watch: {
    columns: function columns(val) {
      if (val) {
        this.columnManager.reset(val);
      }
    }
  },
  created: function created() {
    this.debouncedResize = lodash_debounce(this.onResize, 150);
  },
  mounted: function mounted() {
    var _this = this;

    if (this.stickyOffset) {
      this.stickyElem = this.stickyContainer && (this.stickyContainer === 'window' ? window : document.querySelector(this.stickyContainer));
    }

    this.$nextTick(function () {
      _this.debouncedResize();

      var _this$getLayoutRefs = _this.getLayoutRefs(),
          scrollBody = _this$getLayoutRefs.scrollBody;

      scrollBody.addEventListener('scroll', _this.onScrollBody); // å¼¹åºæ¡åµå¥è¡¨æ ¼æ¶ï¼ç±äºå¨ç»ä¼å¯¼è´ä¸å¼å§å®½åº¦è®¡ç®éè¯¯çé®é¢

      _this.mutation = getMutationObserver(_this.debouncedResize);

      if (_this.stickyElem) {
        window.addEventListener('resize', _this.debouncedResize);

        _this.stickyElem.addEventListener('scroll', _this.onScrollSticky);

        _this.onScrollSticky();
      }
    });
  },
  updated: function updated() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.debouncedResize();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.stickyElem) {
      window.removeEventListener('resize', this.debouncedResize);
      this.stickyElem.removeEventListener('scroll', this.onScrollSticky);
    }

    var _this$getLayoutRefs2 = this.getLayoutRefs(),
        scrollBody = _this$getLayoutRefs2.scrollBody;

    scrollBody.addEventListener('scroll', this.onScrollBody);
    this.debouncedResize && this.debouncedResize.cancel();
    this.mutation && this.mutation.disconnect();
  },
  methods: {
    filterDisabled: function filterDisabled() {
      var arr = [];
      var leg = 0;
      this.data.forEach(function (item) {
        if (!item.disabled) {
          arr.push(item);
        } else {
          leg++;
        }
      });
      return {
        disableds: arr,
        disLength: leg
      };
    },
    selectIndexOf: function selectIndexOf(data, key) {
      return this.selects.findIndex(function (select) {
        return select[key] === data[key];
      });
    },
    selectAllChange: function selectAllChange(checked, key) {
      var selects = checked ? toConsumableArray(this.filterDisabled().disableds) : [];
      this.$emit('select', selects);
    },
    selectChange: function selectChange(checked, data, key) {
      var i = this.selectIndexOf(data, key);
      var selects = [];

      if (checked && i < 0) {
        selects = [].concat(this.selects, data);
      }

      if (!checked && i > -1) {
        selects = this.selects.slice(0, i).concat(this.selects.slice(i + 1));
      }

      this.$emit('select', selects);
    },
    onResize: function onResize() {
      this.onScrollBody();
      this.syncTableColumnSize();
    },
    onScrollSticky: function onScrollSticky() {
      if (!this.stickyOffset) return;

      var _this$getLayoutRefs3 = this.getLayoutRefs(),
          scroll = _this$getLayoutRefs3.scroll,
          scrollHeader = _this$getLayoutRefs3.scrollHeader,
          scrollFooter = _this$getLayoutRefs3.scrollFooter;

      var getHeight = function getHeight(elem) {
        return elem ? elem.getBoundingClientRect().height : 0;
      };

      var offsetHeight = getHeight(scrollHeader) + getHeight(scrollFooter);
      var rect = scroll.$el.getBoundingClientRect();
      this.isStickyHeader = 'number' === typeof this.stickyOffset.top && rect.top < this.stickyOffset.top && rect.bottom > offsetHeight;
      this.isStickyFooter = 'number' === typeof this.stickyOffset.bottom && rect.top < window.innerHeight - offsetHeight && rect.bottom > window.innerHeight + this.stickyOffset.bottom;
    },
    onScrollBody: function onScrollBody() {
      var _this$getLayoutRefs4 = this.getLayoutRefs(),
          scrollHeader = _this$getLayoutRefs4.scrollHeader,
          scrollBody = _this$getLayoutRefs4.scrollBody,
          scrollFooter = _this$getLayoutRefs4.scrollFooter,
          leftFixedBody = _this$getLayoutRefs4.leftFixedBody,
          rightFixedBody = _this$getLayoutRefs4.rightFixedBody;

      if (leftFixedBody) leftFixedBody.scrollTop = scrollBody.scrollTop;
      if (rightFixedBody) rightFixedBody.scrollTop = scrollBody.scrollTop;
      if (scrollHeader) scrollHeader.scrollLeft = scrollBody.scrollLeft;
      if (scrollFooter) scrollFooter.scrollLeft = scrollBody.scrollLeft; // è®¡ç®æ»å¨æ¡çä½ç½®

      if (Math.abs(scrollBody.scrollWidth - scrollBody.clientWidth) <= 1) this.scrollPosition = 'hidden'; // æ»å¨æ¡éèæ¶
      else if (scrollBody.scrollLeft <= 1) this.scrollPosition = 'left'; // æ»å¨æ¡è´´è¿å·¦ä¾§
        else if (scrollBody.scrollLeft >= scrollBody.scrollWidth - scrollBody.clientWidth) this.scrollPosition = 'right'; // æ»å¨æ¡è´´è¿å³ä¾§
          else this.scrollPosition = 'middle'; // æ»å¨æ¡é ä¸­é´

      this.closeDropDown(scrollBody);
    },

    /* æ´æ°æ ¼å­å®½é« */
    syncTableColumnSize: function syncTableColumnSize() {
      var _this$getLayoutRefs5 = this.getLayoutRefs(),
          scrollBody = _this$getLayoutRefs5.scrollBody;

      if (!scrollBody) return;
      var hds = scrollBody.querySelectorAll('thead tr th[data-row-key]');
      var cellWidth = {},
          hUpdate = false;

      for (var i = 0; i < hds.length; i++) {
        var key = hds[i].getAttribute('data-row-key');
        cellWidth[key] = hds[i].getBoundingClientRect().width;
        if (cellWidth[key] !== this.cellWidth[key]) hUpdate = true;
      }

      if (hUpdate) {
        this.cellWidth = cellWidth;
      }

      var getRowHeight = function getRowHeight(selector, rowHeight) {
        var rows = scrollBody.querySelectorAll(selector);
        var newRowHeight = Array.from(rows).map(function (el) {
          return el.getBoundingClientRect().height;
        });
        return JSON.stringify(newRowHeight) === JSON.stringify(rowHeight) ? rowHeight : newRowHeight;
      };

      this.headerRowHeight = getRowHeight('thead tr', this.headerRowHeight);
      this.bodyRowHeight = getRowHeight('tbody tr', this.bodyRowHeight);
      this.footerRowHeight = getRowHeight('tfoot tr', this.footerRowHeight);
    },
    getLayoutRefs: function getLayoutRefs() {
      var _this$$refs = this.$refs,
          scroll = _this$$refs.scroll,
          leftFixed = _this$$refs.leftFixed,
          rightFixed = _this$$refs.rightFixed;
      return _objectSpread$9(_objectSpread$9(_objectSpread$9({}, scroll && {
        scroll: scroll,
        scrollHeader: scroll.$refs.header,
        scrollBody: scroll.$refs.body,
        scrollFooter: scroll.$refs.footer
      }), leftFixed && {
        leftFixed: leftFixed,
        leftFixedHeader: leftFixed.$refs.header,
        leftFixedBody: leftFixed.$refs.body,
        leftFixedFooter: leftFixed.$refs.footer
      }), rightFixed && {
        rightFixed: rightFixed,
        rightFixedHeader: rightFixed.$refs.header,
        rightFixedBody: rightFixed.$refs.body,
        rightFixedFooter: rightFixed.$refs.footer
      });
    },
    getSlotRender: function getSlotRender(column, slotName) {
      if ('function' === typeof column[slotName]) return column[slotName];else if (this.$scopedSlots[column[slotName]]) return this.$scopedSlots[column[slotName]];else if (ColumnRender[column.type]) return ColumnRender[column.type][slotName];
      return ColumnRender['default'][slotName];
    },
    getTableRender: function getTableRender(ref, staticClass, props) {
      var _this3 = this;

      var h = this.$createElement;
      return h("ui-table-layout", helper([{
        "ref": ref,
        "staticClass": staticClass,
        "class": {
          'is-sticky-header': this.isStickyHeader,
          'is-sticky-footer': this.isStickyFooter
        }
      }, {
        "props": props
      }, {
        "scopedSlots": {
          headerRender: function headerRender(props) {
            var column = props.column;
                props.columnIndex;

            var render = _this3.getSlotRender(column, 'renderHeader');

            return [column.sort ? h("ui-table-sorter", {
              "attrs": {
                "value": _this3.sorts[column.dataIndex]
              },
              "on": {
                "change": function change($event) {
                  return _this3.$emit('sort', $event, column);
                }
              }
            }, [render.call(_this3, props)]) : render.call(_this3, props), column.filters && h("ui-table-filter", {
              "attrs": {
                "value": column.filters,
                "hasSearch": _this3.hasSearch
              },
              "on": {
                "change": function change($event) {
                  return _this3.$emit('filter-method', $event, column);
                }
              },
              "ref": "filters"
            }, [render.call(_this3, props)])];
          },
          footerRender: function footerRender(props) {
            var column = props.column;
                props.columnIndex;

            var render = _this3.getSlotRender(column, 'renderFooter');

            return render.call(_this3, props);
          },
          cellRender: function cellRender(props) {
            props.row;
                var column = props.column;
                props.rowIndex;
                props.columnIndex;

            var render = _this3.getSlotRender(column, 'renderCell');

            return render.call(_this3, props);
          },
          emptyRender: function emptyRender(props) {
            var columns = props.columns;
            return h("tr", [h("td", {
              "class": "ui-table__empty",
              "attrs": {
                "colspan": columns.length || 1
              }
            }, [h("ui-icon", [h("svg", {
              "attrs": {
                "width": "64",
                "height": "41",
                "viewBox": "0 0 64 41",
                "xmlns": "http://www.w3.org/2000/svg"
              }
            }, [h("g", {
              "attrs": {
                "transform": "translate(0 1)",
                "fill": "none",
                "fill-rule": "evenodd"
              }
            }, [h("ellipse", {
              "attrs": {
                "fill": "#f5f5f5",
                "cx": "32",
                "cy": "33",
                "rx": "32",
                "ry": "7"
              }
            }), h("g", {
              "attrs": {
                "stroke": "#d9d9d9",
                "fill-rule": "nonzero"
              }
            }, [h("path", {
              "attrs": {
                "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
              }
            }), h("path", {
              "attrs": {
                "fill": "#fafafa",
                "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
              }
            })])])])]), h("p", {
              "class": "ui-table__empty-text"
            }, ["\u6682\u65E0\u6570\u636E"])])]);
          }
        }
      }]));
    },
    closeDropDown: function closeDropDown(scrollBody) {
      this.$refs.filters && this.$refs.filters.handleScrollClose(scrollBody);
    }
  },
  render: function render() {
    var _ref;

    var h = arguments[0];
    // å¦æå­å¨å»ç»åï¼åçæï¼
    var leftFixedRender = null,
        rightFixedRender = null;

    if (this.columnManager.isAnyColumnsLeftFixed()) {
      leftFixedRender = this.getTableRender('leftFixed', 'ui-table__fixed ui-table__fixed--left', {
        isFixed: true,
        headerRows: this.columnManager.leftHeaderRows(),
        columns: this.columnManager.leftColumns(),
        leafColumns: this.columnManager.leftLeafColumns()
      });
    }

    if (this.columnManager.isAnyColumnsRightFixed()) {
      rightFixedRender = this.getTableRender('rightFixed', 'ui-table__fixed ui-table__fixed--right', {
        isFixed: true,
        headerRows: this.columnManager.rightHeaderRows(),
        columns: this.columnManager.rightColumns(),
        leafColumns: this.columnManager.rightLeafColumns()
      });
    }

    var bodyRender = this.getTableRender('scroll', 'ui-table__scroll', {
      isFixed: false,
      headerRows: this.columnManager.headerRows(),
      columns: this.columnManager.groupedColumns(),
      leafColumns: this.columnManager.leafColumns(),
      bodyStyle: {
        maxHeight: this.height
      }
    });
    return h("div", {
      "class": ['ui-table', (_ref = {}, defineProperty$2(_ref, "ui-table--scroll-position-".concat(this.scrollPosition), this.scrollPosition), defineProperty$2(_ref, 'is-empty', !(this.data && this.data.length > 0)), _ref)]
    }, [this.$scopedSlots.loading ? this.$scopedSlots.loading({
      loading: this.loading
    }) : h("ui-progress-linear", {
      "class": {
        'is-hidden': !this.loading
      },
      "attrs": {
        "color": "primary",
        "type": "indeterminate"
      }
    }), h("div", {
      "class": "ui-table__wrap"
    }, [h("div", {
      "class": "ui-table__inner"
    }, [[bodyRender, leftFixedRender, rightFixedRender]])])]);
  }
};

/* script */
var __vue_script__$D = script$D;
/* template */

/* style */

var __vue_inject_styles__$D = undefined;
/* scoped */

var __vue_scope_id__$D = undefined;
/* module identifier */

var __vue_module_identifier__$D = undefined;
/* functional template */

var __vue_is_functional_template__$D = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$D = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, false, undefined, undefined, undefined);

var script$C = {
  name: 'ui-tabs',
  props: {
    /**
     * @name tabsç±»å
     * @prop {string} type
     * @option default
     * @option card
     */
    type: {
      type: String,
      default: 'default' // default or card or button

    },

    /**
     * @name å°ºå¯¸
     * @prop {string} size
     * @option small
     * @option normal
     * @option large
     */
    size: {
      type: String,
      default: 'normal'
    },

    /**
     * @name æ ç­¾éä¸­çç´¢å¼
     * @prop {String} value
     */
    value: {
      type: [String, Number],
      default: ''
    },

    /**
     * @name optionsç±»å
     * @prop {Array|Object} options
     */
    options: {
      type: [Array, Object],
      default: function _default() {
        return [];
      }
    },

    /**
     * @name optionsç±»å
     * @prop {String} optionType
     * @option 0 - [label,label,label]ç±»å
     * @option 1 - [{label,value}]ç±»å
     * @option 2 - {value:label}ç±»å
     */
    optionType: {
      type: String,
      default: '1'
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    labelKey: {
      type: String,
      default: 'label'
    },

    /* æ¯å¦ç¦ç¨æ°´æ³¢çº¹ */
    disableRipple: {
      type: Boolean,
      default: false
    },
    sticky: {
      type: Boolean,
      default: false
    }
  },
  components: {
    UiRippleInk: __vue_component__$1A,
    UiIcon: __vue_component__$1B
  },
  data: function data() {
    return {
      activeValue: this.value,
      isStart: false,
      isEnd: false
    };
  },
  watch: {
    value: function value(val) {
      if (val !== this.activeValue) {
        this.activeValue = val;
      }
    },
    options: function options() {
      var _this = this;

      this.$nextTick(function () {
        _this.checkScrollPosition();
      });
    }
  },
  methods: {
    /**@param {Event} e */
    onRemove: function onRemove(e, item, i) {
      e.stopPropagation();
      e.preventDefault();
      this.$emit('remove', {
        item: item,
        i: i
      });
    },

    /**@param {MouseWheelEvent} e */
    onMouseWheel: function onMouseWheel(e) {
      var currentWidth = this.$el.firstElementChild.offsetWidth;
      var width = this.$el.firstElementChild.scrollWidth;

      if (width === currentWidth) {
        return;
      }

      e.preventDefault();
      this.$el.firstElementChild.scrollLeft += e.deltaY;
      this.checkScrollPosition();
    },
    onMouseenter: function onMouseenter(d) {
      var _this2 = this;

      cancelAnimationFrame(this.raf);
      this.$el.firstElementChild.scrollLeft += d;
      this.checkScrollPosition();
      this.raf = requestAnimationFrame(function () {
        cancelAnimationFrame(_this2.raf);

        _this2.onMouseenter(d);
      });
    },
    onMouseleave: function onMouseleave(d) {
      cancelAnimationFrame(this.raf);
    },
    onClick: function onClick(item, i) {
      switch (this.optionType) {
        case '0':
          this.activeValue = item;
          break;

        case '1':
          this.activeValue = item[this.valueKey];
          break;

        case '2':
          this.activeValue = i;
          break;
      }

      this.$emit('input', this.activeValue);
      this.$emit('change', this.activeValue);
    },
    getLabel: function getLabel(item) {
      switch (this.optionType) {
        case '0':
          return item;

        case '1':
          return item[this.labelKey];

        case '2':
          return item;
      }
    },
    checkScrollPosition: function checkScrollPosition() {
      cancelAnimationFrame(this.raf);
      var currentWidth = this.$el.firstElementChild.offsetWidth;
      var width = this.$el.firstElementChild.scrollWidth;
      var left = this.$el.firstElementChild.scrollLeft;

      if (width === currentWidth) {
        this.isStart = true;
        this.isEnd = true;
        return;
      }

      this.isStart = left === 0;
      this.isEnd = left === width - currentWidth;
    },
    checkIsAtv: function checkIsAtv(item, i) {
      switch (this.optionType) {
        case '0':
          return item === this.activeValue;

        case '1':
          return item[this.valueKey] === this.activeValue;

        case '2':
          return i === this.activeValue;
      }
    }
  },
  mounted: function mounted() {
    this.checkScrollPosition();
  },
  beforeDestroy: function beforeDestroy() {
    cancelAnimationFrame(this.raf);
  }
};

/* script */
var __vue_script__$C = script$C;
/* template */

var __vue_render__$y = function __vue_render__() {
  var _obj;

  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: (_obj = {
      'ui-tabs': true
    }, _obj["ui-tabs--type-" + _vm.type] = _vm.type, _obj["ui-tabs--size-" + _vm.size] = _vm.size, _obj['ui-tabs--sticky'] = _vm.sticky, _obj)
  }, [_c('div', {
    staticClass: "ui-tabs__header",
    on: {
      "mousewheel": _vm.onMouseWheel
    }
  }, [_c('div', {
    staticClass: "ui-tabs__header-content"
  }, _vm._l(_vm.options, function (item, i) {
    return _c('div', {
      key: i,
      class: {
        'ui-tabs__header-item': true,
        'is-active': _vm.checkIsAtv(item, i)
      },
      on: {
        "click": function click($event) {
          return _vm.onClick(item, i);
        }
      }
    }, [_c('div', {
      staticClass: "ui-tabs__header-item-content"
    }, [_vm._t("default", [_c('span', {
      staticClass: "ui-tabs__header-item-label"
    }, [_vm._v(_vm._s(_vm.getLabel(item)))])], null, {
      item: item,
      i: i
    }), _vm._v(" "), item.closeable ? _c('ui-icon', {
      staticClass: "ui-tabs__header-item-close",
      attrs: {
        "icon": "close"
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.onRemove($event, item, i);
        }
      }
    }) : _vm._e()], 2), _vm._v(" "), !_vm.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1);
  }), 0)]), _vm._v(" "), !_vm.isStart ? _c('div', {
    staticClass: "ui-tabs__btn-scroll ui-tabs__btn-scroll--prev",
    on: {
      "mouseenter": function mouseenter($event) {
        $event.stopPropagation();
        return _vm.onMouseenter(-10);
      },
      "mouseleave": function mouseleave($event) {
        $event.stopPropagation();
        return _vm.onMouseleave($event);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_left"
    }
  })], 1) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.isEnd,
      expression: "!isEnd"
    }],
    staticClass: "ui-tabs__btn-scroll ui-tabs__btn-scroll--next",
    on: {
      "mouseenter": function mouseenter($event) {
        $event.stopPropagation();
        return _vm.onMouseenter(10);
      },
      "mouseleave": function mouseleave($event) {
        $event.stopPropagation();
        return _vm.onMouseleave($event);
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "chevron_right"
    }
  })], 1)]);
};

var __vue_staticRenderFns__$y = [];
/* style */

var __vue_inject_styles__$C = undefined;
/* scoped */

var __vue_scope_id__$C = undefined;
/* module identifier */

var __vue_module_identifier__$C = undefined;
/* functional template */

var __vue_is_functional_template__$C = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$C = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$y,
  staticRenderFns: __vue_staticRenderFns__$y
}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, false, undefined, undefined, undefined);

var script$B = {
  name: 'ui-timeline',
  props: {
    reverse: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    }
  },
  provide: function provide() {
    return {
      UiTimeline: this
    };
  },
  computed: {
    classes: function classes() {
      return ['ui-timeline', "ui-timeline--color-".concat(this.color), {
        'is-reverse': this.reverse
      }];
    }
  },
  render: function render(createElement) {
    var slots = this.$slots.default || [];

    if (this.reverse) {
      // ååä¼æ¹ååæ°ç»ï¼æä»¥è¿éè¦å±å¼
      slots = toConsumableArray(slots).reverse();
    }

    return createElement('ul', {
      class: this.classes
    }, slots);
  }
};

/* script */
var __vue_script__$B = script$B;
/* template */

/* style */

var __vue_inject_styles__$B = undefined;
/* scoped */

var __vue_scope_id__$B = undefined;
/* module identifier */

var __vue_module_identifier__$B = undefined;
/* functional template */

var __vue_is_functional_template__$B = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$B = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, false, undefined, undefined, undefined);

//
var script$A = {
  name: 'ui-timeline-item',
  inject: ['UiTimeline'],
  props: {
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent', 'green', 'orange', or 'red'

    },
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },
    timestamp: String,
    hideDot: {
      type: Boolean,
      default: false
    },
    hideTimestamp: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    icon: String
  },
  computed: {
    classes: function classes() {
      return ['ui-timeline-item', "ui-timeline-item--color-".concat(this.color), "ui-timeline-item--size-".concat(this.size)];
    }
  },
  components: {
    UiIcon: __vue_component__$1B
  }
};

/* script */
var __vue_script__$A = script$A;
/* template */

var __vue_render__$x = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('li', {
    class: _vm.classes
  }, [_c('div', {
    staticClass: "ui-timeline-item__tail"
  }), _vm._v(" "), _vm.hideDot ? void 0 : _vm.$slots.dot ? _c('div', {
    staticClass: "ui-timeline-item__dot"
  }, [_vm._t("dot")], 2) : _c('div', {
    staticClass: "ui-timeline-item__node"
  }, [_vm.icon ? _c('ui-icon', {
    staticClass: "ui-timeline-item__icon",
    attrs: {
      "icon": _vm.icon
    }
  }) : _vm._e()], 1), _vm._v(" "), _c('div', {
    staticClass: "ui-timeline-item__wrapper"
  }, [!_vm.hideTimestamp && _vm.placement === 'top' ? _c('div', {
    staticClass: "ui-timeline-item__timestamp is-top"
  }, [_vm._v("\n      " + _vm._s(_vm.timestamp) + "\n    ")]) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-timeline-item__content"
  }, [_vm._t("default")], 2), _vm._v(" "), !_vm.hideTimestamp && _vm.placement === 'bottom' ? _c('div', {
    staticClass: "ui-timeline-item__timestamp is-bottom"
  }, [_vm._v("\n      " + _vm._s(_vm.timestamp) + "\n    ")]) : _vm._e()])], 2);
};

var __vue_staticRenderFns__$x = [];
/* style */

var __vue_inject_styles__$A = undefined;
/* scoped */

var __vue_scope_id__$A = undefined;
/* module identifier */

var __vue_module_identifier__$A = undefined;
/* functional template */

var __vue_is_functional_template__$A = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$A = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$x,
  staticRenderFns: __vue_staticRenderFns__$x
}, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, false, undefined, undefined, undefined);

//
var script$z = {
  name: 'ui-toolbar',
  props: {
    type: {
      type: String,
      default: 'default' // 'default', 'colored' or 'clear' - colored is brand primary color

    },
    textColor: {
      type: String,
      default: 'black' // 'black' or 'white'

    },
    title: String,
    brand: String,
    removeBrandDivider: {
      type: Boolean,
      default: false
    },
    navIcon: {
      type: String,
      default: 'menu'
    },
    removeNavIcon: {
      type: Boolean,
      default: false
    },
    raised: {
      type: Boolean,
      default: true
    },
    progressPosition: {
      type: String,
      default: 'bottom' // 'top' or 'bottom'

    },
    loading: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    classes: function classes() {
      return ["ui-toolbar--type-".concat(this.type), "ui-toolbar--text-color-".concat(this.textColor), "ui-toolbar--progress-position-".concat(this.progressPosition), {
        'is-raised': this.raised
      }];
    },
    progressColor: function progressColor() {
      return this.textColor === 'black' ? 'primary' : 'white';
    },
    hasBrandDivider: function hasBrandDivider() {
      return this.removeBrandDivider ? false : this.brand || this.$slots.brand;
    }
  },
  methods: {
    navIconClick: function navIconClick() {
      this.$emit('nav-icon-click');
    }
  },
  components: {
    UiButton: __vue_component__$1v,
    UiProgressLinear: __vue_component__$T
  }
};

/* script */
var __vue_script__$z = script$z;
/* template */

var __vue_render__$w = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-toolbar",
    class: _vm.classes
  }, [_c('div', {
    staticClass: "ui-toolbar__left"
  }, [!_vm.removeNavIcon ? _c('div', {
    staticClass: "ui-toolbar__nav-icon"
  }, [_vm._t("icon", [_c('ui-button', {
    attrs: {
      "size": "large",
      "type": "secondary",
      "circle": "",
      "color": _vm.textColor,
      "icon": _vm.navIcon
    },
    on: {
      "click": _vm.navIconClick
    }
  })])], 2) : _vm._e(), _vm._v(" "), _vm.brand || _vm.$slots.brand ? _c('div', {
    staticClass: "ui-toolbar__brand"
  }, [_vm._t("brand", [_c('div', {
    staticClass: "ui-toolbar__brand-text"
  }, [_vm._v(_vm._s(_vm.brand))])])], 2) : _vm._e()]), _vm._v(" "), _c('div', {
    staticClass: "ui-toolbar__body",
    class: {
      'has-brand-divider': _vm.hasBrandDivider
    }
  }, [_vm._t("default", [_vm.title ? _c('div', {
    staticClass: "ui-toolbar__title"
  }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()])], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-toolbar__right"
  }, [_vm._t("actions")], 2), _vm._v(" "), _c('ui-progress-linear', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.loading,
      expression: "loading"
    }],
    staticClass: "ui-toolbar__progress",
    attrs: {
      "color": _vm.progressColor
    }
  })], 1);
};

var __vue_staticRenderFns__$w = [];
/* style */

var __vue_inject_styles__$z = undefined;
/* scoped */

var __vue_scope_id__$z = undefined;
/* module identifier */

var __vue_module_identifier__$z = undefined;
/* functional template */

var __vue_is_functional_template__$z = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$z = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$w,
  staticRenderFns: __vue_staticRenderFns__$w
}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

var isEnum = _objectPie.f;
var _objectToArray = function (isEntries) {
  return function (it) {
    var O = _toIobject(it);
    var keys = _objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!_descriptors || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

// https://github.com/tc39/proposal-object-values-entries

var $values = _objectToArray(false);

_export(_export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $find = _arrayMethods(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
_export(_export.P + _export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
_addToUnscopables(KEY);

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$y = {
  components: {
    UiCheckbox: __vue_component__$1p,
    UiTextbox: __vue_component__$1r
  },
  props: {
    title: String,
    list: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    labelKey: {
      type: String,
      default: 'label'
    },
    disabledKey: {
      type: String,
      default: 'disabled'
    },
    filterable: false,
    draggable: false
  },
  data: function data() {
    return {
      sourceIndex: -1,
      targetIndex: -1,
      filter: '',
      checkedMap: {}
    };
  },
  computed: {
    isAllCheck: function isAllCheck() {
      return this.checkList.length > 0 && this.checkList.length === this.filterList.length;
    },
    isIndeterCheck: function isIndeterCheck() {
      return this.checkList.length > 0 && this.checkList.length < this.filterList.length;
    },
    checkList: function checkList() {
      var _this = this;

      return this.filterList.filter(function (item) {
        return !!_this.checkedMap[item[_this.valueKey]];
      });
    },
    filterList: function filterList() {
      var _this2 = this;

      return this.list.filter(function (item) {
        return (item[_this2.labelKey] || '').indexOf(_this2.filter) !== -1;
      });
    },
    checkAllLength: function checkAllLength() {
      return Object.keys(this.checkedMap).length;
    }
  },
  methods: {
    onItemChange: function onItemChange(item) {
      if (item[this.disabledKey]) return;
      var value = item[this.valueKey];

      if (this.checkedMap[value]) {
        this.$delete(this.checkedMap, value);
      } else {
        this.$set(this.checkedMap, value, item);
      }

      this.$emit('change');
    },
    onCheckAll: function onCheckAll() {
      var _this3 = this;

      if (this.filterList.length <= 0) return;

      var checkedMap = _objectSpread$8({}, this.checkedMap);

      var checked = this.isAllCheck ? false : true;
      this.filterList.forEach(function (item) {
        var disabled = item[_this3.disabledKey];
        if (disabled) return;
        var value = item[_this3.valueKey];
        if (checked) checkedMap[value] = item;else delete checkedMap[value];
      });
      this.checkedMap = checkedMap;
      this.$emit('change');
    },
    handleDragStart: function handleDragStart(event, item, index) {
      this.sourceIndex = index;
      this.targetIndex = index;
    },
    handleDragOver: function handleDragOver(event, item, index) {
      this.targetIndex = index;
      event.preventDefault();
    },
    handleDragEnd: function handleDragEnd(event, item, index) {
      this.$emit('drag', index, this.targetIndex);
      this.sourceIndex = -1;
      this.targetIndex = -1;
    }
  }
};

/* script */
var __vue_script__$y = script$y;
/* template */

var __vue_render__$v = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-transfer__list"
  }, [_c('div', {
    staticClass: "ui-transfer__hd"
  }, [_c('ui-checkbox', {
    attrs: {
      "value": _vm.isAllCheck,
      "indeterminate": _vm.isIndeterCheck
    },
    on: {
      "change": _vm.onCheckAll
    }
  }), _vm._v(" "), _c('span', {
    staticClass: "ui-transfer__tt"
  }, [_vm._v(_vm._s(_vm.title))]), _vm._v(" "), _c('span', [_vm._v(_vm._s(_vm.checkAllLength) + "/" + _vm._s(_vm.list.length) + "é¡¹")])], 1), _vm._v(" "), _vm.filterable ? _c('div', {
    staticClass: "ui-transfer__filter"
  }, [_c('ui-textbox', {
    attrs: {
      "size": "small",
      "icon": "search"
    },
    model: {
      value: _vm.filter,
      callback: function callback($$v) {
        _vm.filter = $$v;
      },
      expression: "filter"
    }
  })], 1) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-transfer__bd",
    class: {
      'can-drag': _vm.draggable && !_vm.filter
    }
  }, [this.list.length ? _c('ul', _vm._l(_vm.filterList, function (item, i) {
    return _c('li', {
      key: i,
      class: {
        'is-drag-before': _vm.sourceIndex > _vm.targetIndex && _vm.targetIndex == i,
        'is-drag-after': _vm.sourceIndex < _vm.targetIndex && _vm.targetIndex == i
      }
    }, [_c('div', {
      staticClass: "ui-transfer__item",
      class: {
        'is-disabled': item[_vm.disabledKey]
      },
      attrs: {
        "draggable": _vm.draggable && !_vm.filter
      },
      on: {
        "dragstart": function dragstart($event) {
          $event.stopPropagation();
          return _vm.handleDragStart($event, item, i);
        },
        "dragover": function dragover($event) {
          $event.stopPropagation();
          return _vm.handleDragOver($event, item, i);
        },
        "dragend": function dragend($event) {
          $event.stopPropagation();
          return _vm.handleDragEnd($event, item, i);
        },
        "click": function click($event) {
          $event.preventDefault();
          return _vm.onItemChange(item, i);
        }
      }
    }, [_vm._t("item", [_c('ui-checkbox', {
      attrs: {
        "size": "small",
        "value": Boolean(_vm.checkedMap[item[_vm.valueKey]]),
        "disabled": item[_vm.disabledKey]
      }
    }), _vm._v(" "), _c('span', [_vm._v(_vm._s(item[_vm.labelKey]))])], {
      "data": item,
      "checked": Boolean(_vm.checkedMap[item[_vm.valueKey]]),
      "index": i
    })], 2)]);
  }), 0) : _c('div', {
    staticClass: "ui-transfer__empty"
  }, [_vm._v("ææ æ°æ®")])]), _vm._v(" "), _c('div', {
    staticClass: "ui-transfer__ft"
  })]);
};

var __vue_staticRenderFns__$v = [];
/* style */

var __vue_inject_styles__$y = undefined;
/* scoped */

var __vue_scope_id__$y = undefined;
/* module identifier */

var __vue_module_identifier__$y = undefined;
/* functional template */

var __vue_is_functional_template__$y = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$y = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$v,
  staticRenderFns: __vue_staticRenderFns__$v
}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$x = {
  name: 'ui-transfer',
  components: {
    UiButton: __vue_component__$1v,
    UiIcon: __vue_component__$1B,
    UiTransferList: __vue_component__$y
  },
  props: {
    sourceTitle: String,
    targetTitle: String,
    width: {
      type: [Number, String],
      default: 200
    },
    height: {
      type: [Number, String],
      default: 400
    },
    filterable: Boolean,
    draggable: Boolean,
    autoPlus: Boolean,
    data: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * @name valueç±»å
     * @prop {String} valueType
     * @option 0 - [value,value,value]ç±»å
     * @option 1 - [{label,value}]ç±»å
     */
    valueType: {
      type: String,
      default: '1'
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    labelKey: {
      type: String,
      default: 'label'
    },
    disabledKey: {
      type: String,
      default: 'disabled'
    }
  },
  computed: {
    leftOptions: function leftOptions() {
      var _this = this;

      var rightOptions = this.rightOptions;
      return this.data.filter(function (a) {
        return !rightOptions.some(function (b) {
          return a[_this.valueKey] === b[_this.valueKey];
        });
      });
    },
    rightOptions: function rightOptions() {
      var _this2 = this;

      return this.valueType == '1' ? this.value : this.value.reduce(function (arr, a) {
        a = _this2.data.find(function (b) {
          return a === b[_this2.valueKey];
        });
        if (a || 0 === a) arr.push(a);
        return arr;
      }, []);
    },
    style: function style() {
      var width = typeof this.width === 'string' ? this.width : this.width + 'px';
      var height = typeof this.height === 'string' ? this.height : this.height + 'px';
      return {
        width: width,
        height: height //minHeight: height,

      };
    }
  },
  methods: {
    onLeftChange: function onLeftChange() {
      if (this.autoPlus) {
        this.onMoveToRight();
      }
    },
    onRightChange: function onRightChange() {
      if (this.autoPlus) {
        this.onMoveToLeft();
      }
    },
    onMoveToLeft: function onMoveToLeft() {
      var _this3 = this;

      if (!this.$refs.right || !this.$refs.right.checkedMap) return;
      var map = this.$refs.right.checkedMap;
      var value = this.value.filter(function (item) {
        return !map[_this3.valueType == '1' ? item[_this3.valueKey] : item];
      });
      this.$emit('input', value);
      this.$emit('change', value, 'left');
      this.$emit('move-to-left', Object.values(map));
      this.$refs.right.checkedMap = {};
    },
    onMoveToRight: function onMoveToRight() {
      if (!this.$refs.left || !this.$refs.left.checkedMap) return;

      var map = _objectSpread$7({}, this.$refs.left.checkedMap);

      var value = [].concat(this.value, this.valueType == '1' ? Object.values(map) : Object.keys(map));
      this.$emit('input', value);
      this.$emit('change', value, 'right');
      this.$emit('move-to-right', Object.values(map));
      this.$refs.left.checkedMap = {};
    },
    onRightDrag: function onRightDrag(sourceIndex, targetIndex) {
      var value = toConsumableArray(this.value);

      var tmp = value.splice(sourceIndex, 1);
      value.splice.apply(value, [targetIndex, 0].concat(toConsumableArray(tmp)));
      this.$emit('input', value);
      this.$emit('change', value, 'right');
      this.$emit('drag', value);
    }
  }
};

/* script */
var __vue_script__$x = script$x;
/* template */

var __vue_render__$u = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-transfer"
  }, [_c('div', {
    staticClass: "ui-transfer__left"
  }, [_c('ui-transfer-list', {
    ref: "left",
    style: _vm.style,
    attrs: {
      "title": _vm.sourceTitle,
      "filterable": _vm.filterable,
      "valueKey": _vm.valueKey,
      "labelKey": _vm.labelKey,
      "disabledKey": _vm.disabledKey,
      "list": _vm.leftOptions
    },
    on: {
      "change": _vm.onLeftChange
    },
    scopedSlots: _vm._u([{
      key: "item",
      fn: function fn(scope) {
        return _vm._t(_vm.$scopedSlots['left-item'] ? 'left-item' : 'item', null, null, scope);
      }
    }], null, true)
  })], 1), _vm._v(" "), _c('div', {
    staticClass: "ui-transfer__ct"
  }, [_vm.autoPlus ? _c('ui-button', {
    staticClass: "ui-transfer__btn"
  }, [_c('ui-icon', {
    attrs: {
      "icon": "code"
    }
  })], 1) : [_c('ui-button', {
    staticClass: "ui-transfer__btn",
    on: {
      "click": _vm.onMoveToRight
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "keyboard_arrow_right"
    }
  })], 1), _vm._v(" "), _c('ui-button', {
    staticClass: "ui-transfer__btn",
    on: {
      "click": _vm.onMoveToLeft
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "keyboard_arrow_left"
    }
  })], 1)]], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-transfer__right"
  }, [_c('ui-transfer-list', {
    ref: "right",
    style: _vm.style,
    attrs: {
      "title": _vm.targetTitle,
      "filterable": _vm.filterable,
      "valueKey": _vm.valueKey,
      "labelKey": _vm.labelKey,
      "disabledKey": _vm.disabledKey,
      "list": _vm.rightOptions,
      "draggable": _vm.draggable
    },
    on: {
      "change": _vm.onRightChange,
      "drag": _vm.onRightDrag
    },
    scopedSlots: _vm._u([{
      key: "item",
      fn: function fn(scope) {
        return _vm._t(_vm.$scopedSlots['right-item'] ? 'right-item' : 'item', null, null, scope);
      }
    }], null, true)
  })], 1)]);
};

var __vue_staticRenderFns__$u = [];
/* style */

var __vue_inject_styles__$x = undefined;
/* scoped */

var __vue_scope_id__$x = undefined;
/* module identifier */

var __vue_module_identifier__$x = undefined;
/* functional template */

var __vue_is_functional_template__$x = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$x = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$u,
  staticRenderFns: __vue_staticRenderFns__$u
}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

var NODE_KEY = '$treeNodeId';
var markNodeData = function markNodeData(node, data) {
  if (!data || data[NODE_KEY]) return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
var getNodeKey = function getNodeKey(key, data) {
  if (!key) return data[NODE_KEY];
  return data[key];
};
var findNearestComponent = function findNearestComponent(element, componentName) {
  var target = element;

  while (target && target.tagName !== 'BODY') {
    if (target.__vue__ && target.__vue__.$options.componentName === componentName) {
      return target.__vue__;
    }

    target = target.parentNode;
  }

  return null;
};

function _broadcast(componentName, eventName, params) {
  this.$children.forEach(function (child) {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      _broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}

var emitter = {
  methods: {
    dispatch: function dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }

      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast: function broadcast(componentName, eventName, params) {
      _broadcast.call(this, componentName, eventName, params);
    }
  }
};

//
var script$w = {
  name: 'ui-tree-node',
  componentName: 'UiTreeNode',
  mixins: [emitter],
  props: {
    node: {
      default: function _default() {
        return {};
      }
    },
    props: {},
    renderContent: Function,
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  components: {
    UiCheckbox: __vue_component__$1p,
    NodeContent: {
      props: {
        node: {
          required: true
        }
      },
      render: function render(h) {
        var parent = this.$parent;
        var tree = parent.tree;
        var node = this.node;
        var data = node.data,
            store = node.store;
        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, {
          _self: tree.$vnode.context,
          node: node,
          data: data,
          store: store
        }) : tree.$scopedSlots.default ? tree.$scopedSlots.default({
          node: node,
          data: data
        }) : h("span", {
          "class": "ui-tree-node__label"
        }, [node.label]);
      }
    }
  },
  data: function data() {
    return {
      tree: null,
      expanded: false,
      childNodeRendered: false,
      oldChecked: null,
      oldIndeterminate: null
    };
  },
  watch: {
    'node.indeterminate': function nodeIndeterminate(val) {
      this.handleSelectChange(this.node.checked, val);
    },
    'node.checked': function nodeChecked(val) {
      this.handleSelectChange(val, this.node.indeterminate);
    },
    'node.expanded': function nodeExpanded(val) {
      var _this = this;

      this.$nextTick(function () {
        return _this.expanded = val;
      });

      if (val) {
        this.childNodeRendered = true;
      }
    }
  },
  methods: {
    getNodeKey: function getNodeKey$1(node) {
      return getNodeKey(this.tree.nodeKey, node.data);
    },
    handleSelectChange: function handleSelectChange(checked, indeterminate) {
      if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {
        this.tree.$emit('check-change', this.node.data, checked, indeterminate);
      }

      this.oldChecked = checked;
      this.indeterminate = indeterminate;
    },
    handleClick: function handleClick() {
      var store = this.tree.store;
      store.setCurrentNode(this.node);
      this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);
      this.tree.currentNode = this;

      if (this.tree.expandOnClickNode) {
        this.handleExpandIconClick();
      }

      if (this.tree.checkOnClickNode && !this.node.disabled) {
        this.handleCheckChange(!this.node.checked);
      }

      this.tree.$emit('node-click', this.node.data, this.node, this);
    },
    handleContextMenu: function handleContextMenu(event) {
      if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {
        event.stopPropagation();
        event.preventDefault();
      }

      this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);
    },
    handleExpandIconClick: function handleExpandIconClick() {
      if (this.node.isLeaf) return;

      if (this.expanded) {
        this.tree.$emit('node-collapse', this.node.data, this.node, this);
        this.node.collapse();
      } else {
        this.node.expand();
        this.$emit('node-expand', this.node.data, this.node, this);
      }
    },
    handleCheckChange: function handleCheckChange(value) {
      var _this2 = this;

      this.node.setChecked(value, !this.tree.checkStrictly);
      this.$nextTick(function () {
        var store = _this2.tree.store;

        _this2.tree.$emit('check', _this2.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    },
    handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {
      this.broadcast('UiTreeNode', 'tree-node-expand', node);
      this.tree.$emit('node-expand', nodeData, node, instance);
    },
    handleDragStart: function handleDragStart(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-start', event, this);
    },
    handleDragOver: function handleDragOver(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-over', event, this);
      event.preventDefault();
    },
    handleDrop: function handleDrop(event) {
      event.preventDefault();
    },
    handleDragEnd: function handleDragEnd(event) {
      if (!this.tree.draggable) return;
      this.tree.$emit('tree-node-drag-end', event, this);
    }
  },
  created: function created() {
    var _this3 = this;

    var parent = this.$parent;

    if (parent.isTree) {
      this.tree = parent;
    } else {
      this.tree = parent.tree;
    }

    var tree = this.tree;

    if (!tree) {
      console.warn('Can not find node\'s tree.');
    }

    var props = tree.props || {};
    var childrenKey = props['children'] || 'children';
    this.$watch("node.data.".concat(childrenKey), function () {
      _this3.node.updateChildren();
    });

    if (this.node.expanded) {
      this.expanded = true;
      this.childNodeRendered = true;
    }

    if (this.tree.accordion) {
      this.$on('tree-node-expand', function (node) {
        if (_this3.node !== node) {
          _this3.node.collapse();
        }
      });
    }
  }
};

/* script */
var __vue_script__$w = script$w;
/* template */

var __vue_render__$t = function __vue_render__() {
  var this$1$1 = this;

  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.node.visible,
      expression: "node.visible"
    }],
    ref: "node",
    staticClass: "ui-tree-node",
    class: {
      'is-expanded': _vm.expanded,
      'is-current': _vm.node.isCurrent,
      'is-hidden': !_vm.node.visible,
      'is-focusable': !_vm.node.disabled,
      'is-checked': !_vm.node.disabled && _vm.node.checked
    },
    attrs: {
      "role": "treeitem",
      "tabindex": "-1",
      "aria-expanded": _vm.expanded,
      "aria-disabled": _vm.node.disabled,
      "aria-checked": _vm.node.checked,
      "draggable": _vm.tree.draggable
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.handleClick($event);
      },
      "contextmenu": function contextmenu($event) {
        return this$1$1.handleContextMenu($event);
      },
      "dragstart": function dragstart($event) {
        $event.stopPropagation();
        return _vm.handleDragStart($event);
      },
      "dragover": function dragover($event) {
        $event.stopPropagation();
        return _vm.handleDragOver($event);
      },
      "dragend": function dragend($event) {
        $event.stopPropagation();
        return _vm.handleDragEnd($event);
      },
      "drop": function drop($event) {
        $event.stopPropagation();
        return _vm.handleDrop($event);
      }
    }
  }, [_c('div', {
    staticClass: "ui-tree-node__content",
    style: {
      'padding-left': (_vm.node.level - 1) * _vm.tree.indent + 'px'
    }
  }, [_c('ui-icon', {
    class: [{
      'is-leaf': _vm.node.isLeaf,
      expanded: !_vm.node.isLeaf && _vm.expanded
    }, 'ui-tree-node__expand-icon'],
    attrs: {
      "icon": _vm.tree.iconClass || 'arrow_right'
    },
    nativeOn: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.handleExpandIconClick($event);
      }
    }
  }), _vm._v(" "), _vm.showCheckbox ? _c('ui-checkbox', {
    attrs: {
      "value": _vm.node.checked,
      "indeterminate": _vm.node.indeterminate,
      "disabled": !!_vm.node.disabled
    },
    on: {
      "change": _vm.handleCheckChange
    },
    nativeOn: {
      "click": function click($event) {
        $event.stopPropagation();
      }
    }
  }) : _vm._e(), _vm._v(" "), _vm.node.loading ? _c('ui-icon', {
    staticClass: "ui-tree-node__loading-icon ui-icon-loading",
    attrs: {
      "icon": "autorenew"
    }
  }) : _vm._e(), _vm._v(" "), _c('node-content', {
    attrs: {
      "node": _vm.node
    }
  })], 1), _vm._v(" "), !_vm.renderAfterExpand || _vm.childNodeRendered ? _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.expanded,
      expression: "expanded"
    }],
    staticClass: "ui-tree-node__children",
    attrs: {
      "role": "group",
      "aria-expanded": _vm.expanded
    }
  }, _vm._l(_vm.node.childNodes, function (child) {
    return _c('ui-tree-node', {
      key: _vm.getNodeKey(child),
      attrs: {
        "render-content": _vm.renderContent,
        "render-after-expand": _vm.renderAfterExpand,
        "show-checkbox": _vm.showCheckbox,
        "node": child
      },
      on: {
        "node-expand": _vm.handleChildNodeExpand
      }
    });
  }), 1) : _vm._e()]);
};

var __vue_staticRenderFns__$t = [];
/* style */

var __vue_inject_styles__$w = undefined;
/* scoped */

var __vue_scope_id__$w = undefined;
/* module identifier */

var __vue_module_identifier__$w = undefined;
/* functional template */

var __vue_is_functional_template__$w = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$w = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$t,
  staticRenderFns: __vue_staticRenderFns__$t
}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

var arrayFindIndex = function arrayFindIndex(arr, pred) {
  for (var i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }

  return -1;
};

var objectAssign = function objectAssign(target) {
  for (var i = 1, j = arguments.length; i < j; i++) {
    var source = arguments[i] || {};

    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        var value = source[prop];

        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
};

var getChildState = function getChildState(node) {
  var all = true;
  var none = true;
  var allWithoutDisable = true;

  for (var i = 0, j = node.length; i < j; i++) {
    var n = node[i];

    if (n.checked !== true || n.indeterminate) {
      all = false;

      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }

    if (n.checked !== false || n.indeterminate) {
      none = false;
    }
  }

  return {
    all: all,
    none: none,
    allWithoutDisable: allWithoutDisable,
    half: !all && !none
  };
};

var reInitChecked = function reInitChecked(node) {
  if (node.childNodes.length === 0) return;

  var _getChildState = getChildState(node.childNodes),
      all = _getChildState.all,
      none = _getChildState.none,
      half = _getChildState.half;

  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }

  var parent = node.parent;
  if (!parent || parent.level === 0) return;

  if (!node.store.checkStrictly) {
    reInitChecked(parent);
  }
};

var getPropertyFromData = function getPropertyFromData(node, prop) {
  var props = node.store.props;
  var data = node.data || {};
  var config = props[prop];

  if (typeof config === 'function') {
    return config(data, node);
  } else if (typeof config === 'string') {
    return data[config];
  } else if (typeof config === 'undefined') {
    var dataProp = data[prop];
    return dataProp === undefined ? '' : dataProp;
  }
};

var nodeIdSeed = 0;

var Node$1 = /*#__PURE__*/function () {
  function Node(options) {
    classCallCheck(this, Node);

    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.isCurrent = false;

    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        this[name] = options[name];
      }
    } // internal


    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;

    if (this.parent) {
      this.level = this.parent.level + 1;
    }

    var store = this.store;

    if (!store) {
      throw new Error('[Node]store is required!');
    }

    store.registerNode(this);
    var props = store.props;

    if (props && typeof props.isLeaf !== 'undefined') {
      var isLeaf = getPropertyFromData(this, 'isLeaf');

      if (typeof isLeaf === 'boolean') {
        this.isLeafByUser = isLeaf;
      }
    }

    if (store.lazy !== true && this.data) {
      this.setData(this.data);

      if (store.defaultExpandAll) {
        this.expanded = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }

    if (!Array.isArray(this.data)) {
      markNodeData(this, this.data);
    }

    if (!this.data) return;
    var defaultExpandedKeys = store.defaultExpandedKeys;
    var key = store.key;

    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
      this.expand(null, store.autoExpandParent);
    }

    if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {
      store.currentNode = this;
      store.currentNode.isCurrent = true;
    }

    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }

    this.updateLeafState();
  }

  createClass(Node, [{
    key: "setData",
    value: function setData(data) {
      if (!Array.isArray(data)) {
        markNodeData(this, data);
      }

      this.data = data;
      this.childNodes = [];
      var children;

      if (this.level === 0 && this.data instanceof Array) {
        children = this.data;
      } else {
        children = getPropertyFromData(this, 'children') || [];
      }

      for (var i = 0, j = children.length; i < j; i++) {
        this.insertChild({
          data: children[i]
        });
      }
    }
  }, {
    key: "label",
    get: function get() {
      return getPropertyFromData(this, 'label');
    }
  }, {
    key: "key",
    get: function get() {
      var nodeKey = this.store.key;
      if (this.data) return this.data[nodeKey];
      return null;
    }
  }, {
    key: "disabled",
    get: function get() {
      return getPropertyFromData(this, 'disabled');
    }
  }, {
    key: "nextSibling",
    get: function get() {
      var parent = this.parent;

      if (parent) {
        var index = parent.childNodes.indexOf(this);

        if (index > -1) {
          return parent.childNodes[index + 1];
        }
      }

      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      var parent = this.parent;

      if (parent) {
        var index = parent.childNodes.indexOf(this);

        if (index > -1) {
          return index > 0 ? parent.childNodes[index - 1] : null;
        }
      }

      return null;
    }
  }, {
    key: "contains",
    value: function contains(target) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var walk = function walk(parent) {
        var children = parent.childNodes || [];
        var result = false;

        for (var i = 0, j = children.length; i < j; i++) {
          var child = children[i];

          if (child === target || deep && walk(child)) {
            result = true;
            break;
          }
        }

        return result;
      };

      return walk(this);
    }
  }, {
    key: "remove",
    value: function remove() {
      var parent = this.parent;

      if (parent) {
        parent.removeChild(this);
      }
    }
  }, {
    key: "insertChild",
    value: function insertChild(child, index, batch) {
      if (!child) throw new Error('insertChild error: child is required.');

      if (!(child instanceof Node)) {
        if (!batch) {
          var children = this.getChildren(true);

          if (children.indexOf(child.data) === -1) {
            if (typeof index === 'undefined' || index < 0) {
              children.push(child.data);
            } else {
              children.splice(index, 0, child.data);
            }
          }
        }

        objectAssign(child, {
          parent: this,
          store: this.store
        });
        child = new Node(child);
      }

      child.level = this.level + 1;

      if (typeof index === 'undefined' || index < 0) {
        this.childNodes.push(child);
      } else {
        this.childNodes.splice(index, 0, child);
      }

      this.updateLeafState();
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(child, ref) {
      var index;

      if (ref) {
        index = this.childNodes.indexOf(ref);
      }

      this.insertChild(child, index);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(child, ref) {
      var index;

      if (ref) {
        index = this.childNodes.indexOf(ref);
        if (index !== -1) index += 1;
      }

      this.insertChild(child, index);
    }
  }, {
    key: "removeChild",
    value: function removeChild(child) {
      var children = this.getChildren() || [];
      var dataIndex = children.indexOf(child.data);

      if (dataIndex > -1) {
        children.splice(dataIndex, 1);
      }

      var index = this.childNodes.indexOf(child);

      if (index > -1) {
        this.store && this.store.deregisterNode(child);
        child.parent = null;
        this.childNodes.splice(index, 1);
      }

      this.updateLeafState();
    }
  }, {
    key: "removeChildByData",
    value: function removeChildByData(data) {
      var targetNode = null;

      for (var i = 0; i < this.childNodes.length; i++) {
        if (this.childNodes[i].data === data) {
          targetNode = this.childNodes[i];
          break;
        }
      }

      if (targetNode) {
        this.removeChild(targetNode);
      }
    }
  }, {
    key: "expand",
    value: function expand(callback, expandParent) {
      var _this = this;

      var done = function done() {
        if (expandParent) {
          var parent = _this.parent;

          while (parent.level > 0) {
            parent.expanded = true;
            parent = parent.parent;
          }
        }

        _this.expanded = true;
        if (callback) callback();
      };

      if (this.shouldLoadData()) {
        this.loadData(function (data) {
          if (data instanceof Array) {
            if (_this.checked) {
              _this.setChecked(true, true);
            } else if (!_this.store.checkStrictly) {
              reInitChecked(_this);
            }

            done();
          }
        });
      } else {
        done();
      }
    }
  }, {
    key: "doCreateChildren",
    value: function doCreateChildren(array) {
      var _this2 = this;

      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      array.forEach(function (item) {
        _this2.insertChild(objectAssign({
          data: item
        }, defaultProps), undefined, true);
      });
    }
  }, {
    key: "collapse",
    value: function collapse() {
      this.expanded = false;
    }
  }, {
    key: "shouldLoadData",
    value: function shouldLoadData() {
      return this.store.lazy === true && this.store.load && !this.loaded;
    }
  }, {
    key: "updateLeafState",
    value: function updateLeafState() {
      if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {
        this.isLeaf = this.isLeafByUser;
        return;
      }

      var childNodes = this.childNodes;

      if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
        this.isLeaf = !childNodes || childNodes.length === 0;
        return;
      }

      this.isLeaf = false;
    }
  }, {
    key: "setChecked",
    value: function setChecked(value, deep, recursion, passValue) {
      var _this3 = this;

      this.indeterminate = value === 'half';
      this.checked = value === true;
      if (this.store.checkStrictly) return;

      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        var _getChildState2 = getChildState(this.childNodes),
            all = _getChildState2.all,
            allWithoutDisable = _getChildState2.allWithoutDisable;

        if (!this.isLeaf && !all && allWithoutDisable) {
          this.checked = false;
          value = false;
        }

        var handleDescendants = function handleDescendants() {
          if (deep) {
            var childNodes = _this3.childNodes;

            for (var i = 0, j = childNodes.length; i < j; i++) {
              var child = childNodes[i];
              passValue = passValue || value !== false;
              var isCheck = child.disabled ? child.checked : passValue;
              child.setChecked(isCheck, deep, true, passValue);
            }

            var _getChildState3 = getChildState(childNodes),
                half = _getChildState3.half,
                _all = _getChildState3.all;

            if (!_all) {
              _this3.checked = _all;
              _this3.indeterminate = half;
            }
          }
        };

        if (this.shouldLoadData()) {
          // Only work on lazy load data.
          this.loadData(function () {
            handleDescendants();
            reInitChecked(_this3);
          }, {
            checked: value !== false
          });
          return;
        } else {
          handleDescendants();
        }
      }

      var parent = this.parent;
      if (!parent || parent.level === 0) return;

      if (!recursion) {
        reInitChecked(parent);
      }
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      var forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      // this is data
      if (this.level === 0) return this.data;
      var data = this.data;
      if (!data) return null;
      var props = this.store.props;
      var children = 'children';

      if (props) {
        children = props.children || 'children';
      }

      if (data[children] === undefined) {
        data[children] = null;
      }

      if (forceInit && !data[children]) {
        data[children] = [];
      }

      return data[children];
    }
  }, {
    key: "updateChildren",
    value: function updateChildren() {
      var _this4 = this;

      var newData = this.getChildren() || [];
      var oldData = this.childNodes.map(function (node) {
        return node.data;
      });
      var newDataMap = {};
      var newNodes = [];
      newData.forEach(function (item, index) {
        var key = item[NODE_KEY];
        var isNodeExists = !!key && arrayFindIndex(oldData, function (data) {
          return data[NODE_KEY] === key;
        }) >= 0;

        if (isNodeExists) {
          newDataMap[key] = {
            index: index,
            data: item
          };
        } else {
          newNodes.push({
            index: index,
            data: item
          });
        }
      });

      if (!this.store.lazy) {
        oldData.forEach(function (item) {
          if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);
        });
      }

      newNodes.forEach(function (_ref) {
        var index = _ref.index,
            data = _ref.data;

        _this4.insertChild({
          data: data
        }, index);
      });
      this.updateLeafState();
    }
  }, {
    key: "loadData",
    value: function loadData(callback) {
      var _this5 = this;

      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
        this.loading = true;

        var resolve = function resolve(children) {
          _this5.loaded = true;
          _this5.loading = false;
          _this5.childNodes = [];

          _this5.doCreateChildren(children, defaultProps);

          _this5.updateLeafState();

          if (callback) {
            callback.call(_this5, children);
          }
        };

        this.store.load(this, resolve);
      } else {
        if (callback) {
          callback.call(this);
        }
      }
    }
  }]);

  return Node;
}();

var TreeStore = /*#__PURE__*/function () {
  function TreeStore(options) {
    var _this = this;

    classCallCheck(this, TreeStore);

    this.currentNode = null;
    this.currentNodeKey = null;

    for (var option in options) {
      if (options.hasOwnProperty(option)) {
        this[option] = options[option];
      }
    }

    this.nodesMap = {};
    this.root = new Node$1({
      data: this.data,
      store: this
    });

    if (this.lazy && this.load) {
      var loadFn = this.load;
      loadFn(this.root, function (data) {
        _this.root.doCreateChildren(data);

        _this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }

  createClass(TreeStore, [{
    key: "filter",
    value: function filter(value) {
      var filterNodeMethod = this.filterNodeMethod;
      var lazy = this.lazy;

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          child.visible = filterNodeMethod.call(child, value, child.data, child);
          traverse(child);
        });

        if (!node.visible && childNodes.length) {
          var allHidden = true;
          allHidden = !childNodes.some(function (child) {
            return child.visible;
          });

          if (node.root) {
            node.root.visible = allHidden === false;
          } else {
            node.visible = allHidden === false;
          }
        }

        if (!value) return;
        if (node.visible && !node.isLeaf && !lazy) node.expand();
      };

      traverse(this);
    }
  }, {
    key: "setData",
    value: function setData(newVal) {
      var instanceChanged = newVal !== this.root.data;

      if (instanceChanged) {
        this.root.setData(newVal);

        this._initDefaultCheckedNodes();
      } else {
        this.root.updateChildren();
      }
    }
  }, {
    key: "getNode",
    value: function getNode(data) {
      if (data instanceof Node$1) return data;
      var key = _typeof_1(data) !== 'object' ? data : getNodeKey(this.key, data);
      return this.nodesMap[key] || null;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(data, refData) {
      var refNode = this.getNode(refData);
      refNode.parent.insertBefore({
        data: data
      }, refNode);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(data, refData) {
      var refNode = this.getNode(refData);
      refNode.parent.insertAfter({
        data: data
      }, refNode);
    }
  }, {
    key: "remove",
    value: function remove(data) {
      var node = this.getNode(data);

      if (node && node.parent) {
        if (node === this.currentNode) {
          this.currentNode = null;
        }

        node.parent.removeChild(node);
      }
    }
  }, {
    key: "append",
    value: function append(data, parentData) {
      var parentNode = parentData ? this.getNode(parentData) : this.root;

      if (parentNode) {
        parentNode.insertChild({
          data: data
        });
      }
    }
  }, {
    key: "_initDefaultCheckedNodes",
    value: function _initDefaultCheckedNodes() {
      var _this2 = this;

      var defaultCheckedKeys = this.defaultCheckedKeys || [];
      var nodesMap = this.nodesMap;
      defaultCheckedKeys.forEach(function (checkedKey) {
        var node = nodesMap[checkedKey];

        if (node) {
          node.setChecked(true, !_this2.checkStrictly);
        }
      });
    }
  }, {
    key: "_initDefaultCheckedNode",
    value: function _initDefaultCheckedNode(node) {
      var defaultCheckedKeys = this.defaultCheckedKeys || [];

      if (defaultCheckedKeys.indexOf(node.key) !== -1) {
        node.setChecked(true, !this.checkStrictly);
      }
    }
  }, {
    key: "setDefaultCheckedKey",
    value: function setDefaultCheckedKey(newVal) {
      if (newVal !== this.defaultCheckedKeys) {
        this.defaultCheckedKeys = newVal;

        this._initDefaultCheckedNodes();
      }
    }
  }, {
    key: "registerNode",
    value: function registerNode(node) {
      var key = this.key;
      if (!key || !node || !node.data) return;
      var nodeKey = node.key;
      if (nodeKey !== undefined) this.nodesMap[node.key] = node;
    }
  }, {
    key: "deregisterNode",
    value: function deregisterNode(node) {
      var _this3 = this;

      var key = this.key;
      if (!key || !node || !node.data) return;
      node.childNodes.forEach(function (child) {
        _this3.deregisterNode(child);
      });
      delete this.nodesMap[node.key];
    }
  }, {
    key: "getCheckedNodes",
    value: function getCheckedNodes() {
      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var checkedNodes = [];

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
            checkedNodes.push(child.data);
          }

          traverse(child);
        });
      };

      traverse(this);
      return checkedNodes;
    }
  }, {
    key: "getCheckedKeys",
    value: function getCheckedKeys() {
      var _this4 = this;

      var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.getCheckedNodes(leafOnly).map(function (data) {
        return (data || {})[_this4.key];
      });
    }
  }, {
    key: "getHalfCheckedNodes",
    value: function getHalfCheckedNodes() {
      var nodes = [];

      var traverse = function traverse(node) {
        var childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach(function (child) {
          if (child.indeterminate) {
            nodes.push(child.data);
          }

          traverse(child);
        });
      };

      traverse(this);
      return nodes;
    }
  }, {
    key: "getHalfCheckedKeys",
    value: function getHalfCheckedKeys() {
      var _this5 = this;

      return this.getHalfCheckedNodes().map(function (data) {
        return (data || {})[_this5.key];
      });
    }
  }, {
    key: "_getAllNodes",
    value: function _getAllNodes() {
      var allNodes = [];
      var nodesMap = this.nodesMap;

      for (var nodeKey in nodesMap) {
        if (nodesMap.hasOwnProperty(nodeKey)) {
          allNodes.push(nodesMap[nodeKey]);
        }
      }

      return allNodes;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren(key, data) {
      var node = this.nodesMap[key];
      if (!node) return;
      var childNodes = node.childNodes;

      for (var i = childNodes.length - 1; i >= 0; i--) {
        var child = childNodes[i];
        this.remove(child.data);
      }

      for (var _i = 0, j = data.length; _i < j; _i++) {
        var _child = data[_i];
        this.append(_child, node.data);
      }
    }
  }, {
    key: "_setCheckedKeys",
    value: function _setCheckedKeys(key) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var checkedKeys = arguments.length > 2 ? arguments[2] : undefined;

      var allNodes = this._getAllNodes().sort(function (a, b) {
        return b.level - a.level;
      });

      var cache = Object.create(null);
      var keys = Object.keys(checkedKeys);
      allNodes.forEach(function (node) {
        return node.setChecked(false, false);
      });

      for (var i = 0, j = allNodes.length; i < j; i++) {
        var node = allNodes[i];
        var nodeKey = node.data[key].toString();
        var checked = keys.indexOf(nodeKey) > -1;

        if (!checked) {
          if (node.checked && !cache[nodeKey]) {
            node.setChecked(false, false);
          }

          continue;
        }

        var parent = node.parent;

        while (parent && parent.level > 0) {
          cache[parent.data[key]] = true;
          parent = parent.parent;
        }

        if (node.isLeaf || this.checkStrictly) {
          node.setChecked(true, false);
          continue;
        }

        node.setChecked(true, true);

        if (leafOnly) {
          (function () {
            node.setChecked(false, false);

            var traverse = function traverse(node) {
              var childNodes = node.childNodes;
              childNodes.forEach(function (child) {
                if (!child.isLeaf) {
                  child.setChecked(false, false);
                }

                traverse(child);
              });
            };

            traverse(node);
          })();
        }
      }
    }
  }, {
    key: "setCheckedNodes",
    value: function setCheckedNodes(array) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var key = this.key;
      var checkedKeys = {};
      array.forEach(function (item) {
        checkedKeys[(item || {})[key]] = true;
      });

      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
  }, {
    key: "setCheckedKeys",
    value: function setCheckedKeys(keys) {
      var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.defaultCheckedKeys = keys;
      var key = this.key;
      var checkedKeys = {};
      keys.forEach(function (key) {
        checkedKeys[key] = true;
      });

      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
  }, {
    key: "setDefaultExpandedKeys",
    value: function setDefaultExpandedKeys(keys) {
      var _this6 = this;

      keys = keys || [];
      this.defaultExpandedKeys = keys;
      keys.forEach(function (key) {
        var node = _this6.getNode(key);

        if (node) node.expand(null, _this6.autoExpandParent);
      });
    }
  }, {
    key: "setChecked",
    value: function setChecked(data, checked, deep) {
      var node = this.getNode(data);

      if (node) {
        node.setChecked(!!checked, deep);
      }
    }
  }, {
    key: "getCurrentNode",
    value: function getCurrentNode() {
      return this.currentNode;
    }
  }, {
    key: "setCurrentNode",
    value: function setCurrentNode(currentNode) {
      var prevCurrentNode = this.currentNode;

      if (prevCurrentNode) {
        prevCurrentNode.isCurrent = false;
      }

      this.currentNode = currentNode;
      this.currentNode.isCurrent = true;
    }
  }, {
    key: "setUserCurrentNode",
    value: function setUserCurrentNode(node) {
      var key = node[this.key];
      var currNode = this.nodesMap[key];
      this.setCurrentNode(currNode);
    }
  }, {
    key: "setCurrentNodeKey",
    value: function setCurrentNodeKey(key) {
      if (key === null || key === undefined) {
        this.currentNode && (this.currentNode.isCurrent = false);
        this.currentNode = null;
        return;
      }

      var node = this.getNode(key);

      if (node) {
        this.setCurrentNode(node);
      }
    }
  }]);

  return TreeStore;
}();

var isServer$2 = Vue.prototype.$isServer;
var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var ieVersion = isServer$2 ? 0 : Number(document.documentMode);
/* istanbul ignore next */

var trim$1 = function trim(string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */


var camelCase = function camelCase(name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};
/* istanbul ignore next */

function hasClass$1(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}
/* istanbul ignore next */

function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass$1(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }

  if (!el.classList) {
    el.className = curClass;
  }
}
/* istanbul ignore next */

function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass$1(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }

  if (!el.classList) {
    el.className = trim$1(curClass);
  }
}
/* istanbul ignore next */

var getStyle = ieVersion < 9 ? function (element, styleName) {
  if (isServer$2) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'styleFloat';
  }

  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }

      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (isServer$2) return;
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'cssFloat';
  }

  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function isVNode(node) {
  return node !== null && _typeof_1(node) === 'object' && hasOwn(node, 'componentOptions');
}

var script$v = {
  name: 'ui-tree',
  mixins: [emitter],
  components: {
    UiTreeNode: __vue_component__$w
  },
  data: function data() {
    return {
      store: null,
      root: null,
      currentNode: null,
      treeItems: null,
      checkboxItems: [],
      dragState: {
        showDropIndicator: false,
        draggingNode: null,
        dropNode: null,
        allowDrop: true
      }
    };
  },
  props: {
    data: {
      type: Array
    },
    emptyText: {
      type: String,
      default: function _default() {
        return 'ææ æ°æ®';
      }
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      default: function _default() {
        return {
          children: 'children',
          label: 'label',
          disabled: 'disabled'
        };
      }
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    iconClass: String
  },
  computed: {
    children: {
      set: function set(value) {
        this.data = value;
      },
      get: function get() {
        return this.data;
      }
    },
    treeItemArray: function treeItemArray() {
      return Array.prototype.slice.call(this.treeItems);
    },
    isEmpty: function isEmpty() {
      var childNodes = this.root.childNodes;
      return !childNodes || childNodes.length === 0 || childNodes.every(function (_ref) {
        var visible = _ref.visible;
        return !visible;
      });
    }
  },
  watch: {
    defaultCheckedKeys: function defaultCheckedKeys(newVal) {
      this.store.setDefaultCheckedKey(newVal);
    },
    defaultExpandedKeys: function defaultExpandedKeys(newVal) {
      this.store.defaultExpandedKeys = newVal;
      this.store.setDefaultExpandedKeys(newVal);
    },
    data: function data(newVal) {
      this.store.setData(newVal);
    },
    checkboxItems: function checkboxItems(val) {
      Array.prototype.forEach.call(val, function (checkbox) {
        checkbox.setAttribute('tabindex', -1);
      });
    },
    checkStrictly: function checkStrictly(newVal) {
      this.store.checkStrictly = newVal;
    }
  },
  methods: {
    filter: function filter(value) {
      if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');
      this.store.filter(value);
    },
    getNodeKey: function getNodeKey$1(node) {
      return getNodeKey(this.nodeKey, node.data);
    },
    getNodePath: function getNodePath(data) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getNodePath');
      var node = this.store.getNode(data);
      if (!node) return [];
      var path = [node.data];
      var parent = node.parent;

      while (parent && parent !== this.root) {
        path.push(parent.data);
        parent = parent.parent;
      }

      return path.reverse();
    },
    getCheckedNodes: function getCheckedNodes(leafOnly, includeHalfChecked) {
      return this.store.getCheckedNodes(leafOnly, includeHalfChecked);
    },
    getCheckedKeys: function getCheckedKeys(leafOnly) {
      return this.store.getCheckedKeys(leafOnly);
    },
    getCurrentNode: function getCurrentNode() {
      var currentNode = this.store.getCurrentNode();
      return currentNode ? currentNode.data : null;
    },
    getCurrentKey: function getCurrentKey() {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');
      var currentNode = this.getCurrentNode();
      return currentNode ? currentNode[this.nodeKey] : null;
    },
    setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');
      this.store.setCheckedNodes(nodes, leafOnly);
    },
    setCheckedKeys: function setCheckedKeys(keys, leafOnly) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');
      this.store.setCheckedKeys(keys, leafOnly);
    },
    setChecked: function setChecked(data, checked, deep) {
      this.store.setChecked(data, checked, deep);
    },
    getHalfCheckedNodes: function getHalfCheckedNodes() {
      return this.store.getHalfCheckedNodes();
    },
    getHalfCheckedKeys: function getHalfCheckedKeys() {
      return this.store.getHalfCheckedKeys();
    },
    setCurrentNode: function setCurrentNode(node) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');
      this.store.setUserCurrentNode(node);
    },
    setCurrentKey: function setCurrentKey(key) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');
      this.store.setCurrentNodeKey(key);
    },
    getNode: function getNode(data) {
      return this.store.getNode(data);
    },
    remove: function remove(data) {
      this.store.remove(data);
    },
    append: function append(data, parentNode) {
      this.store.append(data, parentNode);
    },
    insertBefore: function insertBefore(data, refNode) {
      this.store.insertBefore(data, refNode);
    },
    insertAfter: function insertAfter(data, refNode) {
      this.store.insertAfter(data, refNode);
    },
    handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {
      this.broadcast('UiTreeNode', 'tree-node-expand', node);
      this.$emit('node-expand', nodeData, node, instance);
    },
    updateKeyChildren: function updateKeyChildren(key, data) {
      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');
      this.store.updateChildren(key, data);
    },
    initTabIndex: function initTabIndex() {
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
      var checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');

      if (checkedItem.length) {
        checkedItem[0].setAttribute('tabindex', 0);
        return;
      }

      this.treeItems[0] && this.treeItems[0].setAttribute('tabindex', 0);
    },
    handleKeydown: function handleKeydown(ev) {
      var currentItem = ev.target;
      if (currentItem.className.indexOf('ui-tree-node') === -1) return;
      var keyCode = ev.keyCode;
      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');
      var currentIndex = this.treeItemArray.indexOf(currentItem);
      var nextIndex;

      if ([38, 40].indexOf(keyCode) > -1) {
        // upãdown
        ev.preventDefault();

        if (keyCode === 38) {
          // up
          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
        } else {
          nextIndex = currentIndex < this.treeItemArray.length - 1 ? currentIndex + 1 : 0;
        }

        this.treeItemArray[nextIndex].focus(); // éä¸­
      }

      if ([37, 39].indexOf(keyCode) > -1) {
        // leftãright å±å¼
        ev.preventDefault();
        currentItem.click(); // éä¸­
      }

      var hasInput = currentItem.querySelector('[type="checkbox"]');

      if ([13, 32].indexOf(keyCode) > -1 && hasInput) {
        // space enteréä¸­checkbox
        ev.preventDefault();
        hasInput.click();
      }
    }
  },
  created: function created() {
    var _this = this;

    this.isTree = true;
    this.store = new TreeStore({
      key: this.nodeKey,
      data: this.data,
      lazy: this.lazy,
      props: this.props,
      load: this.load,
      currentNodeKey: this.currentNodeKey,
      checkStrictly: this.checkStrictly,
      checkDescendants: this.checkDescendants,
      defaultCheckedKeys: this.defaultCheckedKeys,
      defaultExpandedKeys: this.defaultExpandedKeys,
      autoExpandParent: this.autoExpandParent,
      defaultExpandAll: this.defaultExpandAll,
      filterNodeMethod: this.filterNodeMethod
    });
    this.root = this.store.root;
    var dragState = this.dragState;
    this.$on('tree-node-drag-start', function (event, treeNode) {
      if (typeof _this.allowDrag === 'function' && !_this.allowDrag(treeNode.node)) {
        event.preventDefault();
        return false;
      }

      event.dataTransfer.effectAllowed = 'move'; // wrap in try catch to address IE's error when first param is 'text/plain'

      try {
        // setData is required for draggable to work in FireFox
        // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox
        event.dataTransfer.setData('text/plain', '');
      } catch (e) {}

      dragState.draggingNode = treeNode;

      _this.$emit('node-drag-start', treeNode.node, event);
    });
    this.$on('tree-node-drag-over', function (event, treeNode) {
      var dropNode = findNearestComponent(event.target, 'UiTreeNode');
      var oldDropNode = dragState.dropNode;

      if (oldDropNode && oldDropNode !== dropNode) {
        removeClass(oldDropNode.$el, 'is-drop-inner');
      }

      var draggingNode = dragState.draggingNode;
      if (!draggingNode || !dropNode) return;
      var dropPrev = true;
      var dropInner = true;
      var dropNext = true;
      var userAllowDropInner = true;

      if (typeof _this.allowDrop === 'function') {
        dropPrev = _this.allowDrop(draggingNode.node, dropNode.node, 'prev');
        userAllowDropInner = dropInner = _this.allowDrop(draggingNode.node, dropNode.node, 'inner');
        dropNext = _this.allowDrop(draggingNode.node, dropNode.node, 'next');
      }

      event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';

      if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
        if (oldDropNode) {
          _this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);
        }

        _this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);
      }

      if (dropPrev || dropInner || dropNext) {
        dragState.dropNode = dropNode;
      }

      if (dropNode.node.nextSibling === draggingNode.node) {
        dropNext = false;
      }

      if (dropNode.node.previousSibling === draggingNode.node) {
        dropPrev = false;
      }

      if (dropNode.node.contains(draggingNode.node, false)) {
        dropInner = false;
      }

      if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
        dropPrev = false;
        dropInner = false;
        dropNext = false;
      }

      var targetPosition = dropNode.$el.getBoundingClientRect();

      var treePosition = _this.$el.getBoundingClientRect();

      var dropType;
      var prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
      var nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
      var indicatorTop = -9999;
      var distance = event.clientY - targetPosition.top;

      if (distance < targetPosition.height * prevPercent) {
        dropType = 'before';
      } else if (distance > targetPosition.height * nextPercent) {
        dropType = 'after';
      } else if (dropInner) {
        dropType = 'inner';
      } else {
        dropType = 'none';
      }

      var iconPosition = dropNode.$el.querySelector('.ui-tree-node__expand-icon').getBoundingClientRect();
      var dropIndicator = _this.$refs.dropIndicator;

      if (dropType === 'before') {
        indicatorTop = iconPosition.top - treePosition.top;
      } else if (dropType === 'after') {
        indicatorTop = iconPosition.bottom - treePosition.top;
      }

      dropIndicator.style.top = indicatorTop + 'px';
      dropIndicator.style.left = iconPosition.right - treePosition.left + 'px';

      if (dropType === 'inner') {
        addClass(dropNode.$el, 'is-drop-inner');
      } else {
        removeClass(dropNode.$el, 'is-drop-inner');
      }

      dragState.showDropIndicator = dropType === 'before' || dropType === 'after';
      dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;
      dragState.dropType = dropType;

      _this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);
    });
    this.$on('tree-node-drag-end', function (event) {
      var draggingNode = dragState.draggingNode,
          dropType = dragState.dropType,
          dropNode = dragState.dropNode;
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';

      if (draggingNode && dropNode) {
        var draggingNodeCopy = {
          data: draggingNode.node.data
        };

        if (dropType !== 'none') {
          draggingNode.node.remove();
        }

        if (dropType === 'before') {
          dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
        } else if (dropType === 'after') {
          dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
        } else if (dropType === 'inner') {
          dropNode.node.insertChild(draggingNodeCopy);
        }

        if (dropType !== 'none') {
          _this.store.registerNode(draggingNodeCopy);
        }

        removeClass(dropNode.$el, 'is-drop-inner');

        _this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);

        if (dropType !== 'none') {
          _this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);
        }
      }

      if (draggingNode && !dropNode) {
        _this.$emit('node-drag-end', draggingNode.node, null, dropType, event);
      }

      dragState.showDropIndicator = false;
      dragState.draggingNode = null;
      dragState.dropNode = null;
      dragState.allowDrop = true;
    });
  },
  mounted: function mounted() {
    this.initTabIndex();
    this.$el.addEventListener('keydown', this.handleKeydown);
  },
  updated: function updated() {
    this.treeItems = this.$el.querySelectorAll('[role=treeitem]');
    this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');
  }
};

/* script */
var __vue_script__$v = script$v;
/* template */

var __vue_render__$s = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-tree",
    class: {
      'ui-tree--highlight-current': _vm.highlightCurrent,
      'is-dragging': !!_vm.dragState.draggingNode,
      'is-drop-not-allow': !_vm.dragState.allowDrop,
      'is-drop-inner': _vm.dragState.dropType === 'inner'
    },
    attrs: {
      "role": "tree"
    }
  }, [_vm._l(_vm.root.childNodes, function (child) {
    return _c('ui-tree-node', {
      key: _vm.getNodeKey(child),
      attrs: {
        "node": child,
        "props": _vm.props,
        "render-after-expand": _vm.renderAfterExpand,
        "show-checkbox": _vm.showCheckbox,
        "render-content": _vm.renderContent
      },
      on: {
        "node-expand": _vm.handleNodeExpand
      }
    });
  }), _vm._v(" "), _vm.isEmpty ? _c('div', {
    staticClass: "ui-tree__empty-block"
  }, [_c('span', {
    staticClass: "ui-tree__empty-text"
  }, [_vm._v(_vm._s(_vm.emptyText))])]) : _vm._e(), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.dragState.showDropIndicator,
      expression: "dragState.showDropIndicator"
    }],
    ref: "dropIndicator",
    staticClass: "ui-tree__drop-indicator"
  })], 2);
};

var __vue_staticRenderFns__$s = [];
/* style */

var __vue_inject_styles__$v = undefined;
/* scoped */

var __vue_scope_id__$v = undefined;
/* module identifier */

var __vue_module_identifier__$v = undefined;
/* functional template */

var __vue_is_functional_template__$v = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$v = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$s,
  staticRenderFns: __vue_staticRenderFns__$s
}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

var script$u = {
  name: 'ui-upload',
  components: {
    UiIcon: __vue_component__$1B,
    UiMedia: __vue_component__$X,
    UiUploadDrag: __vue_component__$14
  },
  props: {
    direction: {
      type: String,
      default: 'horizontal'
    },
    showType: {
      type: Number,
      default: 1 //æ¾ç¤ºç±»åï¼1ï¼åªæå³é­ï¼2ï¼å³é­ãé¢è§ãæ¿æ¢

    },
    name: String,
    width: {
      type: [String, Number]
    },
    height: {
      type: [String, Number]
    },

    /**
     * @name æ¯å¦å¯ææ½
     * @prop { boolean } drag
     */
    drag: Boolean,

    /**
     * @name å¤é
     * @prop {boolean} multiple
     */
    multiple: Boolean,

    /**
     * @name accept
     * @prop {string} accept
     */
    accept: String,

    /**
     * @name æ¯å¦æ¾ç¤ºåè¡¨
     * @prop {boolean} listVisible
     */
    listVisible: Boolean,

    /**
     * @name åè¡¨ç±»å
     * @prop {String} listType
     * @option text - ææ¬æ¨¡å¼
     * @option picture - å¾çæ¨¡å¼
     */
    listType: {
      type: String,
      default: 'text' // text | picture

    },

    /**
     * @name é¼ æ ç§»å¥ææ
     * @property {String} hoverEffect
     * @option none - æ ææ
     * @option popover - å¼¹åºæ¡å±ç¤º
     * @option play - å½.typeä¸ºvideoæ¶ï¼ç§»å¥æ­æ¾
     */
    hoverEffect: {
      type: String,
      default: 'popover'
    },

    /**
     * @name æµ®æ¡å®½åº¦
     * @property {Number} popoverWidth
     */
    popoverWidth: {
      type: [Number, String],
      default: 200
    },

    /**
     * @name å°ºå¯¸
     * @prop {String} size
     * @option small - å°
     * @option normal - ä¸­
     * @option large - å¤§
     */
    size: {
      type: String,
      default: 'normal' // 'small', 'normal', 'large'

    },

    /**
     * @name type
     * @prop {String} type
     * @option primary - ä¸»è¦
     * @option secondary - æ¬¡è¦
     */
    type: {
      type: String,
      default: 'primary' // 'primary' or 'secondary'

    },
    color: {
      type: String,
      default: 'default' // 'default', 'primary', 'accent'

    },

    /**
     * @name å¼
     * @property {(File|string)[]} value
     * */
    value: {
      type: [Array, File, String],
      default: null
    },
    disabled: Boolean,
    beforeRemove: Function,
    beforeInput: Function,
    showUploadBtn: {
      type: Boolean,
      default: true
    },
    showReplaceBtn: {
      type: Boolean,
      default: true
    },
    btnWidth: {
      type: [String, Number]
    },
    btnHeight: {
      type: [String, Number]
    },
    icon: {
      type: String,
      default: 'file'
    },
    disabledBtn: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      fileList: [],
      panelShow: false,
      //éæ©æä»¶åï¼å±ç¤ºä¸ä¼ panel
      collapse: false,
      isEdit: false,
      editIdx: null
    };
  },
  computed: {
    elClass: function elClass() {
      return ["ui-upload--".concat(this.listType), "ui-upload--type-".concat(this.type), "ui-upload--color-".concat(this.color), "ui-upload--size-".concat(this.size), {
        'is-drag': this.drag
      }, {
        'is-disabled': this.disabled
      }, {
        'is-disbtn': this.disabledBtn
      }];
    },
    valueList: function valueList() {
      return this.multiple ? this.value : this.value ? [this.value] : [];
    },
    itemStyle: function itemStyle() {
      return {
        width: numToPx(this.width),
        height: numToPx(this.height || this.width)
      };
    },
    slotStyle: function slotStyle() {
      return {
        width: numToPx(this.btnWidth || this.width || this.$attrs['drag-width']),
        height: numToPx(this.btnHeight || this.height || this.$attrs['drag-height'])
      };
    }
  },
  filters: {
    transformByte: function transformByte(size) {
      if (!size) {
        return '0B';
      }

      var num = 1024.0; // byte

      if (size < num) {
        return size + 'B';
      }

      if (size < Math.pow(num, 2)) {
        return (size / num).toFixed(2) + 'K';
      } // kb


      if (size < Math.pow(num, 3)) {
        return (size / Math.pow(num, 2)).toFixed(2) + 'M';
      } // M


      if (size < Math.pow(num, 4)) {
        return (size / Math.pow(num, 3)).toFixed(2) + 'G';
      } // G


      return (size / Math.pow(num, 4)).toFixed(2) + 'T'; // T
    }
  },
  methods: {
    tipsClass: function tipsClass(item) {
      var src = item.name || item;

      if (/\.(jpe?g|png|gif|svg)$/i.test(src)) {
        return 'picture';
      } else if (/\.(mp4|ogg|webm)$/i.test(src)) {
        return 'video';
      } else {
        return 'link';
      }
    },
    renderTips: function renderTips(item) {
      var src = item.name || item;

      if (/\.(jpe?g|png|gif|svg)$/i.test(src)) {
        return 'å¾ç';
      } else if (/\.(mp4|ogg|webm)$/i.test(src)) {
        return 'è§é¢';
      } else {
        return 'é¾æ¥';
      }
    },
    isShowLink: function isShowLink(item) {
      var type = 'unknow';
      var src = item.name || item;

      if (/\.(jpe?g|png|gif|svg)$/i.test(src)) {
        type = 'img';
      } else if (/\.(mp4|ogg|webm)$/i.test(src)) {
        type = 'video';
      }

      if (type == 'unknow' && this.icon == 'link') {
        return true;
      }

      return false;
    },
    onMouseoutMedia: function onMouseoutMedia(event) {
      var target = event.target;
      target.style.top = '101%';
    },
    onMouseoverMedia: function onMouseoverMedia(event) {
      var target = event.target;
      var details = target.parentNode.parentNode.previousSibling;
      details.style.top = 0;
    },
    onPreviewItem: function onPreviewItem(item) {
      var _this = this;

      var _this$mediaProp = this.mediaProp(item),
          type = _this$mediaProp.type,
          src = _this$mediaProp.src;

      if (type == 'unknow' && this.icon == 'link') {
        window.open(src);
        return;
      }

      var url;

      if (src instanceof File) {
        var fr = new FileReader();
        fr.abort();
        fr.readAsDataURL(item);

        fr.onload = function () {
          url = fr.result;
          var obj = {
            type: type,
            url: url
          };

          _this.showMedia(obj);
        };

        return;
      }

      url = src;
      var obj = {
        type: type,
        url: url
      };
      this.showMedia(obj);
    },
    onEdit: function onEdit(item, i) {
      this.isEdit = true;
      this.editIdx = i;
      this.onClick();
    },
    showMedia: function showMedia(obj) {
      var type = obj.type,
          src = obj.url;

      if (type == 'unknow' && this.icon == 'link') {
        window.open(src);
        return;
      }

      this.$message({
        mode: '',
        title: '',
        size: 'auto',
        content: function content(h) {
          return h(type, {
            ref: 'video' === type ? 'media' : '',
            attrs: {
              style: 'max-height: ' + ('video' === type ? '80vh' : '') + '; max-width: 80vw; object-fit: contain;',
              controls: true,
              src: src
            }
          });
        }
      }, {
        mounted: function mounted() {
          if (this.$refs.media && this.$refs.media.paused) {
            var fn = this.$refs.media.play();
            fn && fn.catch(function () {});
          }
        }
      }).catch(function () {});
    },
    onFileInput: function onFileInput(evt) {
      var _this2 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this2.uploadFiles(evt.target.files);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    uploadFiles: function uploadFiles(files) {
      var _this3 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var bool, newValue;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!_this3.disabled) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                _context2.next = 4;
                return new Promise(function (res) {
                  if (typeof _this3.beforeInput === 'function') {
                    _this3.beforeInput(files, function (bool, paths) {
                      files = paths || files;
                      res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 4:
                bool = _context2.sent;

                if (bool) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return");

              case 7:
                if (_this3.multiple) {
                  newValue = [];

                  if (_this3.isEdit) {
                    _this3.value.splice(_this3.editIdx, 1, files[0]);

                    newValue = _this3.value;
                    _this3.isEdit = false;
                    _this3.editIdx = -1;
                  } else {
                    newValue = [].concat(toConsumableArray(_this3.value), toConsumableArray(files));
                  }

                  _this3.$emit('input', newValue);

                  _this3.$emit('success', newValue);
                } else {
                  _this3.$emit('input', files[0] || '');

                  _this3.$emit('success', files[0] || '');
                }

                _this3.$refs.inp.value = '';

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    onRemoveItem: function onRemoveItem(file, i) {
      var _this4 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
        var bool, value, rmdfiles;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!_this4.disabled) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                _context3.next = 4;
                return new Promise(function (res) {
                  if (typeof _this4.beforeRemove === 'function') {
                    _this4.beforeRemove(file, function (bool) {
                      return res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 4:
                bool = _context3.sent;

                if (bool) {
                  value = [].concat(_this4.value);
                  rmdfiles = value.splice(i, 1);

                  _this4.$emit('removed', rmdfiles[0], i);

                  if (_this4.multiple) {
                    _this4.$emit('input', value);
                  } else {
                    _this4.$emit('input', value[0] || '');
                  }
                }

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    onClick: function onClick() {
      if (this.disabled) {
        return;
      }

      this.$refs.inp.click();
    },
    onClickFileItem: function onClickFileItem(item, i) {
      if (this.disabled) {
        return;
      }

      this.$emit('click-file-item', {
        item: item,
        index: i
      });
    },
    onMediaClick: function onMediaClick(item, i) {
      if (this.disabled) {
        return;
      }

      if (this.size === 'small') {
        this.onRemoveItem(item, i);
      }
    },
    mediaProp: function mediaProp(item) {
      var type = 'unknow';
      var size = 50;
      var poster = '';

      if (this.size === 'small') {
        size = 25;
      } else if (this.size === 'large') {
        size = 200;
      }

      var src = item.name || item;

      if (/\.(jpe?g|png|gif|svg)$/i.test(src)) {
        type = 'img';
      } else if (/\.(mp4|ogg|webm)$/i.test(src)) {
        type = 'video'; // poster = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciID48Zz4KICA8cmVjdCB4PSItMSIgeT0iLTEiIHdpZHRoPSIxNzA4LjY2NjY3IiBoZWlnaHQ9IjE3MDguNjY2NjciIGZpbGw9IiMwMDAiLz4KIDwvZz4KIDxnPgogIDxwYXRoIGQ9Im01MTEuMTg5MjQsMTYyLjI0NGMtMTkzLjE0NTksMCAtMzQ5LjcyMjIzLDE1Ni41NzYzMyAtMzQ5LjcyMjIzLDM0OS43MjIyM3MxNTYuNTc2MzMsMzQ5LjcyMjIzIDM0OS43MjIyMywzNDkuNzIyMjNzMzQ5LjcyMjIzLC0xNTYuNTc2MzMgMzQ5LjcyMjIzLC0zNDkuNzIyMjNzLTE1Ni41NzYzMywtMzQ5LjcyMjIzIC0zNDkuNzIyMjMsLTM0OS43MjIyM3ptMCw2MzMuODcxNzFjLTE1Ni45MzA1MywwIC0yODQuMTQ5NDgsLTEyNy4yMTg5NSAtMjg0LjE0OTQ4LC0yODQuMTQ5NDhzMTI3LjIxODk1LC0yODQuMTQ5NDggMjg0LjE0OTQ4LC0yODQuMTQ5NDhzMjg0LjE0OTQ4LDEyNy4yMTg5NSAyODQuMTQ5NDgsMjg0LjE0OTQ4cy0xMjcuMjE4OTUsMjg0LjE0OTQ4IC0yODQuMTQ5NDgsMjg0LjE0OTQ4em0tODcuNDMxMjUsLTQzNy4xNTM0N2wyNjIuMjkyMzYsMTUzLjAwMzk5bC0yNjIuMjkyMzYsMTUzLjAwMzk5bDAsLTMwNi4wMDc5OHoiICBmaWxsPSIjYWFhIi8+CiA8L2c+Cjwvc3ZnPg==`
      }

      return {
        src: item,
        type: type,
        width: this.size === 'flat' ? this.width : size,
        height: this.size === 'flat' ? this.height || this.width : size,
        poster: poster,
        hoverEffect: this.hoverEffect,
        popoverWidth: this.popoverWidth,
        backgroundColor: 'transparent'
      };
    }
  },
  created: function created() {
    if (this.multiple) {
      if (!Array.isArray(this.value)) throw new Error('[UiUpload:multiple]å±æ§å¼ä¸ºtrueæ¶ï¼valueå¿é¡»ä¸ºArrayç±»åã');
    } else {
      if (Array.isArray(this.value)) throw new Error('[UiUpload:multiple]å±æ§å¼ä¸ºfalseæ¶ï¼valueå¿é¡»ä¸ºStringæèFileç±»åã');
    }
  }
};

/* script */
var __vue_script__$u = script$u;
/* template */

var __vue_render__$r = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-upload",
    class: _vm.elClass
  }, [_c('input', {
    ref: "inp",
    staticClass: "ui-upload__input",
    attrs: {
      "name": _vm.name,
      "multiple": _vm.multiple,
      "accept": _vm.accept,
      "type": "file"
    },
    on: {
      "input": _vm.onFileInput
    }
  }), _vm._v(" "), _vm.listVisible && _vm.listType == 'picture' && _vm.showType == 2 ? _vm._l(_vm.valueList, function (item, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-upload__file-item curtom-edit",
      class: _vm.direction == 'vertical' ? 'ui-upload__file-item--vertical' : '',
      style: _vm.itemStyle,
      attrs: {
        "title": item.name || item
      }
    }, [!_vm.disabled ? _c('div', {
      staticClass: "details"
    }, [!_vm.disabled ? _c('ui-button', {
      on: {
        "click": function click($event) {
          return _vm.onPreviewItem(item);
        }
      }
    }, [_vm._v("æ¥ç")]) : _vm._e(), _vm._v(" "), !_vm.disabled && _vm.showReplaceBtn && !_vm.isShowLink(item) ? _c('ui-button', {
      on: {
        "click": function click($event) {
          return _vm.onEdit(item, i);
        }
      }
    }, [_vm._v("æ¿æ¢")]) : _vm._e(), _vm._v(" "), !_vm.disabled ? _c('ui-button', {
      on: {
        "click": function click($event) {
          return _vm.onRemoveItem(item, i);
        }
      }
    }, [_vm._v("å é¤")]) : _vm._e()], 1) : _vm._e(), _vm._v(" "), _c('div', {
      staticClass: "item-tips",
      class: _vm.tipsClass(item)
    }, [_c('span', [_vm._v(_vm._s(_vm.renderTips(item)))])]), _vm._v(" "), _c('ui-media', _vm._b({
      attrs: {
        "hoverEffect": _vm.none,
        "icon": _vm.icon
      },
      on: {
        "click": _vm.showMedia
      }
    }, 'ui-media', _vm.mediaProp(item), false), [_vm.isShowLink(item) ? _c('div', {
      staticClass: "link-text"
    }, [_vm._v(_vm._s(item))]) : _vm._e()])], 1);
  }) : _vm._e(), _vm._v(" "), _vm.listVisible && _vm.listType === 'picture' && _vm.showType == 1 ? _vm._l(_vm.valueList, function (item, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-upload__file-item",
      class: _vm.direction == 'vertical' ? 'ui-upload__file-item--vertical' : '',
      style: _vm.itemStyle,
      attrs: {
        "title": item.name || item
      }
    }, [!_vm.disabled ? _c('a', {
      on: {
        "click": function click($event) {
          return _vm.onRemoveItem(item, i);
        }
      }
    }, [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1) : _vm._e(), _vm._v(" "), _c('ui-media', _vm._b({
      on: {
        "click": _vm.showMedia
      }
    }, 'ui-media', _vm.mediaProp(item), false))], 1);
  }) : _vm._e(), _vm._v(" "), _vm.showUploadBtn ? _c('div', {
    staticClass: "ui-upload__slot",
    class: _vm.direction == 'vertical' ? 'ui-upload__slot--vertical' : '',
    style: _vm.slotStyle,
    on: {
      "click": _vm.onClick
    }
  }, [_c('div', {
    staticClass: "ui-upload__slot-content"
  }, [_vm.drag ? _c('ui-upload-drag', {
    attrs: {
      "width": "100%",
      "height": "100%",
      "accept": _vm.accept,
      "disabled": _vm.disabled
    },
    on: {
      "change": _vm.uploadFiles
    }
  }, [_vm._t("default")], 2) : _vm._t("default"), _vm._v(" "), _vm._t("tip")], 2)]) : _vm._e(), _vm._v(" "), _vm.listVisible && _vm.listType === 'text' ? _c('ul', _vm._l(_vm.valueList, function (item, i) {
    return _c('li', {
      key: i,
      staticClass: "ui-upload__file-item",
      on: {
        "click": function click($event) {
          return _vm.onClickFileItem(item, i);
        }
      }
    }, [_c('ui-media', {
      staticClass: "ui-upload--file-item-icon",
      attrs: {
        "src": item,
        "width": 20,
        "height": 20,
        "background-color": "transparent"
      }
    }), _vm._v(" "), _c('a', {
      attrs: {
        "target": "_blank",
        "rel": "noopener noreferrer",
        "href": item.name || item,
        "download": item.name || item
      }
    }, [_vm._v(_vm._s(item.name || item))]), _vm._v(" "), !_vm.disabled ? _c('a', {
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.onRemoveItem(item, i);
        }
      }
    }, [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1) : _vm._e()], 1);
  }), 0) : _vm._e()], 2);
};

var __vue_staticRenderFns__$r = [];
/* style */

var __vue_inject_styles__$u = undefined;
/* scoped */

var __vue_scope_id__$u = undefined;
/* module identifier */

var __vue_module_identifier__$u = undefined;
/* functional template */

var __vue_is_functional_template__$u = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$u = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$r,
  staticRenderFns: __vue_staticRenderFns__$r
}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

var MAP = 'Map';

// 23.1 Map Objects
_collection(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
  }
}, _collectionStrong, true);

function getInternetExplorerVersion() {
	var ua = window.navigator.userAgent;

	var msie = ua.indexOf('MSIE ');
	if (msie > 0) {
		// IE 10 or older => return version number
		return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	}

	var trident = ua.indexOf('Trident/');
	if (trident > 0) {
		// IE 11 => return version number
		var rv = ua.indexOf('rv:');
		return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	}

	var edge = ua.indexOf('Edge/');
	if (edge > 0) {
		// Edge (IE 12+) => return version number
		return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	}

	// other browser
	return -1;
}

var isIE = void 0;

function initCompat() {
	if (!initCompat.init) {
		initCompat.init = true;
		isIE = getInternetExplorerVersion() !== -1;
	}
}

var ResizeObserver$1 = { render: function render() {
		var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "resize-observer", attrs: { "tabindex": "-1" } });
	}, staticRenderFns: [], _scopeId: 'data-v-b329ee4c',
	name: 'resize-observer',

	methods: {
		compareAndNotify: function compareAndNotify() {
			if (this._w !== this.$el.offsetWidth || this._h !== this.$el.offsetHeight) {
				this._w = this.$el.offsetWidth;
				this._h = this.$el.offsetHeight;
				this.$emit('notify');
			}
		},
		addResizeHandlers: function addResizeHandlers() {
			this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);
			this.compareAndNotify();
		},
		removeResizeHandlers: function removeResizeHandlers() {
			if (this._resizeObject && this._resizeObject.onload) {
				if (!isIE && this._resizeObject.contentDocument) {
					this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);
				}
				delete this._resizeObject.onload;
			}
		}
	},

	mounted: function mounted() {
		var _this = this;

		initCompat();
		this.$nextTick(function () {
			_this._w = _this.$el.offsetWidth;
			_this._h = _this.$el.offsetHeight;
		});
		var object = document.createElement('object');
		this._resizeObject = object;
		object.setAttribute('aria-hidden', 'true');
		object.setAttribute('tabindex', -1);
		object.onload = this.addResizeHandlers;
		object.type = 'text/html';
		if (isIE) {
			this.$el.appendChild(object);
		}
		object.data = 'about:blank';
		if (!isIE) {
			this.$el.appendChild(object);
		}
	},
	beforeDestroy: function beforeDestroy() {
		this.removeResizeHandlers();
	}
};

// Install the components
function install$1(Vue) {
	Vue.component('resize-observer', ResizeObserver$1);
	Vue.component('ResizeObserver', ResizeObserver$1);
}

// Plugin
var plugin$2 = {
	// eslint-disable-next-line no-undef
	version: "0.4.5",
	install: install$1
};

// Auto-install
var GlobalVue$2 = null;
if (typeof window !== 'undefined') {
	GlobalVue$2 = window.Vue;
} else if (typeof global !== 'undefined') {
	GlobalVue$2 = global.Vue;
}
if (GlobalVue$2) {
	GlobalVue$2.use(plugin$2);
}

function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function processOptions(value) {
  var options;

  if (typeof value === 'function') {
    // Simple options (callback-only)
    options = {
      callback: value
    };
  } else {
    // Options object
    options = value;
  }

  return options;
}
function throttle(callback, delay) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var timeout;
  var lastState;
  var currentArgs;

  var throttled = function throttled(state) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    currentArgs = args;
    if (timeout && state === lastState) return;
    var leading = options.leading;

    if (typeof leading === 'function') {
      leading = leading(state, lastState);
    }

    if ((!timeout || state !== lastState) && leading) {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
    }

    lastState = state;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
      timeout = 0;
    }, delay);
  };

  throttled._clear = function () {
    clearTimeout(timeout);
    timeout = null;
  };

  return throttled;
}
function deepEqual(val1, val2) {
  if (val1 === val2) return true;

  if (_typeof$1(val1) === 'object') {
    for (var key in val1) {
      if (!deepEqual(val1[key], val2[key])) {
        return false;
      }
    }

    return true;
  }

  return false;
}

var VisibilityState =
/*#__PURE__*/
function () {
  function VisibilityState(el, options, vnode) {
    _classCallCheck(this, VisibilityState);

    this.el = el;
    this.observer = null;
    this.frozen = false;
    this.createObserver(options, vnode);
  }

  _createClass(VisibilityState, [{
    key: "createObserver",
    value: function createObserver(options, vnode) {
      var _this = this;

      if (this.observer) {
        this.destroyObserver();
      }

      if (this.frozen) return;
      this.options = processOptions(options);

      this.callback = function (result, entry) {
        _this.options.callback(result, entry);

        if (result && _this.options.once) {
          _this.frozen = true;

          _this.destroyObserver();
        }
      }; // Throttle


      if (this.callback && this.options.throttle) {
        var _ref = this.options.throttleOptions || {},
            _leading = _ref.leading;

        this.callback = throttle(this.callback, this.options.throttle, {
          leading: function leading(state) {
            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;
          }
        });
      }

      this.oldResult = undefined;
      this.observer = new IntersectionObserver(function (entries) {
        var entry = entries[0];

        if (entries.length > 1) {
          var intersectingEntry = entries.find(function (e) {
            return e.isIntersecting;
          });

          if (intersectingEntry) {
            entry = intersectingEntry;
          }
        }

        if (_this.callback) {
          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.
          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
          if (result === _this.oldResult) return;
          _this.oldResult = result;

          _this.callback(result, entry);
        }
      }, this.options.intersection); // Wait for the element to be in document

      vnode.context.$nextTick(function () {
        if (_this.observer) {
          _this.observer.observe(_this.el);
        }
      });
    }
  }, {
    key: "destroyObserver",
    value: function destroyObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      } // Cancel throttled call


      if (this.callback && this.callback._clear) {
        this.callback._clear();

        this.callback = null;
      }
    }
  }, {
    key: "threshold",
    get: function get() {
      return this.options.intersection && this.options.intersection.threshold || 0;
    }
  }]);

  return VisibilityState;
}();

function bind$1(el, _ref2, vnode) {
  var value = _ref2.value;
  if (!value) return;

  if (typeof IntersectionObserver === 'undefined') {
    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');
  } else {
    var state = new VisibilityState(el, value, vnode);
    el._vue_visibilityState = state;
  }
}

function update(el, _ref3, vnode) {
  var value = _ref3.value,
      oldValue = _ref3.oldValue;
  if (deepEqual(value, oldValue)) return;
  var state = el._vue_visibilityState;

  if (!value) {
    unbind(el);
    return;
  }

  if (state) {
    state.createObserver(value, vnode);
  } else {
    bind$1(el, {
      value: value
    }, vnode);
  }
}

function unbind(el) {
  var state = el._vue_visibilityState;

  if (state) {
    state.destroyObserver();
    delete el._vue_visibilityState;
  }
}

var ObserveVisibility = {
  bind: bind$1,
  update: update,
  unbind: unbind
};

function install(Vue) {
  Vue.directive('observe-visibility', ObserveVisibility);
  /* -- Add more components here -- */
}
/* -- Plugin definition & Auto-install -- */

/* You shouldn't have to modify the code below */
// Plugin

var plugin$1 = {
  // eslint-disable-next-line no-undef
  version: "0.4.6",
  install: install
};

var GlobalVue$1 = null;

if (typeof window !== 'undefined') {
  GlobalVue$1 = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue$1 = global.Vue;
}

if (GlobalVue$1) {
  GlobalVue$1.use(plugin$1);
}

var scrollparent = createCommonjsModule(function (module) {
(function (root, factory) {
  if (module.exports) {
    module.exports = factory();
  } else {
    root.Scrollparent = factory();
  }
}(commonjsGlobal, function () {
  var regex = /(auto|scroll)/;

  var parents = function (node, ps) {
    if (node.parentNode === null) { return ps; }

    return parents(node.parentNode, ps.concat([node]));
  };

  var style = function (node, prop) {
    return getComputedStyle(node, null).getPropertyValue(prop);
  };

  var overflow = function (node) {
    return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
  };

  var scroll = function (node) {
   return regex.test(overflow(node));
  };

  var scrollParent = function (node) {
    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
      return ;
    }

    var ps = parents(node.parentNode, []);

    for (var i = 0; i < ps.length; i += 1) {
      if (scroll(ps[i])) {
        return ps[i];
      }
    }

    return document.scrollingElement || document.documentElement;
  };

  return scrollParent;
}));
});

var config$1 = {
  itemsLimit: 1000
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var props$1 = {
  items: {
    type: Array,
    required: true
  },
  keyField: {
    type: String,
    default: 'id'
  },
  direction: {
    type: String,
    default: 'vertical',
    validator: function validator(value) {
      return ['vertical', 'horizontal'].includes(value);
    }
  }
};

function simpleArray() {
  return this.items.length && _typeof(this.items[0]) !== 'object';
}

var supportsPassive = false;

if (typeof window !== 'undefined') {
  supportsPassive = false;

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('test', null, opts);
  } catch (e) {}
}

var uid = 0;
var script$t = {
  name: 'RecycleScroller',
  components: {
    ResizeObserver: ResizeObserver$1
  },
  directives: {
    ObserveVisibility: ObserveVisibility
  },
  props: _objectSpread2({}, props$1, {
    itemSize: {
      type: Number,
      default: null
    },
    minItemSize: {
      type: [Number, String],
      default: null
    },
    sizeField: {
      type: String,
      default: 'size'
    },
    typeField: {
      type: String,
      default: 'type'
    },
    buffer: {
      type: Number,
      default: 200
    },
    pageMode: {
      type: Boolean,
      default: false
    },
    prerender: {
      type: Number,
      default: 0
    },
    emitUpdate: {
      type: Boolean,
      default: false
    }
  }),
  data: function data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },
  computed: {
    sizes: function sizes() {
      if (this.itemSize === null) {
        var sizes = {
          '-1': {
            accumulator: 0
          }
        };
        var items = this.items;
        var field = this.sizeField;
        var minItemSize = this.minItemSize;
        var computedMinSize = 10000;
        var accumulator = 0;
        var current;

        for (var i = 0, l = items.length; i < l; i++) {
          current = items[i][field] || minItemSize;

          if (current < computedMinSize) {
            computedMinSize = current;
          }

          accumulator += current;
          sizes[i] = {
            accumulator: accumulator,
            size: current
          };
        } // eslint-disable-next-line


        this.$_computedMinItemSize = computedMinSize;
        return sizes;
      }

      return [];
    },
    simpleArray: simpleArray
  },
  watch: {
    items: function items() {
      this.updateVisibleItems(true);
    },
    pageMode: function pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },
    sizes: {
      handler: function handler() {
        this.updateVisibleItems(false);
      },
      deep: true
    }
  },
  created: function created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = new Map();
    this.$_unusedViews = new Map();
    this.$_scrollDirty = false;
    this.$_lastUpdateScrollPosition = 0; // In SSR mode, we also prerender the same number of item for the first render
    // to avoir mismatch between server and client templates

    if (this.prerender) {
      this.$_prerender = true;
      this.updateVisibleItems(false);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.applyPageMode();
    this.$nextTick(function () {
      // In SSR mode, render the real number of visible items
      _this.$_prerender = false;

      _this.updateVisibleItems(true);

      _this.ready = true;
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.removeListeners();
  },
  methods: {
    addView: function addView(pool, index, item, key, type) {
      var view = {
        item: item,
        position: 0
      };
      var nonReactive = {
        id: uid++,
        index: index,
        used: true,
        key: key,
        type: type
      };
      Object.defineProperty(view, 'nr', {
        configurable: false,
        value: nonReactive
      });
      pool.push(view);
      return view;
    },
    unuseView: function unuseView(view) {
      var fake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var unusedViews = this.$_unusedViews;
      var type = view.nr.type;
      var unusedPool = unusedViews.get(type);

      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type, unusedPool);
      }

      unusedPool.push(view);

      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
        this.$_views.delete(view.nr.key);
      }
    },
    handleResize: function handleResize() {
      this.$emit('resize');
      if (this.ready) this.updateVisibleItems(false);
    },
    handleScroll: function handleScroll(event) {
      var _this2 = this;

      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        requestAnimationFrame(function () {
          _this2.$_scrollDirty = false;

          var _this2$updateVisibleI = _this2.updateVisibleItems(false, true),
              continuous = _this2$updateVisibleI.continuous; // It seems sometimes chrome doesn't fire scroll event :/
          // When non continous scrolling is ending, we force a refresh


          if (!continuous) {
            clearTimeout(_this2.$_refreshTimout);
            _this2.$_refreshTimout = setTimeout(_this2.handleScroll, 100);
          }
        });
      }
    },
    handleVisibilityChange: function handleVisibilityChange(isVisible, entry) {
      var _this3 = this;

      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit('visible');
          requestAnimationFrame(function () {
            _this3.updateVisibleItems(false);
          });
        } else {
          this.$emit('hidden');
        }
      }
    },
    updateVisibleItems: function updateVisibleItems(checkItem) {
      var checkPositionDiff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var itemSize = this.itemSize;
      var minItemSize = this.$_computedMinItemSize;
      var typeField = this.typeField;
      var keyField = this.simpleArray ? null : this.keyField;
      var items = this.items;
      var count = items.length;
      var sizes = this.sizes;
      var views = this.$_views;
      var unusedViews = this.$_unusedViews;
      var pool = this.pool;
      var startIndex, endIndex;
      var totalSize;

      if (!count) {
        startIndex = endIndex = totalSize = 0;
      } else if (this.$_prerender) {
        startIndex = 0;
        endIndex = this.prerender;
        totalSize = null;
      } else {
        var scroll = this.getScroll(); // Skip update if use hasn't scrolled enough

        if (checkPositionDiff) {
          var positionDiff = scroll.start - this.$_lastUpdateScrollPosition;
          if (positionDiff < 0) positionDiff = -positionDiff;

          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
            return {
              continuous: true
            };
          }
        }

        this.$_lastUpdateScrollPosition = scroll.start;
        var buffer = this.buffer;
        scroll.start -= buffer;
        scroll.end += buffer; // Variable size mode

        if (itemSize === null) {
          var h;
          var a = 0;
          var b = count - 1;
          var i = ~~(count / 2);
          var oldI; // Searching for startIndex

          do {
            oldI = i;
            h = sizes[i].accumulator;

            if (h < scroll.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {
              b = i;
            }

            i = ~~((a + b) / 2);
          } while (i !== oldI);

          i < 0 && (i = 0);
          startIndex = i; // For container style

          totalSize = sizes[count - 1].accumulator; // Searching for endIndex

          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++) {}

          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++; // Bounds

            endIndex > count && (endIndex = count);
          }
        } else {
          // Fixed size mode
          startIndex = ~~(scroll.start / itemSize);
          endIndex = Math.ceil(scroll.end / itemSize); // Bounds

          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);
          totalSize = count * itemSize;
        }
      }

      if (endIndex - startIndex > config$1.itemsLimit) {
        this.itemsLimitError();
      }

      this.totalSize = totalSize;
      var view;
      var continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;

      if (this.$_continuous !== continuous) {
        if (continuous) {
          views.clear();
          unusedViews.clear();

          for (var _i = 0, l = pool.length; _i < l; _i++) {
            view = pool[_i];
            this.unuseView(view);
          }
        }

        this.$_continuous = continuous;
      } else if (continuous) {
        for (var _i2 = 0, _l = pool.length; _i2 < _l; _i2++) {
          view = pool[_i2];

          if (view.nr.used) {
            // Update view item index
            if (checkItem) {
              view.nr.index = items.findIndex(function (item) {
                return keyField ? item[keyField] === view.item[keyField] : item === view.item;
              });
            } // Check if index is still in visible range


            if (view.nr.index === -1 || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }

      var unusedIndex = continuous ? null : new Map();
      var item, type, unusedPool;
      var v;

      for (var _i3 = startIndex; _i3 < endIndex; _i3++) {
        item = items[_i3];
        var key = keyField ? item[keyField] : item;

        if (key == null) {
          throw new Error("Key is ".concat(key, " on item (keyField is '").concat(keyField, "')"));
        }

        view = views.get(key);

        if (!itemSize && !sizes[_i3].size) {
          if (view) this.unuseView(view);
          continue;
        } // No view assigned to item


        if (!view) {
          type = item[typeField];
          unusedPool = unusedViews.get(type);

          if (continuous) {
            // Reuse existing view
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
              view.item = item;
              view.nr.used = true;
              view.nr.index = _i3;
              view.nr.key = key;
              view.nr.type = type;
            } else {
              view = this.addView(pool, _i3, item, key, type);
            }
          } else {
            // Use existing view
            // We don't care if they are already used
            // because we are not in continous scrolling
            v = unusedIndex.get(type) || 0;

            if (!unusedPool || v >= unusedPool.length) {
              view = this.addView(pool, _i3, item, key, type);
              this.unuseView(view, true);
              unusedPool = unusedViews.get(type);
            }

            view = unusedPool[v];
            view.item = item;
            view.nr.used = true;
            view.nr.index = _i3;
            view.nr.key = key;
            view.nr.type = type;
            unusedIndex.set(type, v + 1);
            v++;
          }

          views.set(key, view);
        } else {
          view.nr.used = true;
          view.item = item;
        } // Update position


        if (itemSize === null) {
          view.position = sizes[_i3 - 1].accumulator;
        } else {
          view.position = _i3 * itemSize;
        }
      }

      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;
      if (this.emitUpdate) this.$emit('update', startIndex, endIndex); // After the user has finished scrolling
      // Sort views so text selection is correct

      clearTimeout(this.$_sortTimer);
      this.$_sortTimer = setTimeout(this.sortViews, 300);
      return {
        continuous: continuous
      };
    },
    getListenerTarget: function getListenerTarget() {
      var target = scrollparent(this.$el); // Fix global scroll target for Chrome and Safari

      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }

      return target;
    },
    getScroll: function getScroll() {
      var el = this.$el,
          direction = this.direction;
      var isVertical = direction === 'vertical';
      var scrollState;

      if (this.pageMode) {
        var bounds = el.getBoundingClientRect();
        var boundsSize = isVertical ? bounds.height : bounds.width;
        var start = -(isVertical ? bounds.top : bounds.left);
        var size = isVertical ? window.innerHeight : window.innerWidth;

        if (start < 0) {
          size += start;
          start = 0;
        }

        if (start + size > boundsSize) {
          size = boundsSize - start;
        }

        scrollState = {
          start: start,
          end: start + size
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }

      return scrollState;
    },
    applyPageMode: function applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners: function addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener('resize', this.handleResize);
    },
    removeListeners: function removeListeners() {
      if (!this.listenerTarget) {
        return;
      }

      this.listenerTarget.removeEventListener('scroll', this.handleScroll);
      this.listenerTarget.removeEventListener('resize', this.handleResize);
      this.listenerTarget = null;
    },
    scrollToItem: function scrollToItem(index) {
      var scroll;

      if (this.itemSize === null) {
        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0;
      } else {
        scroll = index * this.itemSize;
      }

      this.scrollToPosition(scroll);
    },
    scrollToPosition: function scrollToPosition(position) {
      if (this.direction === 'vertical') {
        this.$el.scrollTop = position;
      } else {
        this.$el.scrollLeft = position;
      }
    },
    itemsLimitError: function itemsLimitError() {

      setTimeout(function () {
      });
      throw new Error('Rendered items limit reached');
    },
    sortViews: function sortViews() {
      this.pool.sort(function (viewA, viewB) {
        return viewA.nr.index - viewB.nr.index;
      });
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function (context) {
      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}
/* script */


var __vue_script__$t = script$t;
/* template */

var __vue_render__$q = function __vue_render__() {
  var _obj, _obj$1;

  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c("div", {
    directives: [{
      name: "observe-visibility",
      rawName: "v-observe-visibility",
      value: _vm.handleVisibilityChange,
      expression: "handleVisibilityChange"
    }],
    staticClass: "vue-recycle-scroller",
    class: (_obj = {
      ready: _vm.ready,
      "page-mode": _vm.pageMode
    }, _obj["direction-" + _vm.direction] = true, _obj),
    on: {
      "&scroll": function scroll($event) {
        return _vm.handleScroll($event);
      }
    }
  }, [_vm.$slots.before ? _c("div", {
    staticClass: "vue-recycle-scroller__slot"
  }, [_vm._t("before")], 2) : _vm._e(), _vm._v(" "), _c("div", {
    ref: "wrapper",
    staticClass: "vue-recycle-scroller__item-wrapper",
    style: (_obj$1 = {}, _obj$1[_vm.direction === "vertical" ? "minHeight" : "minWidth"] = _vm.totalSize + "px", _obj$1)
  }, _vm._l(_vm.pool, function (view) {
    return _c("div", {
      key: view.nr.id,
      staticClass: "vue-recycle-scroller__item-view",
      class: {
        hover: _vm.hoverKey === view.nr.key
      },
      style: _vm.ready ? {
        transform: "translate" + (_vm.direction === "vertical" ? "Y" : "X") + "(" + view.position + "px)"
      } : null,
      on: {
        mouseenter: function mouseenter($event) {
          _vm.hoverKey = view.nr.key;
        },
        mouseleave: function mouseleave($event) {
          _vm.hoverKey = null;
        }
      }
    }, [_vm._t("default", null, {
      item: view.item,
      index: view.nr.index,
      active: view.nr.used
    })], 2);
  }), 0), _vm._v(" "), _vm.$slots.after ? _c("div", {
    staticClass: "vue-recycle-scroller__slot"
  }, [_vm._t("after")], 2) : _vm._e(), _vm._v(" "), _c("ResizeObserver", {
    on: {
      notify: _vm.handleResize
    }
  })], 1);
};

var __vue_staticRenderFns__$q = [];
__vue_render__$q._withStripped = true;
/* style */

var __vue_inject_styles__$t = undefined;
/* scoped */

var __vue_scope_id__$t = undefined;
/* module identifier */

var __vue_module_identifier__$t = undefined;
/* functional template */

var __vue_is_functional_template__$t = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$t = normalizeComponent({
  render: __vue_render__$q,
  staticRenderFns: __vue_staticRenderFns__$q
}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

var script$1$1 = {
  name: 'DynamicScroller',
  components: {
    RecycleScroller: __vue_component__$t
  },
  inheritAttrs: false,
  provide: function provide() {
    if (typeof ResizeObserver !== 'undefined') {
      this.$_resizeObserver = new ResizeObserver(function (entries) {
        var _iterator = _createForOfIteratorHelper(entries),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;

            if (entry.target) {
              var event = new CustomEvent('resize', {
                detail: {
                  contentRect: entry.contentRect
                }
              });
              entry.target.dispatchEvent(event);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }

    return {
      vscrollData: this.vscrollData,
      vscrollParent: this,
      vscrollResizeObserver: this.$_resizeObserver
    };
  },
  props: _objectSpread2({}, props$1, {
    minItemSize: {
      type: [Number, String],
      required: true
    }
  }),
  data: function data() {
    return {
      vscrollData: {
        active: true,
        sizes: {},
        validSizes: {},
        keyField: this.keyField,
        simpleArray: false
      }
    };
  },
  computed: {
    simpleArray: simpleArray,
    itemsWithSize: function itemsWithSize() {
      var result = [];
      var items = this.items,
          keyField = this.keyField,
          simpleArray = this.simpleArray;
      var sizes = this.vscrollData.sizes;

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var id = simpleArray ? i : item[keyField];
        var size = sizes[id];

        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {
          size = 0;
        }

        result.push({
          item: item,
          id: id,
          size: size
        });
      }

      return result;
    },
    listeners: function listeners() {
      var listeners = {};

      for (var key in this.$listeners) {
        if (key !== 'resize' && key !== 'visible') {
          listeners[key] = this.$listeners[key];
        }
      }

      return listeners;
    }
  },
  watch: {
    items: function items() {
      this.forceUpdate(false);
    },
    simpleArray: {
      handler: function handler(value) {
        this.vscrollData.simpleArray = value;
      },
      immediate: true
    },
    direction: function direction(value) {
      this.forceUpdate(true);
    }
  },
  created: function created() {
    this.$_updates = [];
    this.$_undefinedSizes = 0;
    this.$_undefinedMap = {};
  },
  activated: function activated() {
    this.vscrollData.active = true;
  },
  deactivated: function deactivated() {
    this.vscrollData.active = false;
  },
  methods: {
    onScrollerResize: function onScrollerResize() {
      var scroller = this.$refs.scroller;

      if (scroller) {
        this.forceUpdate();
      }

      this.$emit('resize');
    },
    onScrollerVisible: function onScrollerVisible() {
      this.$emit('vscroll:update', {
        force: false
      });
      this.$emit('visible');
    },
    forceUpdate: function forceUpdate() {
      var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (clear || this.simpleArray) {
        this.vscrollData.validSizes = {};
      }

      this.$emit('vscroll:update', {
        force: true
      });
    },
    scrollToItem: function scrollToItem(index) {
      var scroller = this.$refs.scroller;
      if (scroller) scroller.scrollToItem(index);
    },
    getItemSize: function getItemSize(item) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var id = this.simpleArray ? index != null ? index : this.items.indexOf(item) : item[this.keyField];
      return this.vscrollData.sizes[id] || 0;
    },
    scrollToBottom: function scrollToBottom() {
      var _this = this;

      if (this.$_scrollingToBottom) return;
      this.$_scrollingToBottom = true;
      var el = this.$el; // Item is inserted to the DOM

      this.$nextTick(function () {
        el.scrollTop = el.scrollHeight + 5000; // Item sizes are computed

        var cb = function cb() {
          el.scrollTop = el.scrollHeight + 5000;
          requestAnimationFrame(function () {
            el.scrollTop = el.scrollHeight + 5000;

            if (_this.$_undefinedSizes === 0) {
              _this.$_scrollingToBottom = false;
            } else {
              requestAnimationFrame(cb);
            }
          });
        };

        requestAnimationFrame(cb);
      });
    }
  }
};
/* script */

var __vue_script__$1$1 = script$1$1;
/* template */

var __vue_render__$1$1 = function __vue_render__$1() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c("RecycleScroller", _vm._g(_vm._b({
    ref: "scroller",
    attrs: {
      items: _vm.itemsWithSize,
      "min-item-size": _vm.minItemSize,
      direction: _vm.direction,
      "key-field": "id"
    },
    on: {
      resize: _vm.onScrollerResize,
      visible: _vm.onScrollerVisible
    },
    scopedSlots: _vm._u([{
      key: "default",
      fn: function fn(ref) {
        var itemWithSize = ref.item;
        var index = ref.index;
        var active = ref.active;
        return [_vm._t("default", null, null, {
          item: itemWithSize.item,
          index: index,
          active: active,
          itemWithSize: itemWithSize
        })];
      }
    }], null, true)
  }, "RecycleScroller", _vm.$attrs, false), _vm.listeners), [_vm._v(" "), _c("template", {
    slot: "before"
  }, [_vm._t("before")], 2), _vm._v(" "), _c("template", {
    slot: "after"
  }, [_vm._t("after")], 2)], 2);
};

var __vue_staticRenderFns__$1$1 = [];
__vue_render__$1$1._withStripped = true;
/* style */

var __vue_inject_styles__$1$1 = undefined;
/* scoped */

var __vue_scope_id__$1$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1$1 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1$1 = normalizeComponent({
  render: __vue_render__$1$1,
  staticRenderFns: __vue_staticRenderFns__$1$1
}, __vue_inject_styles__$1$1, __vue_script__$1$1, __vue_scope_id__$1$1, __vue_is_functional_template__$1$1, __vue_module_identifier__$1$1, false, undefined, undefined, undefined);

var script$2$1 = {
  name: 'DynamicScrollerItem',
  inject: ['vscrollData', 'vscrollParent', 'vscrollResizeObserver'],
  props: {
    // eslint-disable-next-line vue/require-prop-types
    item: {
      required: true
    },
    watchData: {
      type: Boolean,
      default: false
    },

    /**
     * Indicates if the view is actively used to display an item.
     */
    active: {
      type: Boolean,
      required: true
    },
    index: {
      type: Number,
      default: undefined
    },
    sizeDependencies: {
      type: [Array, Object],
      default: null
    },
    emitResize: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'div'
    }
  },
  computed: {
    id: function id() {
      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];
    },
    size: function size() {
      return this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id] || 0;
    },
    finalActive: function finalActive() {
      return this.active && this.vscrollData.active;
    }
  },
  watch: {
    watchData: 'updateWatchData',
    id: function id() {
      if (!this.size) {
        this.onDataUpdate();
      }
    },
    finalActive: function finalActive(value) {
      if (!this.size) {
        if (value) {
          if (!this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes++;
            this.vscrollParent.$_undefinedMap[this.id] = true;
          }
        } else {
          if (this.vscrollParent.$_undefinedMap[this.id]) {
            this.vscrollParent.$_undefinedSizes--;
            this.vscrollParent.$_undefinedMap[this.id] = false;
          }
        }
      }

      if (this.vscrollResizeObserver) {
        if (value) {
          this.observeSize();
        } else {
          this.unobserveSize();
        }
      } else if (value && this.$_pendingVScrollUpdate === this.id) {
        this.updateSize();
      }
    }
  },
  created: function created() {
    var _this = this;

    if (this.$isServer) return;
    this.$_forceNextVScrollUpdate = null;
    this.updateWatchData();

    if (!this.vscrollResizeObserver) {
      var _loop = function _loop(k) {
        _this.$watch(function () {
          return _this.sizeDependencies[k];
        }, _this.onDataUpdate);
      };

      for (var k in this.sizeDependencies) {
        _loop(k);
      }

      this.vscrollParent.$on('vscroll:update', this.onVscrollUpdate);
      this.vscrollParent.$on('vscroll:update-size', this.onVscrollUpdateSize);
    }
  },
  mounted: function mounted() {
    if (this.vscrollData.active) {
      this.updateSize();
      this.observeSize();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.vscrollParent.$off('vscroll:update', this.onVscrollUpdate);
    this.vscrollParent.$off('vscroll:update-size', this.onVscrollUpdateSize);
    this.unobserveSize();
  },
  methods: {
    updateSize: function updateSize() {
      if (this.finalActive) {
        if (this.$_pendingSizeUpdate !== this.id) {
          this.$_pendingSizeUpdate = this.id;
          this.$_forceNextVScrollUpdate = null;
          this.$_pendingVScrollUpdate = null;
          this.computeSize(this.id);
        }
      } else {
        this.$_forceNextVScrollUpdate = this.id;
      }
    },
    updateWatchData: function updateWatchData() {
      var _this2 = this;

      if (this.watchData) {
        this.$_watchData = this.$watch('data', function () {
          _this2.onDataUpdate();
        }, {
          deep: true
        });
      } else if (this.$_watchData) {
        this.$_watchData();
        this.$_watchData = null;
      }
    },
    onVscrollUpdate: function onVscrollUpdate(_ref) {
      var force = _ref.force; // If not active, sechedule a size update when it becomes active

      if (!this.finalActive && force) {
        this.$_pendingVScrollUpdate = this.id;
      }

      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {
        this.updateSize();
      }
    },
    onDataUpdate: function onDataUpdate() {
      this.updateSize();
    },
    computeSize: function computeSize(id) {
      var _this3 = this;

      this.$nextTick(function () {
        if (_this3.id === id) {
          var width = _this3.$el.offsetWidth;
          var height = _this3.$el.offsetHeight;

          _this3.applySize(width, height);
        }

        _this3.$_pendingSizeUpdate = null;
      });
    },
    applySize: function applySize(width, height) {
      var size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width);

      if (size && this.size !== size) {
        if (this.vscrollParent.$_undefinedMap[this.id]) {
          this.vscrollParent.$_undefinedSizes--;
          this.vscrollParent.$_undefinedMap[this.id] = undefined;
        }

        this.$set(this.vscrollData.sizes, this.id, size);
        this.$set(this.vscrollData.validSizes, this.id, true);
        if (this.emitResize) this.$emit('resize', this.id);
      }
    },
    observeSize: function observeSize() {
      if (!this.vscrollResizeObserver) return;
      this.vscrollResizeObserver.observe(this.$el.parentNode);
      this.$el.parentNode.addEventListener('resize', this.onResize);
    },
    unobserveSize: function unobserveSize() {
      if (!this.vscrollResizeObserver) return;
      this.vscrollResizeObserver.unobserve(this.$el.parentNode);
      this.$el.parentNode.removeEventListener('resize', this.onResize);
    },
    onResize: function onResize(event) {
      var _event$detail$content = event.detail.contentRect,
          width = _event$detail$content.width,
          height = _event$detail$content.height;
      this.applySize(width, height);
    }
  },
  render: function render(h) {
    return h(this.tag, this.$slots.default);
  }
};
/* script */

var __vue_script__$2$1 = script$2$1;
/* template */

/* style */

var __vue_inject_styles__$2$1 = undefined;
/* scoped */

var __vue_scope_id__$2$1 = undefined;
/* module identifier */

var __vue_module_identifier__$2$1 = undefined;
/* functional template */

var __vue_is_functional_template__$2$1 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$2$1 = normalizeComponent({}, __vue_inject_styles__$2$1, __vue_script__$2$1, __vue_scope_id__$2$1, __vue_is_functional_template__$2$1, __vue_module_identifier__$2$1, false, undefined, undefined, undefined);

function registerComponents(Vue, prefix) {
  Vue.component("".concat(prefix, "recycle-scroller"), __vue_component__$t);
  Vue.component("".concat(prefix, "RecycleScroller"), __vue_component__$t);
  Vue.component("".concat(prefix, "dynamic-scroller"), __vue_component__$1$1);
  Vue.component("".concat(prefix, "DynamicScroller"), __vue_component__$1$1);
  Vue.component("".concat(prefix, "dynamic-scroller-item"), __vue_component__$2$1);
  Vue.component("".concat(prefix, "DynamicScrollerItem"), __vue_component__$2$1);
}

var plugin = {
  // eslint-disable-next-line no-undef
  version: "1.0.10",
  install: function install(Vue, options) {
    var finalOptions = Object.assign({}, {
      installComponents: true,
      componentsPrefix: ''
    }, options);

    for (var key in finalOptions) {
      if (typeof finalOptions[key] !== 'undefined') {
        config$1[key] = finalOptions[key];
      }
    }

    if (finalOptions.installComponents) {
      registerComponents(Vue, finalOptions.componentsPrefix);
    }
  }
};
var GlobalVue = null;

if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}

if (GlobalVue) {
  GlobalVue.use(plugin);
}

var script$s = {
  name: 'ui-virtual-list',
  props: {
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    direction: {
      type: String,
      default: 'vertical'
    },
    minItemSize: {
      type: Number,
      default: 80
    },
    keyField: {
      type: String,
      default: '$$id'
    }
  },
  components: {
    DynamicScroller: __vue_component__$1$1,
    DynamicScrollerItem: __vue_component__$2$1
  },
  data: function data() {
    return {};
  },
  computed: {
    items: function items() {
      if (this.keyField !== '$$id') {
        return this.options;
      }

      return this.options.map(function (item, i) {
        if (_typeof_1(item) !== 'object') {
          return item;
        }

        if (!item.$$id) {
          item.$$id = i;
        }

        return item;
      });
    }
  },
  mounted: function mounted() {},
  methods: {},
  beforeDestroy: function beforeDestroy() {}
};

/* script */
var __vue_script__$s = script$s;
/* template */

var __vue_render__$p = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('DynamicScroller', _vm._b({
    staticClass: "ui-virtual-list",
    attrs: {
      "key-field": _vm.keyField,
      "items": _vm.items,
      "min-item-size": _vm.minItemSize,
      "direction": _vm.direction
    },
    scopedSlots: _vm._u([{
      key: "default",
      fn: function fn(ref) {
        var item = ref.item;
        var index = ref.index;
        var active = ref.active;
        return _c('DynamicScrollerItem', {
          attrs: {
            "item": item,
            "active": active,
            "data-index": index,
            "data-active": active
          }
        }, [_vm._t("default", null, null, {
          item: item,
          index: index
        })], 2);
      }
    }], null, true)
  }, 'DynamicScroller', _vm.$attrs, false));
};

var __vue_staticRenderFns__$p = [];
/* style */

var __vue_inject_styles__$s = undefined;
/* scoped */

var __vue_scope_id__$s = undefined;
/* module identifier */

var __vue_module_identifier__$s = undefined;
/* functional template */

var __vue_is_functional_template__$s = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$s = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$p,
  staticRenderFns: __vue_staticRenderFns__$p
}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var prefixCls$3 = 'ui-card';
var script$r = {
  name: 'ui-card',
  props: {
    type: {
      type: String,
      default: 'none' // 'inner'

    },
    //æ é¢
    title: {
      type: String,
      default: ''
    },
    //é´å½±æ¾ç¤ºæ¶æº
    shadow: {
      type: String,
      default: '' // 'always':ä¸ç´æ¾ç¤º 'never': ä¸æ¾ç¤º 'hover': é¼ æ ç§»ä¸å»æ¾ç¤º

    },
    //æ¯å¦æ¾ç¤ºè¾¹æ¡
    bordered: {
      type: Boolean,
      default: true
    },
    //åè§å¤§å°
    borderRadius: {
      type: Number,
      default: 0
    }
  },
  computed: {
    classes: function classes() {
      var _ref;

      return ["".concat(prefixCls$3), (_ref = {}, defineProperty$2(_ref, "".concat(prefixCls$3, "-bordered"), this.bordered), defineProperty$2(_ref, "is-inner_".concat(this.type), true), defineProperty$2(_ref, "is-shadow_".concat(this.shadow), true), _ref)];
    },
    cardStyles: function cardStyles() {
      return {
        borderRadius: "".concat(this.borderRadius, "px")
      };
    }
  }
};

/* script */
var __vue_script__$r = script$r;
/* template */

var __vue_render__$o = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes,
    style: _vm.cardStyles
  }, [_vm.$slots.title || _vm.title ? _c('div', {
    staticClass: "ui-card__header"
  }, [_vm._t("title", [_vm._v("\n      " + _vm._s(_vm.title) + "\n    ")]), _vm._v(" "), _vm.$slots.extra ? _c('div', {
    staticClass: "ui-card__header-extra"
  }, [_vm._t("extra")], 2) : _vm._e()], 2) : _vm._e(), _vm._v(" "), _vm.$slots.cover ? _c('div', {
    staticClass: "ui-card__cover"
  }, [_vm._t("cover")], 2) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "ui-card__body"
  }, [_vm._t("default")], 2)]);
};

var __vue_staticRenderFns__$o = [];
/* style */

var __vue_inject_styles__$r = undefined;
/* scoped */

var __vue_scope_id__$r = "data-v-1ea3fa8a";
/* module identifier */

var __vue_module_identifier__$r = undefined;
/* functional template */

var __vue_is_functional_template__$r = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$r = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$o,
  staticRenderFns: __vue_staticRenderFns__$o
}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

var script$q = {
  name: 'text-ellipsis',
  props: {
    content: {
      type: [String, Number, Object],
      default: ''
    },
    contentRows: {
      type: Number,
      default: 1
    }
  },
  data: function data() {
    return {
      height: 'auto',
      contentHeight: 'auto',
      tooltipContent: ''
    };
  },
  computed: {
    show: function show() {
      return window.parseInt(this.height) < this.contentHeight;
    }
  },
  render: function render(h) {
    return h('div', {
      class: 'text-ellipsis-container',
      style: {
        'max-height': this.height,
        '-webkit-line-clamp': this.contentRows
      }
    }, [h('el-tooltip', {
      props: {
        placement: 'top',
        content: "".concat(this.tooltipContent),
        disabled: !this.show
      }
    }, [h('div', [h('span', {
      class: 'mapper-content'
    }, [this.content])])])]);
  },
  mounted: function mounted() {
    this.computedEllipsis();
    window.addEventListener('resize', this.computedEllipsis);
  },
  watch: {
    content: function content() {
      this.computedEllipsis();
    }
  },
  methods: {
    computedEllipsis: function computedEllipsis() {
      var _this = this;

      this.$nextTick(function () {
        _this.tooltipContent = _typeof_1(_this.content) === 'object' ? _this.content.elm.innerText : _this.content;
        var el = _this.$el;
        var children = el.children[0].children[0];
        _this.height = "".concat(window.parseInt(window.getComputedStyle(el, null).lineHeight) * _this.contentRows, "px");
        _this.contentHeight = children.offsetHeight;
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('resize', this.computedEllipsis);
  }
};

/* script */
var __vue_script__$q = script$q;
/* template */

/* style */

var __vue_inject_styles__$q = undefined;
/* scoped */

var __vue_scope_id__$q = undefined;
/* module identifier */

var __vue_module_identifier__$q = undefined;
/* functional template */

var __vue_is_functional_template__$q = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$q = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

var script$p = {
  name: 'ui-data-mapper',
  componentName: 'UiDataMapper',
  components: {
    TextEllipsis: __vue_component__$q
  },
  props: {
    // æ°æ®
    data: {
      type: Object,
      default: function _default() {}
    },
    // è®¾ç½®å
    // [{
    //   prop: 'prop',
    //   label: 'label'
    // }]
    columns: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    // å ä½ç¬¦
    placeholder: {
      type: String,
      default: ''
    },
    contentRows: {
      type: Number,
      default: 1
    },
    // å­åç´ çæåæ¹å
    inline: {
      type: Boolean,
      default: true
    },
    labelWidth: {
      type: [String, Number],
      default: ''
    },
    labelPosition: {
      type: String,
      default: 'right'
    }
  },
  render: function render(h) {
    var contentRows = this.renderRow(h, this.columns);
    return h('div', {
      class: 'ui-data-mapper'
    }, [contentRows]);
  },
  methods: {
    // æ¸²æcontentRows
    renderRow: function renderRow(h, columns) {
      var cols = this.renderCol(h, columns);
      return h('div', {
        class: 'ui-grid'
      }, cols);
    },
    // æ¸²æå
    renderCol: function renderCol(h) {
      var _this = this;

      var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return columns.map(function (col, index) {
        // å¤çobject path
        var isPath = col.prop.indexOf('.') >= 0;
        var propData = isPath ? col.prop.split('.').reduce(function (pre, next) {
          return pre[next] || {};
        }, _this.data) : _this.data[col.prop]; // å¤çåå®¹

        _typeof_1(propData) === 'object' && (propData = _this.placeholder);
        var VALUE = col.formatter ? col.formatter(_this.data, col, index) : propData || _this.placeholder;
        var title = h('div', {
          class: ['ui-data-mapper-title', "ui-data-mapper-title-".concat(_this.labelPosition)],
          style: _this.labelWidth !== undefined ? {
            width: /^[0-9]$/.test(_this.labelWidth) ? _this.labelWidth + 'px' : _this.labelWidth
          } : {}
        }, [col.label && "".concat(col.label, "\uFF1A")]);
        return h('div', {
          class: {
            'ui-grid-cell': true,
            'col-8': _this.inline,
            'ui-data-mapper-col': _this.inline,
            'ui-data-mapper-col-vertical': !_this.inline,
            'ui-data-mapper-col-top': _this.labelPosition === 'top'
          },
          props: _this.inline ? {
            xs: 24,
            sm: 12,
            md: 12,
            lg: 8,
            xl: 8
          } : {}
        }, [title, _this.renderContent(h, VALUE)]);
      });
    },
    renderContent: function renderContent(h, content) {
      var textEllipsis = h('text-ellipsis', {
        props: {
          content: content,
          contentRows: this.contentRows
        }
      });
      return h('div', {
        class: 'ui-data-mapper-col-content'
      }, [textEllipsis]);
    }
  }
};

/* script */
var __vue_script__$p = script$p;
/* template */

/* style */

var __vue_inject_styles__$p = undefined;
/* scoped */

var __vue_scope_id__$p = "data-v-5d791192";
/* module identifier */

var __vue_module_identifier__$p = undefined;
/* functional template */

var __vue_is_functional_template__$p = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$p = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

var lastTime = 0;
var prefixes = 'webkit moz ms o'.split(' '); // åæµè§å¨åç¼

var requestAnimationFrame$1;
var cancelAnimationFrame$1;
var isServer$1 = typeof window === 'undefined';

if (isServer$1) {
  requestAnimationFrame$1 = function requestAnimationFrame() {
    return;
  };

  cancelAnimationFrame$1 = function cancelAnimationFrame() {
    return;
  };
} else {
  requestAnimationFrame$1 = window.requestAnimationFrame;
  cancelAnimationFrame$1 = window.cancelAnimationFrame;
  var prefix; // éè¿éååæµè§å¨åç¼ï¼æ¥å¾å°requestAnimationFrameåcancelAnimationFrameå¨å½åæµè§å¨çå®ç°å½¢å¼

  for (var i$1 = 0; i$1 < prefixes.length; i$1++) {
    if (requestAnimationFrame$1 && cancelAnimationFrame$1) {
      break;
    }

    prefix = prefixes[i$1];
    requestAnimationFrame$1 = requestAnimationFrame$1 || window[prefix + 'RequestAnimationFrame'];
    cancelAnimationFrame$1 = cancelAnimationFrame$1 || window[prefix + 'CancelAnimationFrame'] || window[prefix + 'CancelRequestAnimationFrame'];
  } // å¦æå½åæµè§å¨ä¸æ¯ærequestAnimationFrameåcancelAnimationFrameï¼åä¼éå°setTimeout


  if (!requestAnimationFrame$1 || !cancelAnimationFrame$1) {
    requestAnimationFrame$1 = function requestAnimationFrame(callback) {
      var currTime = new Date().getTime(); // ä¸ºäºä½¿setTimteoutçå°½å¯è½çæ¥è¿æ¯ç§60å¸§çææ

      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

    cancelAnimationFrame$1 = function cancelAnimationFrame(id) {
      window.clearTimeout(id);
    };
  }
}

var script$o = {
  name: 'ui-count-to',
  props: {
    startVal: {
      type: Number,
      required: false,
      default: 0
    },
    endVal: {
      type: Number,
      required: false,
      default: 2017
    },
    duration: {
      type: Number,
      required: false,
      default: 3000
    },
    autoplay: {
      type: Boolean,
      required: false,
      default: true
    },
    decimals: {
      type: Number,
      required: false,
      default: 0,
      validator: function validator(value) {
        return value >= 0;
      }
    },
    decimal: {
      type: String,
      required: false,
      default: '.'
    },
    separator: {
      type: String,
      required: false,
      default: ','
    },
    prefix: {
      type: String,
      required: false,
      default: ''
    },
    suffix: {
      type: String,
      required: false,
      default: ''
    },
    useEasing: {
      type: Boolean,
      required: false,
      default: true
    },
    easingFn: {
      type: Function,
      default: function _default(t, b, c, d) {
        return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
      }
    }
  },
  data: function data() {
    return {
      localStartVal: this.startVal,
      displayValue: this.formatNumber(this.startVal),
      printVal: null,
      paused: false,
      localDuration: this.duration,
      startTime: null,
      timestamp: null,
      remaining: null,
      rAF: null
    };
  },
  computed: {
    countDown: function countDown() {
      return this.startVal > this.endVal;
    }
  },
  watch: {
    startVal: function startVal() {
      if (this.autoplay) {
        this.start();
      }
    },
    endVal: function endVal() {
      if (this.autoplay) {
        this.start();
      }
    }
  },
  mounted: function mounted() {
    if (this.autoplay) {
      this.start();
    }

    this.$emit('mountedCallback');
  },
  methods: {
    start: function start() {
      this.localStartVal = this.startVal;
      this.startTime = null;
      this.localDuration = this.duration;
      this.paused = false;
      this.rAF = requestAnimationFrame$1(this.count);
    },
    pauseResume: function pauseResume() {
      if (this.paused) {
        this.resume();
        this.paused = false;
      } else {
        this.pause();
        this.paused = true;
      }
    },
    pause: function pause() {
      cancelAnimationFrame$1(this.rAF);
    },
    resume: function resume() {
      this.startTime = null;
      this.localDuration = +this.remaining;
      this.localStartVal = +this.printVal;
      requestAnimationFrame$1(this.count);
    },
    reset: function reset() {
      this.startTime = null;
      cancelAnimationFrame$1(this.rAF);
      this.displayValue = this.formatNumber(this.startVal);
    },
    count: function count(timestamp) {
      if (!this.startTime) this.startTime = timestamp;
      this.timestamp = timestamp;
      var progress = timestamp - this.startTime;
      this.remaining = this.localDuration - progress;

      if (this.useEasing) {
        if (this.countDown) {
          this.printVal = this.localStartVal - this.easingFn(progress, 0, this.localStartVal - this.endVal, this.localDuration);
        } else {
          this.printVal = this.easingFn(progress, this.localStartVal, this.endVal - this.localStartVal, this.localDuration);
        }
      } else {
        if (this.countDown) {
          this.printVal = this.localStartVal - (this.localStartVal - this.endVal) * (progress / this.localDuration);
        } else {
          this.printVal = this.localStartVal + (this.endVal - this.localStartVal) * (progress / this.localDuration);
        }
      }

      if (this.countDown) {
        this.printVal = this.printVal < this.endVal ? this.endVal : this.printVal;
      } else {
        this.printVal = this.printVal > this.endVal ? this.endVal : this.printVal;
      }

      this.displayValue = this.formatNumber(this.printVal);

      if (progress < this.localDuration) {
        this.rAF = requestAnimationFrame$1(this.count);
      } else {
        this.$emit('callback');
      }
    },
    isNumber: function isNumber(val) {
      return !isNaN(parseFloat(val));
    },
    formatNumber: function formatNumber(num) {
      num = num.toFixed(this.decimals);
      num += '';
      var x = num.split('.');
      var x1 = x[0];
      var x2 = x.length > 1 ? this.decimal + x[1] : '';
      var rgx = /(\d+)(\d{3})/;

      if (this.separator && !this.isNumber(this.separator)) {
        while (rgx.test(x1)) {
          x1 = x1.replace(rgx, '$1' + this.separator + '$2');
        }
      }

      return this.prefix + x1 + x2 + this.suffix;
    }
  },
  destroyed: function destroyed() {
    cancelAnimationFrame$1(this.rAF);
  }
};

/* script */
var __vue_script__$o = script$o;
/* template */

var __vue_render__$n = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', [_vm._v("\n  " + _vm._s(_vm.displayValue) + "\n")]);
};

var __vue_staticRenderFns__$n = [];
/* style */

var __vue_inject_styles__$o = undefined;
/* scoped */

var __vue_scope_id__$o = undefined;
/* module identifier */

var __vue_module_identifier__$o = undefined;
/* functional template */

var __vue_is_functional_template__$o = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$o = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$n,
  staticRenderFns: __vue_staticRenderFns__$n
}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

Vue.prototype.$isServer; // å¤æ­åæ°æ¯å¦æ¯å¶ä¸­ä¹ä¸

function oneOf(value, validList) {
  for (var i = 0; i < validList.length; i++) {
    if (value === validList[i]) {
      return true;
    }
  }

  return false;
}

var prefixCls$2 = 'ui-chart-circle';
var script$n = {
  name: 'ui-circle',
  props: {
    percent: {
      type: Number,
      default: 0
    },
    size: {
      type: Number,
      default: 120
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeColor: {
      type: String,
      default: '#2d8cf0'
    },
    strokeLinecap: {
      validator: function validator(value) {
        return oneOf(value, ['square', 'round']);
      },
      default: 'round'
    },
    trailWidth: {
      type: Number,
      default: 5
    },
    trailColor: {
      type: String,
      default: '#eaeef2'
    },
    dashboard: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    circleSize: function circleSize() {
      return {
        width: "".concat(this.size, "px"),
        height: "".concat(this.size, "px")
      };
    },
    computedStrokeWidth: function computedStrokeWidth() {
      return this.percent === 0 && this.dashboard ? 0 : this.strokeWidth;
    },
    radius: function radius() {
      return 50 - this.strokeWidth / 2;
    },
    pathString: function pathString() {
      if (this.dashboard) {
        return "M 50,50 m 0,".concat(this.radius, "\n                    a ").concat(this.radius, ",").concat(this.radius, " 0 1 1 0,-").concat(2 * this.radius, "\n                    a ").concat(this.radius, ",").concat(this.radius, " 0 1 1 0,").concat(2 * this.radius);
      } else {
        return "M 50,50 m 0,-".concat(this.radius, "\n                    a ").concat(this.radius, ",").concat(this.radius, " 0 1 1 0,").concat(2 * this.radius, "\n                    a ").concat(this.radius, ",").concat(this.radius, " 0 1 1 0,-").concat(2 * this.radius);
      }
    },
    len: function len() {
      return Math.PI * 2 * this.radius;
    },
    trailStyle: function trailStyle() {
      var style = {};

      if (this.dashboard) {
        style = {
          'stroke-dasharray': "".concat(this.len - 75, "px ").concat(this.len, "px"),
          'stroke-dashoffset': "-".concat(75 / 2, "px"),
          transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
        };
      }

      return style;
    },
    pathStyle: function pathStyle() {
      var style = {};

      if (this.dashboard) {
        style = {
          'stroke-dasharray': "".concat(this.percent / 100 * (this.len - 75), "px ").concat(this.len, "px"),
          'stroke-dashoffset': "-".concat(75 / 2, "px"),
          transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .6s ease 0s, stroke .6s, stroke-width .06s ease .6s'
        };
      } else {
        style = {
          'stroke-dasharray': "".concat(this.len, "px ").concat(this.len, "px"),
          'stroke-dashoffset': "".concat((100 - this.percent) / 100 * this.len, "px"),
          transition: 'stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease'
        };
      }

      return style;
    },
    wrapClasses: function wrapClasses() {
      return "".concat(prefixCls$2);
    },
    innerClasses: function innerClasses() {
      return "".concat(prefixCls$2, "-inner");
    }
  }
};

/* script */
var __vue_script__$n = script$n;
/* template */

var __vue_render__$m = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.wrapClasses,
    style: _vm.circleSize
  }, [_c('svg', {
    attrs: {
      "viewBox": "0 0 100 100"
    }
  }, [_c('path', {
    style: _vm.trailStyle,
    attrs: {
      "d": _vm.pathString,
      "stroke": _vm.trailColor,
      "stroke-width": _vm.trailWidth,
      "fill-opacity": 0
    }
  }), _vm._v(" "), _c('path', {
    style: _vm.pathStyle,
    attrs: {
      "d": _vm.pathString,
      "stroke-linecap": _vm.strokeLinecap,
      "stroke": _vm.strokeColor,
      "stroke-width": _vm.computedStrokeWidth,
      "fill-opacity": "0"
    }
  })]), _vm._v(" "), _c('div', {
    class: _vm.innerClasses
  }, [_vm._t("default")], 2)]);
};

var __vue_staticRenderFns__$m = [];
/* style */

var __vue_inject_styles__$n = undefined;
/* scoped */

var __vue_scope_id__$n = "data-v-e4571f7a";
/* module identifier */

var __vue_module_identifier__$n = undefined;
/* functional template */

var __vue_is_functional_template__$n = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$n = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$m,
  staticRenderFns: __vue_staticRenderFns__$m
}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

//
//
//
//
var prefixCls$1 = 'ui-breadcrumb';
var script$m = {
  name: 'ui-bread-crumb',
  props: {
    separator: {
      type: String,
      default: '/'
    }
  },
  computed: {
    classes: function classes() {
      return "".concat(prefixCls$1);
    }
  },
  mounted: function mounted() {
    this.updateChildren();
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      _this.updateChildren();
    });
  },
  methods: {
    updateChildren: function updateChildren() {
      var _this2 = this;

      this.$children.forEach(function (child) {
        child.separator = _this2.separator;
      });
    }
  },
  watch: {
    separator: function separator() {
      this.updateChildren();
    }
  }
};

/* script */
var __vue_script__$m = script$m;
/* template */

var __vue_render__$l = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$l = [];
/* style */

var __vue_inject_styles__$m = undefined;
/* scoped */

var __vue_scope_id__$m = "data-v-93561ade";
/* module identifier */

var __vue_module_identifier__$m = undefined;
/* functional template */

var __vue_is_functional_template__$m = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$m = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$l,
  staticRenderFns: __vue_staticRenderFns__$l
}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

var mixinsLink = {
  props: {
    to: {
      type: [Object, String]
    },
    replace: {
      type: Boolean,
      default: false
    },
    target: {
      type: String,
      validator: function validator(value) {
        return oneOf(value, ['_blank', '_self', '_parent', '_top']);
      },
      default: '_self'
    },
    append: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  computed: {
    linkUrl: function linkUrl() {
      var type = _typeof_1(this.to);

      if (type !== 'string') {
        return null;
      }

      if (this.to.includes('//')) {
        /* Absolute URL, we do not need to route this */
        return this.to;
      }

      var router = this.$router;

      if (router) {
        var current = this.$route;
        var route = router.resolve(this.to, current, this.append);
        return route ? route.href : this.to;
      }

      return this.to;
    }
  },
  methods: {
    handleClick: function handleClick() {
      var new_window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var router = this.$router;

      if (new_window) {
        var to = this.to;

        if (router) {
          var current = this.$route;
          var route = router.resolve(this.to, current, this.append);
          to = route ? route.href : this.to;
        }

        window.open(to);
      } else {
        if (router) {
          this.replace ? this.$router.replace(this.to, function () {}) : this.$router.push(this.to, function () {});
        } else {
          window.location.href = this.to;
        }
      }
    },
    handleCheckClick: function handleCheckClick(event) {
      var new_window = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.to) {
        if (this.target === '_blank') {
          return false;
        } else {
          event.preventDefault();
          this.handleClick(new_window);
        }
      }
    }
  }
};

//
var prefixCls = 'ui-breadcrumb-item';
var script$l = {
  name: 'ui-bread-crumb-item',
  mixins: [mixinsLink],
  data: function data() {
    return {
      separator: '',
      showSeparator: false
    };
  },
  computed: {
    linkClasses: function linkClasses() {
      return "".concat(prefixCls, "-link");
    },
    separatorClasses: function separatorClasses() {
      return "".concat(prefixCls, "-separator");
    }
  },
  mounted: function mounted() {
    this.showSeparator = this.$slots.separator !== undefined;
  }
};

/* script */
var __vue_script__$l = script$l;
/* template */

var __vue_render__$k = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', [_vm.to ? _c('a', {
    class: _vm.linkClasses,
    attrs: {
      "href": _vm.linkUrl,
      "target": _vm.target
    },
    on: {
      "click": [function ($event) {
        if ($event.ctrlKey || $event.shiftKey || $event.altKey || $event.metaKey) {
          return null;
        }

        return _vm.handleCheckClick($event, false);
      }, function ($event) {
        if (!$event.ctrlKey) {
          return null;
        }

        return _vm.handleCheckClick($event, true);
      }, function ($event) {
        if (!$event.metaKey) {
          return null;
        }

        return _vm.handleCheckClick($event, true);
      }]
    }
  }, [_vm._t("default")], 2) : _c('span', {
    class: _vm.linkClasses
  }, [_vm._t("default")], 2), _vm._v(" "), !_vm.showSeparator ? _c('span', {
    class: _vm.separatorClasses,
    domProps: {
      "innerHTML": _vm._s(_vm.separator)
    }
  }) : _c('span', {
    class: _vm.separatorClasses
  }, [_vm._t("separator")], 2)]);
};

var __vue_staticRenderFns__$k = [];
/* style */

var __vue_inject_styles__$l = undefined;
/* scoped */

var __vue_scope_id__$l = "data-v-971c993e";
/* module identifier */

var __vue_module_identifier__$l = undefined;
/* functional template */

var __vue_is_functional_template__$l = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$l = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$k,
  staticRenderFns: __vue_staticRenderFns__$k
}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

//
//
//
var script$k = {
  name: 'ui-water-mark',
  props: {
    //æ¾ç¤ºçæ°´å°ææ¬
    inputText: {
      type: String,
      default: '3kæ¸¸æ'
    },
    //æ¯å¦åè®¸éè¿jsæèå¼åèå·¥å·ç­éå¾ä¿®æ¹æ°´å°DOMèç¹ï¼æ°´å°çidï¼attributeå±æ§ï¼èç¹çå é¤ï¼
    //trueä¸ºåè®¸ï¼é»è®¤ä¸åè®¸
    inputAllowDele: {
      type: Boolean,
      default: false
    },
    //æ¯å¦å¨éæ¯ç»ä»¶æ¶å»é¤æ°´å°èç¹ï¼åææ¯åè®¸ç¨æ·ä¿®æ¹DOMï¼å¦åå»é¤åä¼åæ¬¡èªå¨çæï¼
    // trueä¼ï¼é»è®¤ä¸ä¼
    inputDestroy: {
      type: Boolean,
      default: false
    },
    //æ°´å°å­ä½é¢è²
    styleColor: {
      type: String,
      default: 'rgb(112, 113, 114, 0.1)'
    },
    fontSize: {
      type: String,
      default: '18'
    },
    width: {
      type: String,
      default: 150
    },
    height: {
      type: String,
      default: 100
    }
  },
  data: function data() {
    return {
      maskDiv: {} //å½åæ¾ç¤ºçæ°´å°divèç¹DOMå¯¹è±¡

    };
  },
  mounted: function mounted() {
    var _this = this;

    //ç¡®è®¤DOMæ¸²æååæ§è¡
    this.$nextTick(function () {
      //åå»ºæ°´å°èç¹
      _this.init();

      if (!_this.inputAllowDele) {
        // è®¾ç½®æ°´å°èç¹ä¿®æ¹çDOMäºä»¶
        _this.Monitor();
      }
    });
  },
  methods: {
    init: function init() {
      var canvas = document.createElement('canvas');
      canvas.id = 'canvas';
      canvas.width = this.width; //åä¸ªæ°´å°çå®½é«

      canvas.height = this.height;
      this.maskDiv = document.createElement('div');
      var ctx = canvas.getContext('2d');
      ctx.font = "normal ".concat(this.fontSize, "px Microsoft Yahei"); //è®¾ç½®æ ·å¼

      ctx.fillStyle = this.styleColor; //æ°´å°å­ä½é¢è²

      ctx.rotate(30 * Math.PI / 180); //æ°´å°åè½¬è§åº¦

      ctx.fillText(this.inputText, 30, 0);
      var src = canvas.toDataURL('image/png');
      this.maskDiv.style.position = 'fixed';
      this.maskDiv.style.zIndex = '9999';
      this.maskDiv.id = '_waterMark';
      this.maskDiv.style.top = '0px';
      this.maskDiv.style.left = '0';
      this.maskDiv.style.width = '100%';
      this.maskDiv.style.height = '100%';
      this.maskDiv.style.pointerEvents = 'none';
      this.maskDiv.style.backgroundImage = 'URL(' + src + ')'; // æ°´å°èç¹æå°bodyä¸

      document.body.appendChild(this.maskDiv);
    },
    Monitor: function Monitor() {
      var body = document.getElementsByTagName('body')[0];
      var options = {
        childList: true,
        attributes: true,
        characterData: true,
        subtree: true,
        attributeOldValue: true,
        characterDataOldValue: true
      };
      var observer = new MutationObserver(this.callback);
      observer.observe(body, options); //çå¬bodyèç¹
    },
    //DOMæ¹åæ§è¡callback
    callback: function callback(mutations, observer) {
      //å½attributeå±æ§è¢«ä¿®æ¹
      if (mutations[0].target.id === '_waterMark') {
        this.removeMaskDiv();
      } //å½idè¢«æ¹åæ¶


      if (mutations[0].attributeName === 'id') {
        this.removeMaskDiv();
        this.init();
      } //å½èç¹è¢«å é¤


      if (mutations[0].removedNodes[0] && mutations[0].removedNodes[0].id === '_waterMark') {
        this.init();
      }
    },

    /* public */
    //æå¨éæ¯æ°´å°DOM
    removeMaskDiv: function removeMaskDiv() {
      document.body.removeChild(this.maskDiv);
    },
    //æå¨çææ°´å°
    createMaskDiv: function createMaskDiv() {
      this.init();
    }
  },
  watch: {
    //çå¬ä¼ å¥æ°´å°ææ¬åå
    inputText: function inputText() {
      var _this2 = this;

      this.$nextTick(function () {
        _this2.removeMaskDiv();
      });
    }
  },
  destroy: function destroy() {
    //ç»ä»¶éæ¯æ¶å»é¤çæå¨bodyèç¹ä¸çæ°´å°èç¹
    if (this.inputDestroy) {
      this.removeMaskDiv();
    }
  }
};

/* script */
var __vue_script__$k = script$k;
/* template */

var __vue_render__$j = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div');
};

var __vue_staticRenderFns__$j = [];
/* style */

var __vue_inject_styles__$k = undefined;
/* scoped */

var __vue_scope_id__$k = undefined;
/* module identifier */

var __vue_module_identifier__$k = undefined;
/* functional template */

var __vue_is_functional_template__$k = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$k = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$j,
  staticRenderFns: __vue_staticRenderFns__$j
}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$j = {
  name: 'ui-back-top',
  props: {
    visibilityHeight: {
      type: Number,
      default: 400
    },
    backPosition: {
      type: Number,
      default: 0
    },
    customStyle: {
      type: Object,
      default: function _default() {
        return {
          right: '50px',
          bottom: '50px',
          width: '40px',
          height: '40px',
          'border-radius': '4px',
          'line-height': '45px',
          background: '#e7eaf1'
        };
      }
    },
    transitionName: {
      type: String,
      default: 'fade'
    }
  },
  data: function data() {
    return {
      visible: false,
      interval: null,
      isMoving: false
    };
  },
  mounted: function mounted() {
    window.addEventListener('scroll', this.handleScroll);
  },
  beforeDestroy: function beforeDestroy() {
    window.removeEventListener('scroll', this.handleScroll);

    if (this.interval) {
      clearInterval(this.interval);
    }
  },
  methods: {
    handleScroll: function handleScroll() {
      this.visible = window.pageYOffset > this.visibilityHeight;
    },
    backToTop: function backToTop() {
      var _this = this;

      if (this.isMoving) return;
      var start = window.pageYOffset;
      var i = 0;
      this.isMoving = true;
      this.interval = setInterval(function () {
        var next = Math.floor(_this.easeInOutQuad(10 * i, start, -start, 500));

        if (next <= _this.backPosition) {
          window.scrollTo(0, _this.backPosition);
          clearInterval(_this.interval);
          _this.isMoving = false;
        } else {
          window.scrollTo(0, next);
        }

        i++;
      }, 16.7);
    },
    easeInOutQuad: function easeInOutQuad(t, b, c, d) {
      if ((t /= d / 2) < 1) return c / 2 * t * t + b;
      return -c / 2 * (--t * (t - 2) - 1) + b;
    }
  }
};

/* script */
var __vue_script__$j = script$j;
/* template */

var __vue_render__$i = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": _vm.transitionName
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.visible,
      expression: "visible"
    }],
    staticClass: "back-to-ceiling",
    style: _vm.customStyle,
    on: {
      "click": _vm.backToTop
    }
  }, [_c('svg', {
    staticClass: "Icon Icon--backToTopArrow",
    staticStyle: {
      "height": "16px",
      "width": "16px"
    },
    attrs: {
      "width": "16",
      "height": "16",
      "viewBox": "0 0 17 17",
      "xmlns": "http://www.w3.org/2000/svg",
      "aria-hidden": "true"
    }
  }, [_c('path', {
    attrs: {
      "d": "M12.036 15.59a1 1 0 0 1-.997.995H5.032a.996.996 0 0 1-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z"
    }
  })])])]);
};

var __vue_staticRenderFns__$i = [];
/* style */

var __vue_inject_styles__$j = undefined;
/* scoped */

var __vue_scope_id__$j = "data-v-6ffeae9e";
/* module identifier */

var __vue_module_identifier__$j = undefined;
/* functional template */

var __vue_is_functional_template__$j = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$j = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$i,
  staticRenderFns: __vue_staticRenderFns__$i
}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

var script$i = {
  name: 'ui-count-down',
  props: {
    /**
     * remain days
     */
    days: {
      type: Number,
      default: 0
    },

    /**
     * remain hours
     */
    hours: {
      type: Number,
      default: 0
    },

    /**
     * remain minutes
     */
    minutes: {
      type: Number,
      default: 0
    },

    /**
     * remain seconds
     */
    seconds: {
      type: Number,
      default: 0
    },

    /**
     * remain milliseconds
     */
    milliseconds: {
      type: Number,
      default: 0
    },

    /**
     * whether autoplay or not
     */
    autoplay: {
      type: Boolean,
      default: true
    },

    /**
     * è¾åºæ ¼å¼ã
     * é»è®¤å¼ï¼'dd å¤© hh æ¶ mm å ss ç§'ãddãhhãmmãss å ms æ è¯ç¬¦é½æ¯å¯éçã
     * é»è®¤å¼ä¼æ ¹æ®æ¯å¦ä¼ å¥days, hours, minutes, seconds å millisecondsèååï¼
     * æ¯å¦ç¨æ·åªä¼ äºminutesï¼é£ä¹é»è®¤å¼å°±åä¸º'mm å ss ç§'
     */
    format: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    return {
      elapsed: 0,
      rafId: null
    };
  },
  computed: {
    time: function time() {
      return toMilliseconds(this);
    },
    formatComputed: function formatComputed() {
      if (this.format) return this.format;
      var formatDefault = ['dd å¤©', 'hh æ¶', 'mm å', 'ss ç§'];

      if (!this.days) {
        formatDefault.shift();

        if (!this.hours) {
          formatDefault.shift();
          if (!this.minutes) formatDefault.shift();
        }
      }

      return formatDefault.join(' ');
    },
    countdown: function countdown() {
      return Math.max(0, this.time - this.elapsed);
    },
    countdownFormated: function countdownFormated() {
      return formatTime(this.countdown, this.formatComputed);
    },
    countdownData: function countdownData() {
      return toTimeData(this.countdown);
    }
  },
  mounted: function mounted() {
    if (this.autoplay) this.start();
  },
  methods: {
    /**
     * å¼å§è®¡æ¶
     * @public
     */
    start: function start() {
      var _this = this;

      if (this.rafId) return;
      var last;

      var step = function step() {
        _this.rafId = requestAnimationFrame(function (timestamp) {
          if (last) _this.elapsed += Math.round(timestamp - last);
          last = timestamp;
          if (_this.countdown > 0) step();else {
            _this.rafId = null;
            /**
             * è®¡æ¶ç»æäºä»¶
             */

            _this.$emit('finish');
          }
        });
      };

      step();
    },

    /**
     * æåè®¡æ¶
     * @public
     */
    pause: function pause() {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    },

    /**
     * éç½®è®¡æ¶ï¼éè¦è°ç¨startæ¥åæ¬¡å¯å¨
     * @public
     */
    reset: function reset() {
      this.pause();
      this.elapsed = 0;
    }
  }
};

/* script */
var __vue_script__$i = script$i;
/* template */

var __vue_render__$h = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('span', [_vm._t("default", [_vm._v(_vm._s(_vm.countdownFormated))], null, _vm.countdownData)], 2);
};

var __vue_staticRenderFns__$h = [];
/* style */

var __vue_inject_styles__$i = undefined;
/* scoped */

var __vue_scope_id__$i = undefined;
/* module identifier */

var __vue_module_identifier__$i = undefined;
/* functional template */

var __vue_is_functional_template__$i = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$i = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$h,
  staticRenderFns: __vue_staticRenderFns__$h
}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$h = {
  name: 'ui-text-ellipsis',
  emits: ['textClick', 'hide', 'show'],
  props: {
    text: String,
    height: Number,
    width: Number,
    isLimitHeight: {
      type: Boolean,
      default: true
    },
    useTooltip: {
      type: Boolean,
      default: false
    },
    tooltipParams: {
      type: Object,
      default: function _default() {}
    },
    textStyle: [String, Object, Array],
    textClass: [String, Object, Array],
    more: String
  },
  data: function data() {
    return {
      keyIndex: 0,
      isHide: false
    };
  },
  watch: {
    isLimitHeight: function isLimitHeight() {
      this.init();
    },
    text: function text() {
      this.init();
    },
    height: function height() {
      this.init();
    },
    width: function width() {
      this.init();
    }
  },
  mounted: function mounted() {
    this.init();
  },
  methods: {
    init: function init() {
      this.keyIndex += 1;
      var more = this.$el.querySelector('.h-text-ellipsis-more');
      var text = this.$refs.textBox;
      more.style.display = 'none';
      text.style.width = this.width + 'px';

      if (this.isLimitHeight) {
        this.limitShow();
      } else {
        this.$emit('show');
        this.isHide = false;
      }
    },
    textClick: function textClick() {
      this.$emit('textClick');
    },
    limitShow: function limitShow() {
      var _this = this;

      this.$nextTick(function () {
        var textDom = _this.$el.querySelector('.h-text-ellipsis-limit-text');

        var title = _this.$el;

        var more = _this.$el.querySelector('.h-text-ellipsis-more');

        var n = 1000;

        if (textDom) {
          if (title.offsetHeight > _this.height) {
            more.style.display = 'inline-block';
            var text = _this.text;

            while (title.offsetHeight > _this.height && n > 0) {
              if (title.offsetHeight > _this.height * 3) {
                textDom.innerText = text = text.substring(0, Math.floor(text.length / 2));
              } else {
                textDom.innerText = text = text.substring(0, text.length - 1);
              }

              n--;
            }

            _this.$emit('hide');

            _this.isHide = true;
          } else {
            _this.$emit('show');

            _this.isHide = false;
          }
        }
      });
    }
  }
};

/* script */
var __vue_script__$h = script$h;
/* template */

var __vue_render__$g = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    ref: "textBox",
    staticClass: "h-text-ellipsis"
  }, [_vm._t("before"), _c('span', {
    directives: [{
      name: "tooltip",
      rawName: "v-tooltip",
      value: _vm.useTooltip && _vm.isHide ? _vm.tooltipParams : {},
      expression: "useTooltip && isHide ? tooltipParams : {}"
    }],
    class: _vm.textClass,
    style: _vm.textStyle,
    on: {
      "click": _vm.textClick
    }
  }, [_c('span', {
    key: _vm.keyIndex,
    staticClass: "h-text-ellipsis-limit-text"
  }, [_vm._v(_vm._s(_vm.text))]), _c('span', {
    staticClass: "h-text-ellipsis-more"
  }, [_vm._v(_vm._s(_vm.more)), _vm._t("more")], 2)]), _vm._t("after")], 2);
};

var __vue_staticRenderFns__$g = [];
/* style */

var __vue_inject_styles__$h = undefined;
/* scoped */

var __vue_scope_id__$h = "data-v-12abcbbb";
/* module identifier */

var __vue_module_identifier__$h = undefined;
/* functional template */

var __vue_is_functional_template__$h = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$h = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$g,
  staticRenderFns: __vue_staticRenderFns__$g
}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

var bind = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return toString.call(val) === '[object FormData]';
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return toString.call(val) === '[object URLSearchParams]';
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

var utils = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
var buildURL = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

var InterceptorManager_1 = InterceptorManager;

var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
var enhanceError = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};

var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
transitional.silentJSONParsing;
transitional.forcedJSONParsing;
transitional.clarifyTimeoutError;

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
var createError = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
var settle = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

var cookies = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
var isAbsoluteURL = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
var combineURLs = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
var buildFullPath = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

var isURLSameOrigin = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

var Cancel_1 = Cancel;

var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional$1 = config.transitional || transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional$1.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel_1('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = xhr;
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = xhr;
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitional,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

var defaults_1 = defaults;

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
var transformData = function transformData(data, headers, fns) {
  var context = this || defaults_1;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

var isCancel = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel_1('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
var dispatchRequest = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults_1.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
var mergeConfig = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

var data = {
  "version": "0.26.1"
};

var VERSION = data.version;

var validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

var validator = {
  assertOptions: assertOptions,
  validators: validators$1
};

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager_1(),
    response: new InterceptorManager_1()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

var Axios_1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel_1(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

var CancelToken_1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
var spread = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
var isAxiosError = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios_1(defaultConfig);
  var instance = bind(Axios_1.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios_1.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios$1 = createInstance(defaults_1);

// Expose Axios class to allow class inheritance
axios$1.Axios = Axios_1;

// Expose Cancel & CancelToken
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel;
axios$1.VERSION = data.version;

// Expose all/spread
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;

// Expose isAxiosError
axios$1.isAxiosError = isAxiosError;

var axios_1 = axios$1;

// Allow use of default import syntax in TypeScript
var _default = axios$1;
axios_1.default = _default;

var axios = axios_1;

function saveObjArr(name, data) {
  // localStorage å­å¨æ°ç»å¯¹è±¡çæ¹æ³
  localStorage.setItem(name, JSON.stringify(data));
}
function getObjArr(name) {
  // localStorage è·åæ°ç»å¯¹è±¡çæ¹æ³
  var res = window.localStorage.getItem(name);

  if (res && res !== 'undefined') {
    return JSON.parse(res);
  }

  return false;
}
function clearLocalStorage(name) {
  localStorage.removeItem(name);
}

var instance$6 = axios.create({});
var CHUNK_SIZE = 3 * 1024 * 1024; //åçå¤§å°

var fileIndex = 0; //å½åæ­£å¨è¢«éåçæä»¶ä¸æ 
// æææä»¶ç¶æ

var Status = {
  wait: 'wait',
  pause: 'pause',
  uploading: 'uploading',
  hash: 'hash',
  error: 'error',
  done: 'done',
  merge: 'merge'
}; // åä¸ªæä»¶çç¶æ

var _fileStatus = {
  wait: 'wait',
  uploading: 'uploading',
  success: 'success',
  error: 'error',
  secondPass: 'secondPass',
  pause: 'pause',
  resume: 'resume',
  merge: 'merge'
}; // åä¸ªæä»¶çç¶æ å¯¹åºæè¿°

var fileStatusStr = {
  wait: 'å¾ä¸ä¼ ',
  uploading: 'ä¸ä¼ ä¸­',
  success: 'æå',
  error: 'å¤±è´¥',
  secondPass: 'å·²ç§ä¼ ',
  pause: 'æå',
  resume: 'æ¢å¤',
  merge: 'åå¹¶åçä¸­'
};
var script$g = {
  name: 'ui-chunk-upload',
  components: {
    UiIcon: __vue_component__$1B,
    UiButton: __vue_component__$1v
  },
  props: {
    //æ¯å¦ä¸ºå¤éæ¨¡å¼
    multiple: {
      type: Boolean,
      default: true
    },
    //æ¥åä¸ä¼ çæä»¶ç±»å
    accept: {
      type: String,
      default: ''
    },
    //æå¤§åè®¸ä¸ä¼ ä¸ªæ°,é»è®¤0ï¼ä¸éå¶
    limit: {
      type: Number,
      default: 0
    },
    //åä¸ªåççå¤§å°
    chunkSize: {
      type: Number,
      default: CHUNK_SIZE
    },
    // ä¸ä¼ å¹¶åæ°
    threads: {
      type: Number,
      default: 3
    },
    // éè¯¯éè¯æ¬¡æ°
    chunkRetry: {
      type: Number,
      default: 3
    },
    // axios baseUrl
    baseUrl: {
      type: String,
      default: 'http://resource-admin-center-kf.3kwan.com/pack/ajax/upload'
    },
    // æä»¶è¶åºä¸ªæ°éå¶æ¶çé©å­
    onExceed: {
      type: Function,
      default: function _default() {}
    },
    //ä¸ä¼ æä»¶åçé©å­ï¼è¿åfalseååæ­¢ä¸ä¼ 
    beforeUpload: {
      type: Function,
      default: null
    },
    //éä¼ å­æ®µï¼å¨æååè°ä¸­è¿å
    ext: {
      type: String,
      default: ''
    }
  },
  data: function data() {
    return {
      uploadFiles: [],
      //å¾ä¸ä¼ çæä»¶éå
      panelShow: false,
      //éæ©æä»¶åï¼å±ç¤ºä¸ä¼ panel
      collapse: false,
      //æä»¶åè¡¨æå æ å¿
      status: Status.wait,
      //é»è®¤ç¶æï¼ç­å¾ï¼
      worker: null,
      cancels: [],
      // å­å¨è¦åæ¶çè¯·æ±
      tempThreads: 3,
      timer: null,
      filesNum: 0,
      filesTotal: 0
    };
  },
  filters: {
    transformByte: function transformByte(size) {
      if (!size) {
        return '0B';
      }

      var num = 1024.0; // byte

      if (size < num) {
        return size + 'B';
      }

      if (size < Math.pow(num, 2)) {
        return (size / num).toFixed(2) + 'K';
      } // kb


      if (size < Math.pow(num, 3)) {
        return (size / Math.pow(num, 2)).toFixed(2) + 'M';
      } // M


      if (size < Math.pow(num, 4)) {
        return (size / Math.pow(num, 3)).toFixed(2) + 'G';
      } // G


      return (size / Math.pow(num, 4)).toFixed(2) + 'T'; // T
    },
    // åä¸ªæä»¶ç¶ææ ¼å¼å
    fileStatus: function fileStatus(status) {
      return fileStatusStr[_fileStatus[status]];
    }
  },
  computed: {
    changeDisabled: function changeDisabled() {
      return ![Status.wait, Status.done].includes(this.status);
    }
  },
  created: function created() {
    this.setAxios();
    this.tempThreads = this.threads;
  },
  destroyed: function destroyed() {
    this.clearFiles();
  },
  methods: {
    //æåæä»¶ä¸ä¼ 
    onClickFile: function onClickFile() {
      this.$refs.inp.click();
    },
    //å³é­å±ç¤ºä¸ä¼ panel
    closePanel: function closePanel() {
      this.panelShow = false;
      this.clearFiles();
    },
    //æä»¶åè¡¨æå 
    fileListShow: function fileListShow() {
      var fileList = this.$refs.fileList;
      var height = fileList.offsetHeight;
      var fileListH = 360;

      if (height === fileListH) {
        fileList.style.height = '0px';
        this.collapse = true;
      } else {
        fileList.style.height = fileListH + 'px';
        this.collapse = false;
      }
    },
    //å¤çæä»¶ä¸ä¼ 
    handleFileChange: function handleFileChange(e) {
      var _this = this;

      var files = e.target.files;
      if (!files) return;
      fileIndex = 0; // éç½®æä»¶ä¸æ 
      //å¤æ­æä»¶éæ©çä¸ªæ°

      if (this.limit && files.length > this.limit) {
        this.onExceed && this.onExceed(files);
        return;
      }

      this.status = Status.wait;
      this.panelShow = true;
      this.filesNum = 0;
      var postFiles = Array.prototype.slice.call(files);
      this.filesTotal = postFiles.length;
      postFiles.forEach(function (item) {
        _this.handleStart(item);
      });
    },
    //åå§å
    handleStart: function handleStart(rawFile) {
      var _this2 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var bool;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                //åå§åé¨åèªå®ä¹å±æ§
                rawFile.status = _fileStatus.wait;
                rawFile.chunkList = []; //åçåè¡¨

                rawFile.uploadProgress = 0;
                rawFile.fakeUploadProgress = 0; // åè¿åº¦æ¡ï¼å¤çæ¢å¤ä¸ä¼ åï¼è¿åº¦æ¡åç§»çé®é¢

                rawFile.hashProgress = 0; //hashæ£éªè¿åº¦

                if (!_this2.beforeUpload) {
                  _context.next = 11;
                  break;
                }

                _context.next = 8;
                return new Promise(function (res) {
                  if (typeof _this2.beforeUpload === 'function') {
                    _this2.beforeUpload(rawFile, function (bool, paths) {
                      rawFile = paths || rawFile;
                      res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 8:
                bool = _context.sent;

                if (bool) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return");

              case 11:
                _this2.uploadFiles.push(rawFile);

                _this2.filesNum++;

                if (_this2.filesNum === _this2.filesTotal) {
                  _this2.handleUpload();
                }

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    //å¤çä¸ä¼ 
    handleUpload: function handleUpload() {
      var _this3 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var filesArr, _loop, i, _ret;

        return regenerator.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (_this3.uploadFiles) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                _this3.status = Status.uploading;
                filesArr = _this3.uploadFiles; //éåéè¦ä¸ä¼ çæä»¶

                _loop = /*#__PURE__*/regenerator.mark(function _loop(i) {
                  var fileChunkList, verifyRes, getChunkStorage;
                  return regenerator.wrap(function _loop$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          fileIndex = i;

                          if (!['secondPass', 'success', 'error'].includes(filesArr[i].status)) {
                            _context2.next = 4;
                            break;
                          }
                          return _context2.abrupt("return", "continue");

                        case 4:
                          fileChunkList = _this3.createFileChunk(filesArr[i]); //è¥ä¸æ¯æ¢å¤ç¶æï¼åè¿è¡hashè®¡ç®

                          if (!(filesArr[i].status !== 'resume')) {
                            _context2.next = 13;
                            break;
                          }

                          //è¿è¡hashè®¡ç®
                          _this3.status = Status.hash; //çææä»¶hash

                          _context2.next = 9;
                          return _this3.calculateHash(fileChunkList);

                        case 9:
                          filesArr[i].hash = _context2.sent;

                          if (!(_this3.status === Status.wait)) {
                            _context2.next = 13;
                            break;
                          }
                          return _context2.abrupt("return", "break");

                        case 13:
                          _this3.status = Status.uploading; // æä»¶ä¸ä¼ ä¹åçæ ¡éªï¼ æ ¡éªæä»¶æ¯å¦å·²å­å¨

                          _context2.next = 16;
                          return _this3.verifyUpload(filesArr[i].name, filesArr[i].hash);

                        case 16:
                          verifyRes = _context2.sent;

                          if (!verifyRes.data.file_exists) {
                            _context2.next = 25;
                            break;
                          }

                          filesArr[i].status = _fileStatus.secondPass;
                          filesArr[i].uploadProgress = 100;
                          _this3.status = Status.done;

                          _this3.$emit('success', filesArr[i].name);

                          _this3.$set(filesArr, i, filesArr[i]);

                          _context2.next = 35;
                          break;

                        case 25:
                          filesArr[i].status = _fileStatus.uploading;
                          getChunkStorage = _this3.getChunkStorage(filesArr[i].hash);
                          filesArr[i].fileHash = filesArr[i].hash; // æä»¶çhashï¼åå¹¶æ¶ä½¿ç¨

                          filesArr[i].chunkList = fileChunkList.map(function (_ref, index) {
                            var file = _ref.file;
                            return {
                              fileHash: filesArr[i].hash,
                              fileName: filesArr[i].name,
                              index: index,
                              hash: filesArr[i].hash + '-' + index,
                              chunk: file,
                              size: file.size,
                              uploaded: getChunkStorage && getChunkStorage.includes(index),
                              // æ è¯ï¼æ¯å¦å·²å®æä¸ä¼ 
                              progress: getChunkStorage && getChunkStorage.includes(index) ? 100 : 0,
                              status: getChunkStorage && getChunkStorage.includes(index) ? 'success' : 'wait' // ä¸ä¼ ç¶æï¼ç¨ä½è¿åº¦ç¶ææ¾ç¤º

                            };
                          });

                          _this3.$set(filesArr, i, filesArr[i]);
                          _context2.next = 35;
                          return _this3.uploadChunks(filesArr[i]);

                        case 35:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _loop);
                });
                i = 0;

              case 6:
                if (!(i < filesArr.length)) {
                  _context3.next = 16;
                  break;
                }

                return _context3.delegateYield(_loop(i), "t0", 8);

              case 8:
                _ret = _context3.t0;

                if (!(_ret === "continue")) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("continue", 13);

              case 11:
                if (!(_ret === "break")) {
                  _context3.next = 13;
                  break;
                }

                return _context3.abrupt("break", 16);

              case 13:
                i++;
                _context3.next = 6;
                break;

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2);
      }))();
    },
    // æä»¶ä¸ä¼ ä¹åçæ ¡éªï¼ æ ¡éªæä»¶æ¯å¦å·²å­å¨
    verifyUpload: function verifyUpload(fileName, fileHash) {
      return new Promise(function (resolve) {
        var obj = {
          opt: 'getChunkInfo',
          name: fileName,
          file_md5: fileHash
        };
        instance$6.post('', obj).then(function (res) {
          resolve(res.data);
        }).catch(function (err) {
        });
      });
    },
    //åå»ºæä»¶åç
    createFileChunk: function createFileChunk(file) {
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.chunkSize;
      var fileChunkList = [];
      var count = 0;

      while (count < file.size) {
        fileChunkList.push({
          file: file.slice(count, count + size)
        });
        count += size;
      }

      return fileChunkList;
    },
    //çææä»¶hash(web-worker)
    calculateHash: function calculateHash(fileChunkList) {
      var _this4 = this;

      return new Promise(function (resolve) {
        var url = '';

        if (/8088/.test(location.origin)) {
          url = '/fonts/hash.js';
        } else if (/web-test/.test(location.origin)) {
          url = '/nui/lib/fonts/hash.js';
        } else {
          url = '/static/nui/lib/fonts/hash.js';
        }

        _this4.worker = new Worker(url);

        _this4.worker.postMessage({
          fileChunkList: fileChunkList
        });

        _this4.worker.onmessage = function (e) {
          var _e$data = e.data,
              percentage = _e$data.percentage,
              hash = _e$data.hash;

          if (_this4.uploadFiles[fileIndex]) {
            _this4.uploadFiles[fileIndex].hashProgress = Number(percentage.toFixed(0));

            _this4.$set(_this4.uploadFiles, fileIndex, _this4.uploadFiles[fileIndex]);
          }

          if (hash) {
            resolve(hash);
          }
        };
      });
    },
    //å°åçä¸ä¼ ç»æå¡ç«¯
    uploadChunks: function uploadChunks(data) {
      var _this5 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
        var chunkData;
        return regenerator.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                chunkData = data.chunkList;
                return _context5.abrupt("return", new Promise( /*#__PURE__*/function () {
                  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(resolve, reject) {
                    var requestDataList, isUpload;
                    return regenerator.wrap(function _callee3$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            requestDataList = chunkData.filter(function (_ref3) {
                              var uploaded = _ref3.uploaded;
                              return !uploaded;
                            }).map(function (_ref4) {
                              var fileHash = _ref4.fileHash,
                                  chunk = _ref4.chunk,
                                  fileName = _ref4.fileName,
                                  index = _ref4.index;
                              var type = fileName.split('.')[1];
                              var formData = new FormData();
                              formData.append('opt', 'upload');
                              formData.append('name', fileName);
                              formData.append('file_md5', fileHash);
                              formData.append('type', type);
                              formData.append('size', chunk.size);
                              formData.append('chunkFile', chunk);
                              formData.append('chunk', index);
                              formData.append('chunks', chunkData.length);
                              return {
                                formData: formData,
                                index: index,
                                fileName: fileName
                              };
                            });
                            _context4.prev = 1;
                            _context4.next = 4;
                            return _this5.sendRequest(requestDataList, chunkData);

                          case 4:
                            _context4.next = 13;
                            break;

                          case 9:
                            _context4.prev = 9;
                            _context4.t0 = _context4["catch"](1);

                            // ä¸ä¼ æè¢«rejectç
                            _this5.$toast.error('äº² ä¸ä¼ å¤±è´¥äº,èèéè¯ä¸å¦' + _context4.t0);

                            return _context4.abrupt("return");

                          case 13:
                            // åå¹¶åç
                            isUpload = chunkData.some(function (item) {
                              return item.uploaded === false;
                            });

                            if (!isUpload) {
                              _context4.next = 19;
                              break;
                            }

                            _this5.$toast.error('å­å¨å¤±è´¥çåç');

                            _context4.next = 28;
                            break;

                          case 19:
                            _context4.prev = 19;
                            _context4.next = 22;
                            return _this5.mergeRequest(data);

                          case 22:
                            resolve();
                            _context4.next = 28;
                            break;

                          case 25:
                            _context4.prev = 25;
                            _context4.t1 = _context4["catch"](19);
                            reject();

                          case 28:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee3, null, [[1, 9], [19, 25]]);
                  }));

                  return function (_x, _x2) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4);
      }))();
    },
    //å¹¶åä¸ä¼ åç
    sendRequest: function sendRequest(forms, chunkData) {
      var _this6 = this;
      var finished = 0;
      var total = forms.length;
      var that = this;
      var retryArr = []; // æ°ç»å­å¨æ¯ä¸ªæä»¶hashè¯·æ±çéè¯æ¬¡æ°ï¼åç´¯å  æ¯å¦[1,0,2],å°±æ¯ç¬¬0ä¸ªæä»¶åçæ¥é1æ¬¡ï¼ç¬¬2ä¸ªæ¥é2æ¬¡

      return new Promise(function (resolve, reject) {
        var handler = function handler() {
          if (_this6.tempThreads > _this6.threads) return;

          if (forms.length) {
            // åºæ 
            var formInfo = forms.shift();
            var formData = formInfo.formData;
            var index = formInfo.index;
            instance$6.post('', formData, {
              onUploadProgress: that.createProgresshandler(chunkData[index]),
              cancelToken: new axios.CancelToken(function (c) {
                return _this6.cancels.push(c);
              })
            }).then(function (res) {
              // æ´æ¹ç¶æ
              chunkData[index].uploaded = true;
              chunkData[index].status = 'success'; // å­å¨å·²ä¸ä¼ çåçä¸æ 

              _this6.addChunkStorage(chunkData[index].fileHash, index);

              finished++;
              handler();
            }).catch(function (e) {
              // è¥ç¶æä¸ºæåæç­å¾ï¼åç¦æ­¢éè¯
              if ([Status.pause, Status.wait].includes(_this6.status)) return;

              if (typeof retryArr[index] !== 'number') {
                retryArr[index] = 0;
              } // æ´æ°ç¶æ


              chunkData[index].status = 'warning'; // ç´¯å éè¯¯æ¬¡æ°

              retryArr[index]++; // éè¯3æ¬¡

              if (retryArr[index] >= _this6.chunkRetry) {
                console.warn(' éè¯å¤±è´¥--- > handler -> retryArr', retryArr, chunkData[index].hash);
                return reject('éè¯å¤±è´¥', retryArr);
              }
              _this6.tempThreads++; // éæ¾å½åå ç¨çéé
              // å°å¤±è´¥çéæ°å å¥éå

              forms.push(formInfo);
              handler();
            });
          }

          if (finished >= total) {
            resolve('done');
          }
        }; // æ§å¶å¹¶å


        for (var i = 0; i < _this6.tempThreads; i++) {
          handler();
        }
      });
    },
    // éç¥æå¡ç«¯åå¹¶åç
    mergeRequest: function mergeRequest(data) {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        var obj = {
          opt: 'mergeChunks',
          name: data.name,
          file_md5: data.hash
        };
        instance$6.post('', obj).then( /*#__PURE__*/function () {
          var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(res) {
            return regenerator.wrap(function _callee5$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (!(res.data.code === 0)) {
                      _context6.next = 9;
                      break;
                    }
                    data.status = _fileStatus.merge;
                    _this7.status = Status.merge;
                    _context6.next = 6;
                    return _this7.checkMergeStatus(data);

                  case 6:
                    resolve();
                    _context6.next = 13;
                    break;

                  case 9:
                    // æä»¶åæ°éä¸å¯¹ï¼æ¸é¤ç¼å­
                    clearLocalStorage(data.hash);
                    data.status = _fileStatus.error;
                    _this7.status = Status.wait;
                    resolve();

                  case 13:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee5);
          }));

          return function (_x3) {
            return _ref5.apply(this, arguments);
          };
        }()).catch(function (err) {
          data.status = _fileStatus.error;
          _this7.status = Status.error;
          reject();
        });
      });
    },
    //æ¥è¯¢åå¹¶ç¶æ
    checkMergeStatus: function checkMergeStatus(data) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        var obj = {
          opt: 'getMergeStatus',
          name: data.name,
          file_md5: data.hash
        };
        instance$6.post('', obj).then(function (res) {
          if (res.data.code == 0 && res.data.data.mergeStatus == true) {
            clearLocalStorage(data.hash);
            data.status = _fileStatus.success;
            _this8.status = Status.done;
            clearInterval(_this8.timer);

            _this8.$emit('success', data.name, res.data.data.file, _this8.ext);

            resolve();
          } else {
            if (_this8.timer != null) {
              clearInterval(_this8.timer);
            }

            _this8.timer = setInterval( /*#__PURE__*/asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
              return regenerator.wrap(function _callee6$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      clearInterval(_this8.timer);
                      _context7.next = 3;
                      return _this8.checkMergeStatus(data);

                    case 3:
                      resolve();

                    case 4:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee6);
            })), 1000);
          }
        }).catch(function (err) {
          _this8.status = Status.error;
          clearInterval(_this8.timer);
          reject();
        });
      });
    },
    //å¤æ­æä»¶ç±»å«
    fileCategory: function fileCategory(param) {
      var ext = param.split('.')[1];
      var type = '';
      var typeMap = {
        image: ['gif', 'jpg', 'jpeg', 'png', 'bmp', 'webp'],
        video: ['mp4', 'm3u8', 'rmvb', 'avi', 'swf', '3gp', 'mkv', 'flv'],
        text: ['doc', 'txt', 'docx', 'pages', 'epub', 'pdf', 'numbers', 'csv', 'xls', 'xlsx', 'keynote', 'ppt', 'pptx'],
        package: ['zip', 'rar', 'arj', 'z']
      };
      Object.keys(typeMap).forEach(function (_type) {
        var extensions = typeMap[_type];

        if (extensions.indexOf(ext) > -1) {
          type = _type;
        }
      });
      return type;
    },
    // åçä¸ä¼ è¿åº¦
    createProgresshandler: function createProgresshandler(item) {
      var _this9 = this;
      return function (p) {
        item.progress = parseInt(String(p.loaded / p.total * 100));

        _this9.fileProgress();
      };
    },
    // æä»¶æ»è¿åº¦
    fileProgress: function fileProgress() {
      var currentFile = this.uploadFiles[fileIndex];

      if (currentFile && currentFile.chunkList.length > 0) {
        var uploadProgress = currentFile.chunkList.map(function (item) {
          return item.size * item.progress;
        }).reduce(function (acc, cur) {
          return acc + cur;
        });
        var currentFileProgress = parseInt((uploadProgress / currentFile.size).toFixed(2)); // çåè¿åº¦æ¡å¤ç--å¤çè¿åº¦æ¡åç§»

        if (!currentFile.fakeUploadProgress) {
          currentFile.uploadProgress = currentFileProgress;
          this.$set(this.uploadFiles, fileIndex, currentFile);
        } else if (currentFileProgress > currentFile.fakeUploadProgress) {
          currentFile.uploadProgress = currentFileProgress;
          this.$set(this.uploadFiles, fileIndex, currentFile);
        }
      }
    },
    // æ¸ç©ºæä»¶
    clearFiles: function clearFiles() {
      fileIndex = 0;
      this.handlePause();
      this.worker && this.worker.terminate(); // ä¸­æ­worker

      this.status = Status.wait;
      Object.assign(this.$data, this.$options.data()); // éç½®dataæææ°æ®
    },
    // å¤æ­æ¯å¦é½å·²å®æä¸ä¼ 
    isAllStatus: function isAllStatus() {
      var isAllSuccess = this.uploadFiles.every(function (item) {
        return ['success', 'secondPass', 'error'].includes(item.status);
      });

      if (isAllSuccess) {
        this.status = Status.done;
        this.$emit('success');
      }
    },
    //è®¾ç½®axiosåæ°
    setAxios: function setAxios() {
      //è®¾ç½®baseUrl
      instance$6.defaults.baseURL = this.baseUrl;
    },
    // å­å¨å·²ä¸ä¼ å®æçåçä¸æ 
    addChunkStorage: function addChunkStorage(name, index) {
      var data = [index];
      var arr = getObjArr(name);

      if (arr) {
        saveObjArr(name, [].concat(toConsumableArray(arr), data));
      } else {
        saveObjArr(name, data);
      }
    },
    // è·åå·²ä¸ä¼ å®æçåçä¸æ 
    getChunkStorage: function getChunkStorage(name) {
      return getObjArr(name);
    },
    // æåä¸ä¼ 
    handlePause: function handlePause() {
      this.status = Status.pause;

      if (this.uploadFiles.length) {
        var currentFile = this.uploadFiles[fileIndex];
        currentFile.status = _fileStatus.pause; // å°å½åè¿åº¦èµå¼ç»åè¿åº¦æ¡

        currentFile.fakeUploadProgress = currentFile.uploadProgress;
      }

      while (this.cancels.length > 0) {
        this.cancels.pop()('åæ¶è¯·æ±');
      }
    }
  }
};

/* script */
var __vue_script__$g = script$g;
/* template */

var __vue_render__$f = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-chunk-upload"
  }, [!_vm.changeDisabled ? _c('input', {
    ref: "inp",
    staticClass: "ui-chunk-upload_input",
    attrs: {
      "type": "file",
      "multiple": _vm.multiple,
      "accept": _vm.accept,
      "Î¿nclick": "f.outerHTML=f.outerHTML"
    },
    on: {
      "change": _vm.handleFileChange
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "btn-file_slot",
    on: {
      "click": _vm.onClickFile
    }
  }, [_vm._t("default", [_c('ui-button', {
    attrs: {
      "color": "primary",
      "disabled": _vm.changeDisabled
    }
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "xmlns": "http://www.w3.org/2000/svg",
      "width": "24",
      "height": "24",
      "viewBox": "0 0 24 24"
    }
  }, [_c('path', {
    attrs: {
      "d": "M5.016 18h13.969v2.016H5.016V18zM9 15.984v-6H5.016L12 3l6.984 6.984H15v6H9z"
    }
  })])]), _vm._v("éæ©æä»¶")], 1)])], 2), _vm._v(" "), _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.panelShow,
      expression: "panelShow"
    }],
    staticClass: "file-panel"
  }, [_c('h2', [_vm._v("\n      æä»¶åè¡¨\n      "), _c('div', {
    staticClass: "btn-group"
  }, [_c('a', {
    attrs: {
      "title": _vm.collapse ? 'å±å¼' : 'æå '
    },
    on: {
      "click": _vm.fileListShow
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": _vm.collapse ? 'add' : 'remove'
    }
  })], 1), _vm._v(" "), _c('a', {
    attrs: {
      "title": "å³é­"
    },
    on: {
      "click": _vm.closePanel
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "close"
    }
  })], 1)])]), _vm._v(" "), _c('div', {
    ref: "fileList",
    staticClass: "file-list"
  }, [_vm._l(_vm.uploadFiles, function (file, idx) {
    return _c('ul', {
      key: idx,
      staticClass: "file-item",
      class: "file-" + file.id
    }, [_c('li', {
      staticClass: "file-type",
      attrs: {
        "icon": _vm.fileCategory(file.name)
      }
    }), _vm._v(" "), _c('li', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip.top",
        value: file.name,
        expression: "file.name",
        modifiers: {
          "top": true
        }
      }],
      staticClass: "file-name"
    }, [_vm._v(_vm._s(file.name))]), _vm._v(" "), _c('li', {
      staticClass: "file-size"
    }, [_vm._v(_vm._s(_vm._f("transformByte")(file.size)))]), _vm._v(" "), _c('li', {
      staticClass: "file-status"
    }, [_vm._v(_vm._s(_vm._f("fileStatus")(file.status)))]), _vm._v(" "), _c('li', {
      staticClass: "file-operate"
    }, [_vm._v("\n          " + _vm._s(file.status === 'done' ? '100' : file.uploadProgress) + "%\n        ")]), _vm._v(" "), _c('li', {
      staticClass: "progress",
      class: file.status === 'error' ? 'error' : '',
      style: {
        width: file.status === 'done' ? '100' : file.uploadProgress + '%'
      }
    })]);
  }), _vm._v(" "), !_vm.uploadFiles.length ? _c('div', {
    staticClass: "no-file"
  }, [_vm._v("ææ å¾ä¸ä¼ æä»¶")]) : _vm._e()], 2)])]);
};

var __vue_staticRenderFns__$f = [];
/* style */

var __vue_inject_styles__$g = undefined;
/* scoped */

var __vue_scope_id__$g = undefined;
/* module identifier */

var __vue_module_identifier__$g = undefined;
/* functional template */

var __vue_is_functional_template__$g = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$g = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$f,
  staticRenderFns: __vue_staticRenderFns__$f
}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, undefined, undefined, undefined);

//
var script$f = {
  name: 'ui-sidemenu',
  componentName: 'UiSidemenu',
  components: {
    VPopover: VPopover,
    UiIcon: __vue_component__$1B,
    UiRippleInk: __vue_component__$1A
  },
  directives: {
    VClosePopover: VClosePopover
  },
  props: {
    open: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ''
    },
    title: {
      type: String,
      required: true
    },
    isAccordion: Boolean,
    secondary: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: undefined
    }
  },
  inject: ['RootMenu', 'UiMenu'],
  provide: function provide() {
    return {
      RootMenu: this.RootMenu,
      UiMenu: this
    };
  },
  data: function data() {
    return {
      isOpen: this.open,
      id: UUID.short('ui-sidemenu-'),
      menus: [],
      activeIndex: -1
    };
  },
  created: function created() {
    this.UiMenu.addMenu(this);
    this.RootMenu.addMenu(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.UiMenu.removeMenu(this);
    this.RootMenu.removeMenu(this);
  },
  computed: {
    classes: function classes() {
      return {
        'ui-sidemenu': true,
        'ui-menu-item': true,
        'is-open': this.isOpen,
        'is-collapse': this.RootMenu.collapse,
        'is-divider': this.divider,
        'is-disabled': this.disabled,
        'is-active': this.active
      };
    },
    active: function active() {
      return this.UiMenu.activeId === this.id;
    },
    activeId: function activeId() {
      return this.active && this.menus[this.activeIndex] ? this.menus[this.activeIndex].id : null;
    }
  },
  methods: {
    addMenu: function addMenu(menu) {
      this.menus.push(menu); // Select the menu if there's no menu selected (i.e. the menu is the only menu)
      // or the menu's selected prop is true

      if (menu.selected) {
        this.activeIndex = this.menus.length - 1;
        this.UiMenu.activeId = this.id;
        this.toggleCollapsible(true);
      }
    },
    removeMenu: function removeMenu(menu) {
      var index = this.menus.indexOf(menu);

      if (index > -1) {
        this.menus.splice(index, 1);
      }
    },
    onMenuClick: function onMenuClick(menu, event) {
      this.activeIndex = this.menus.indexOf(menu);
      this.UiMenu.onMenuClick(this, event);
      this.toggleCollapsible(true);
    },
    onMouseOver: function onMouseOver() {
      this.$refs.popover.show();
    },
    onMouseOut: function onMouseOut() {
      this.$refs.popover.hide();
    },
    toggleCollapsible: function toggleCollapsible(bool) {
      if (this.disabled || this.RootMenu.collapse) {
        return;
      }

      this.isOpen = 'boolean' === typeof bool ? bool : !this.isOpen;
    },
    closePopover: function closePopover() {
      if (this.$refs.popover) {
        this.$refs.popover.close();
      }
    }
  }
};

/* script */
var __vue_script__$f = script$f;
/* template */

var __vue_render__$e = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('li', {
    ref: "sidemenu",
    class: _vm.classes,
    attrs: {
      "tabindex": _vm.disabled ? null : '0'
    },
    on: {
      "mouseover": _vm.onMouseOver,
      "mouseout": _vm.onMouseOut
    }
  }, [_c('div', {
    staticClass: "ui-sidemenu__header"
  }, [_c('div', {
    staticClass: "ui-sidemenu__header-icon"
  }, [_vm.$slots.icon ? _vm._t("icon") : _vm.icon ? _c('ui-icon', {
    attrs: {
      "icon": _vm.icon
    }
  }) : _vm._e()], 2), _vm._v(" "), _c('div', {
    staticClass: "ui-sidemenu__header-text"
  }, [_vm.$slots.title ? _vm._t("title") : [_vm._v(_vm._s(_vm.title))]], 2), _vm._v(" "), _vm.secondary ? _c('div', {
    staticClass: "ui-sidemenu__header-secondary"
  }, [_vm._v("\n      " + _vm._s(_vm.secondary) + "\n    ")]) : _vm._e(), _vm._v(" "), _c('ui-icon', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.RootMenu.collapse,
      expression: "!RootMenu.collapse"
    }],
    staticClass: "ui-sidemenu__header-collapse",
    attrs: {
      "icon": "chevron_right"
    }
  }), _vm._v(" "), !_vm.disabled && !_vm.RootMenu.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1), _vm._v(" "), _vm.RootMenu.collapse ? _c('v-popover', {
    ref: "popover",
    staticClass: "ui-sidemenu__popover",
    attrs: {
      "popover-class": "ui-sidemenu__dropdown",
      "placement": "right-start",
      "boundaries-element": "body"
    }
  }, [_c('div', {
    directives: [{
      name: "close-popover",
      rawName: "v-close-popover"
    }],
    staticClass: "ui-sidemenu__body-wrapper",
    attrs: {
      "slot": "popover"
    },
    slot: "popover"
  }, [_c('ul', {
    staticClass: "ui-sidemenu__body",
    on: {
      "mouseover": _vm.onMouseOver,
      "mouseout": _vm.onMouseOut
    }
  }, [_vm._t("default")], 2)]), _vm._v(" "), !_vm.disabled && !_vm.RootMenu.disableRipple ? _c('ui-ripple-ink') : _vm._e()], 1) : _c('v-popover', {
    ref: "popover",
    staticClass: "ui-sidemenu__popover",
    attrs: {
      "popover-class": "ui-sidemenu__dropdown",
      "placement": "right-start",
      "boundaries-element": "body"
    }
  }, [_c('div', {
    directives: [{
      name: "close-popover",
      rawName: "v-close-popover"
    }],
    staticClass: "ui-sidemenu__body-wrapper",
    attrs: {
      "slot": "popover"
    },
    slot: "popover"
  }, [_c('ul', {
    staticClass: "ui-sidemenu__body is-inline",
    on: {
      "mouseover": _vm.onMouseOver,
      "mouseout": _vm.onMouseOut
    }
  }, [_vm._t("default")], 2)])])], 1);
};

var __vue_staticRenderFns__$e = [];
/* style */

var __vue_inject_styles__$f = undefined;
/* scoped */

var __vue_scope_id__$f = undefined;
/* module identifier */

var __vue_module_identifier__$f = undefined;
/* functional template */

var __vue_is_functional_template__$f = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$f = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$e,
  staticRenderFns: __vue_staticRenderFns__$e
}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

// 7.2.9 SameValue(x, y)
var _sameValue = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

// @@search logic
_fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = _anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = _regexpExecAbstract(rx, S);
      if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

// https://github.com/tc39/proposal-object-values-entries

var $entries = _objectToArray(true);

_export(_export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

var _arrayFill = function fill(value /* , start = 0, end = @length */) {
  var O = _toObject(this);
  var length = _toLength(O.length);
  var aLen = arguments.length;
  var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


_export(_export.P, 'Array', { fill: _arrayFill });

_addToUnscopables('fill');

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var instance$5 = axios.create({});
var script$e = {
  name: 'ui-batch-material',
  props: {
    // axios baseUrl
    baseUrl: {
      type: String,
      default: 'http://lzh.3kwan.com/api/get_supply_resources'
    },
    //è¯·æ±åæ°
    requestParams: {
      type: Object,
      default: {}
    },
    //é»è®¤æ°æ®æº
    options: {
      type: Array,
      default: []
    },
    value: {
      type: Array,
      default: []
    },
    //æ¾ç¤ºææ¬å­æ®µ
    textKey: {
      type: Array,
      default: ['resource_name', 'global_resource_id']
    },
    //æç´¢ææ§½
    search: {
      type: String,
      default: ''
    },
    //æç´¢åæ°
    searchParams: {
      type: Object,
      default: {}
    },
    //éå¶å¯éç´ ææ°é
    maxNum: {
      type: Number,
      default: 10
    },
    //æ¯å¦æ¾ç¤ºå¼¹åºå±
    visible: {
      type: Boolean,
      default: false
    },
    tabsOptions: {
      type: Array,
      default: [{
        label: 'è§é¢',
        value: '2'
      }, {
        label: 'å¾ç',
        value: '1'
      }]
    },
    tabsActive: {
      type: String,
      default: '2'
    },
    showButton: {
      type: Boolean,
      default: true
    },
    showSuccess: {
      type: Boolean,
      default: true
    },
    showSuccessHeader: {
      type: Boolean,
      default: true
    },
    previewType: {
      type: String,
      default: '1'
    },
    clearForm: {
      type: Boolean,
      default: false
    },
    maxHeight: {
      type: Number || String,
      default: 'auto'
    },
    // åé¡µå¤§å°
    pageSizes: {
      type: Array,
      default: function _default() {
        return ['10', '15', '20', '50', '100'];
      }
    },
    //ä¸é¡µå¤å°æ¡æ°é
    pageSize: {
      type: Number,
      default: 10
    },
    // åé¡µç±»å 1:position 2:cursor
    pageType: {
      type: String,
      default: 'position'
    },
    // æ¯å¦æ¾ç¤ºè§é¢æ¶é¿
    showDuration: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      atvTab: '',
      activeTab: '',
      lists: {},
      checkboxGroup: {},
      chooseData: [],
      loading: false,
      totalPages: 1,
      pageNo: 1,
      //é¡µç 
      copyOrigin: {},
      successData: [],
      uncheckboxAllStatus: false,
      checkAllLeg: 0,
      otherNum: 0,
      btnText: '',
      pageNos: [1, 1],
      activeIdx: 0,
      isdraggable: false,
      hasMore: [true, true] // æ¯å¦ææ´å¤æ°æ®

    };
  },
  components: {
    UiButton: __vue_component__$1v,
    UiModal: __vue_component__$1e,
    UiTabs: __vue_component__$C,
    UiMedia: __vue_component__$X,
    UiCheckbox: __vue_component__$1p,
    UiTextbox: __vue_component__$1r,
    Draggable: Draggable
  },
  created: function created() {
    this.setAxios();
  },
  mounted: function mounted() {
    var _this = this;

    if (this.tabsOptions) {
      this.tabsOptions.map(function (item, i) {
        _this.btnText += i != 0 ? "/".concat(item.label) : item.label;
      });
      this.pageNos = new Array(this.tabsOptions.length).fill(1);
      this.hasMore = new Array(this.tabsOptions.length).fill(true);
    }

    var nOptions = this.options.reduce(function (prev, cur) {
      if (cur.resource_url != '' && cur.resource_url != null && cur.resource_url != undefined) {
        prev.push(cur);
      }

      return prev;
    }, []);

    if (this.value.length > 0) {
      nOptions = this.value.reduce(function (prev, cur) {
        if (cur.resource_url != '' && cur.resource_url != null && cur.resource_url != undefined) {
          prev.push(cur);
        }

        return prev;
      }, []);
    }

    this.atvTab = this.activeTab = this.tabsActive;
    this.$set(this.lists, this.activeTab, []);
    this.$emit('change-tabs', this.activeTab);
    this.successData = JSON.parse(JSON.stringify(nOptions));

    if (this.visible) {
      this.openModel('material-model');
    }
  },
  watch: {
    visible: function visible(val) {
      if (val) {
        this.openModel('material-model');
      }
    },
    value: function value(val) {
      var nOptions = val.reduce(function (prev, cur) {
        if (cur.resource_url != '' && cur.resource_url != null && cur.resource_url != undefined) {
          prev.push(cur);
        }

        return prev;
      }, []);

      if (nOptions.length == 0) {
        this.clearChoose();
      }

      this.successData = JSON.parse(JSON.stringify(nOptions));
    },
    options: function options(val) {
      var nOptions = val.reduce(function (prev, cur) {
        if (cur.resource_url != '' && cur.resource_url != null && cur.resource_url != undefined) {
          prev.push(cur);
        }

        return prev;
      }, []);
      this.successData = JSON.parse(JSON.stringify(nOptions));
    }
  },
  methods: {
    showMedia: function showMedia(type, src) {
      var audio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      this.$message({
        mode: '',
        title: '',
        size: 'auto',
        content: function content(h) {
          return h(type, {
            attrs: {
              style: 'max-height: ' + ('video' === type ? '80vh' : '80vh') + '; max-width: 80vw; object-fit: contain;',
              src: src,
              audio: audio,
              play: true
            }
          });
        }
      }).catch(function () {});
    },
    mediaType: function mediaType(type) {
      var media_type = ''; // æ ¹æ®ä¼ å¥çç±»ååæ°è¿è¡å¤æ­

      switch (type) {
        case 1:
          // å¦æç±»åä¸º1ï¼åå°åªä½ç±»åè®¾ç½®ä¸ºå¾ç
          media_type = 'img';
          break;
        // å¦æç±»åä¸º2ï¼åå°åªä½ç±»åè®¾ç½®ä¸ºè§é¢

        case 2:
          media_type = 'video';
          break;

        case 4:
          media_type = 'carousel';
          break;

        case 7:
          media_type = 'group';
          break;
      }

      return media_type;
    },
    draggableStart: function draggableStart() {
      this.isdraggable = true;
    },
    draggableEnd: function draggableEnd() {
      this.isdraggable = false;
      this.$emit('change-drag', this.successData);
      this.$emit('input', this.successData);
      this.$emit('change', this.successData);
    },
    clearValidate: function clearValidate() {
      for (var _i = 0, _Object$entries = Object.entries(this.searchParams); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0];
            _Object$entries$_i[1];

        this.searchParams[key] = '';
      }
    },
    onCloseModal: function onCloseModal() {
      this.$emit('update:visible', false);

      if (this.clearForm) {
        this.clearValidate();
      }
    },
    openModel: function openModel(ref) {
      this.$refs[ref].open();

      if (this.successData.length > 0) {
        this.chooseData = JSON.parse(JSON.stringify(this.successData));
      }

      if (this.previewType == 2) {
        this.clearChoose();
      }

      this.onSearch();
    },
    closeModal: function closeModal(ref) {
      this.$refs[ref].close();
      this.$emit('update:visible', false);

      if (this.clearForm) {
        this.clearValidate();
      }
    },
    //è®¾ç½®axiosåæ°
    setAxios: function setAxios() {
      //è®¾ç½®baseUrl
      instance$5.defaults.baseURL = this.baseUrl;
    },
    axiosApi: function axiosApi(src, params) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        instance$5.get(src, {
          params: params
        }).then(function (res) {
          resolve(res.data);
        }).catch(function () {
          reject();
        });
        instance$5.interceptors.response.use(function (response) {
          var res = response.data;

          if (res == '') {
            _this2.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');

            return reject();
          }

          if (res['code'] != 0) {
            _this2.$toast(res.msg);

            return reject();
          }

          return response;
        }, function (error) {
          this.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');
          return reject(error);
        });
      });
    },
    getMediaDataByType: function getMediaDataByType(type) {
      var _this3 = this;

      var extParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var params, _yield$_this3$axiosAp, code, data, msg;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this3.uncheckboxAllStatus = false;
                _this3.checkAllLeg = 0;
                params = _objectSpread$6(_objectSpread$6({
                  resource_type: type,
                  pageNo: _this3.pageNos[_this3.activeIdx],
                  pageSize: _this3.pageSize
                }, _this3.requestParams), extParams);
                _context.next = 5;
                return _this3.axiosApi(_this3.baseUrl, params);

              case 5:
                _yield$_this3$axiosAp = _context.sent;
                code = _yield$_this3$axiosAp.code;
                data = _yield$_this3$axiosAp.data;
                msg = _yield$_this3$axiosAp.msg;

                if (!(code && code != 0)) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return", _this3.$toast(msg));

              case 11:
                if (data.resultTotal) {
                  _this3.totalPages = data.resultTotal;
                } else {
                  _this3.$set(_this3.hasMore, _this3.activeIdx, data.has_more || false);
                }

                _this3.$set(_this3.lists, type, data.list);

                _this3.checkboxGroup = {};

                _this3.lists[type].map(function (item) {
                  _this3.checkboxGroup[item.global_resource_id] = false;
                });

                setTimeout(function () {
                  _this3.$nextTick(function () {
                    _this3.initChooseStatus();
                  });
                }, 1);
                _this3.loading = false;

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    initChooseStatus: function initChooseStatus() {
      var _this4 = this;

      if (this.chooseData.length != 0) {
        this.lists[this.activeTab].map(function (item) {
          var index = _this4.chooseData.findIndex(function (value) {
            return value.global_resource_id == item.global_resource_id;
          });

          if (index != -1) {
            _this4.checkAllLeg++;
          }
        });
        this.chooseData.forEach(function (item) {
          for (var prop in _this4.checkboxGroup) {
            if (_this4.checkboxGroup.hasOwnProperty(prop) && prop === item.global_resource_id) {
              _this4.checkboxGroup[item.global_resource_id] = true;
            }
          }
        });
      }
    },
    handleUnCheckAllChange: function handleUnCheckAllChange() {
      var _this5 = this;

      if (this.lists[this.activeTab].length > this.maxNum) {
        this.$toast({
          type: 'warning',
          message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
        });
        return false;
      }

      this.uncheckboxAllStatus = true;
      this.lists[this.activeTab].map(function (item) {
        var index = _this5.chooseData.findIndex(function (value) {
          return value.global_resource_id == item.global_resource_id;
        });

        if (index != -1) {
          _this5.chooseData.splice(index, 1);

          _this5.checkAllLeg--;
        } else {
          _this5.chooseData.push(item);
        }

        for (var prop in _this5.checkboxGroup) {
          if (_this5.checkboxGroup.hasOwnProperty(prop) && prop === item.global_resource_id) {
            _this5.checkboxGroup[item.global_resource_id] = !_this5.checkboxGroup[item.global_resource_id];
          }
        }
      });
    },
    handleOtherNum: function handleOtherNum() {
      var _this6 = this;

      return new Promise(function (resolve) {
        _this6.otherNum = 0;
        _this6.chooseData.length > 0 && _this6.chooseData.map(function (item, i) {
          var index = _this6.lists[_this6.activeTab].findIndex(function (value) {
            return value.global_resource_id == item.global_resource_id;
          });

          if (index == -1 && !item.isFixed) {
            _this6.otherNum++;
          }
        });
        resolve();
      });
    },
    handleCheckAllChange: function handleCheckAllChange() {
      var _this7 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(_this7.checkAllLeg == _this7.lists[_this7.activeTab].length)) {
                  _context2.next = 3;
                  break;
                }

                _this7.lists[_this7.activeTab].map(function (item) {
                  var index = _this7.chooseData.findIndex(function (value) {
                    return value.global_resource_id == item.global_resource_id;
                  });

                  if (index != -1 && !item.isFixed) {
                    _this7.chooseData.splice(index, 1);

                    _this7.checkAllLeg--;
                  } else {
                    !item.isFixed && _this7.chooseData.push(item);
                  }

                  for (var prop in _this7.checkboxGroup) {
                    if (_this7.checkboxGroup.hasOwnProperty(prop) && prop === item.global_resource_id && !item.isFixed) {
                      _this7.checkboxGroup[item.global_resource_id] = !_this7.checkboxGroup[item.global_resource_id];
                    }
                  }
                });

                return _context2.abrupt("return", false);

              case 3:
                _context2.next = 5;
                return _this7.handleOtherNum();

              case 5:
                if (!(_this7.lists[_this7.activeTab].length + _this7.otherNum > _this7.maxNum)) {
                  _context2.next = 8;
                  break;
                }

                _this7.$toast({
                  type: 'warning',
                  message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(_this7.maxNum, "\u6761\u7D20\u6750")
                });

                return _context2.abrupt("return", false);

              case 8:
                _this7.checkAllLeg = _this7.lists[_this7.activeTab].length;
                _this7.uncheckboxAllStatus = false;

                _this7.lists[_this7.activeTab].map(function (item) {
                  var index = _this7.chooseData.findIndex(function (value) {
                    return value.global_resource_id == item.global_resource_id;
                  });

                  if (index == -1 && !item.isFixed) {
                    _this7.chooseData.push(item);
                  }

                  _this7.chooseData.map(function (item) {
                    !item.isFixed && (_this7.checkboxGroup[item.global_resource_id] = true);
                  });
                });

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    handleCheckChange: function handleCheckChange(item) {
      var index = this.chooseData.findIndex(function (value) {
        return value.global_resource_id == item.global_resource_id;
      });

      if (index == -1) {
        if (this.chooseData.length < this.maxNum) {
          if (!item.isFixed) {
            this.checkAllLeg++;
            this.chooseData.push(item);
          }
        } else {
          this.$toast({
            type: 'warning',
            message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
          });

          for (var prop in this.checkboxGroup) {
            if (this.checkboxGroup.hasOwnProperty(prop) && prop === item.global_resource_id && !item.isFixed) {
              this.checkboxGroup[item.global_resource_id] = false;
            }
          }

          return false;
        }
      } else {
        if (!item.isFixed) {
          this.checkAllLeg--;
          this.chooseData.splice(index, 1);
        }
      }
    },
    getMediaDataByParams: function getMediaDataByParams(i) {
      this.getMediaDataByType(i, _objectSpread$6(_objectSpread$6({
        resource_id: this.searchParams.resource_id,
        resource_name: this.searchParams.resource_name
      }, this.requestParams), this.searchParams));
    },
    changeTabs: function changeTabs(i) {
      var _this8 = this;

      if (this.activeTab == i) return;
      this.activeTab = i;
      this.loading = true;

      if (this.clearForm) {
        this.clearValidate();
      }

      this.tabsOptions.map(function (item, idx) {
        if (item.value == i) {
          _this8.activeIdx = idx;
        }
      });
      this.getMediaDataByParams(i);
      this.$emit('change-tabs', this.activeTab);
    },
    changeCursor: function changeCursor(type) {
      this.loading = true;
      this.pageNos[this.activeIdx] = type == 'prev' ? this.pageNos[this.activeIdx] - 1 : this.pageNos[this.activeIdx] + 1;
      this.getMediaDataByParams(this.activeTab);
    },
    changePage: function changePage(i) {
      this.loading = true;
      if (this.pageNos[this.activeIdx] == i) return;
      this.pageNos[this.activeIdx] = i;
      this.getMediaDataByParams(this.activeTab);
    },
    pageSizeChange: function pageSizeChange(num) {
      this.loading = true;
      this.pageSize = num;
      this.getMediaDataByParams(this.activeTab);
    },
    onSearch: function onSearch() {
      this.loading = true;
      this.pageNos[this.activeIdx] = 1;
      this.getMediaDataByParams(this.activeTab);
    },
    clearChoose: function clearChoose() {
      this.checkAllLeg = 0;
      this.chooseData = [];

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key)) {
          this.checkboxGroup[key] = false;
        }
      }
    },
    clearAll: function clearAll() {
      this.clearSuccess();
    },
    clearSuccess: function clearSuccess() {
      this.chooseData = this.successData = [];

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key)) {
          this.checkboxGroup[key] = false;
        }
      }

      this.$emit('success', this.successData);
      this.$emit('input', this.successData);
      this.$emit('change', this.successData);
    },
    clearItem: function clearItem(id) {
      this.delSuccessChoose(id);
    },
    delSuccessChoose: function delSuccessChoose(id) {
      var _this9 = this;

      this.delChoose(id);
      this.successData.length > 0 && this.successData.forEach(function (item, i) {
        if (item.global_resource_id == id) {
          _this9.successData.splice(i, 1);

          _this9.$emit('success', _this9.successData);

          _this9.$emit('input', _this9.successData);

          _this9.$emit('change', _this9.successData);
        }
      });
    },
    delChoose: function delChoose(id) {
      var _this10 = this;

      this.lists[this.activeTab].map(function (item) {
        if (id == item.global_resource_id) {
          _this10.checkAllLeg--;
        }
      });

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key) && key == id) {
          this.checkboxGroup[key] = false;
        }
      }

      this.chooseData.length > 0 && this.chooseData.forEach(function (item, i) {
        if (item.global_resource_id == id) {
          _this10.chooseData.splice(i, 1);
        }
      });
    },
    save: function save() {
      this.$emit('success', this.chooseData);
      this.$emit('input', this.chooseData);
      this.$emit('change', this.chooseData);
      this.successData = JSON.parse(JSON.stringify(this.chooseData));
      this.$refs['material-model'].close();

      if (this.clearForm) {
        this.clearValidate();
      }
    }
  }
};

var __vue_script__$e = script$e;
/* template */

var __vue_render__$d = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-batch-material"
  }, [_vm.previewType == 2 ? [_vm.successData.length > 0 ? _c('div', {
    staticClass: "preview-2"
  }, _vm._l(_vm.successData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "preview-item"
    }, [_c('a', {
      on: {
        "click": function click($event) {
          return _vm.openModel('material-model');
        }
      }
    }, [_c('div', {
      staticClass: "mater-item",
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "100",
        "height": "100",
        "type": _vm.mediaType(choose.resource_type),
        "hover-effect": choose.resource_type == 2 ? 'play' : 'popover',
        "src": choose.resource_url,
        "poster": choose.cover_img,
        "audio": choose.resource_type == 4 ? choose.audio : '',
        "background-color": "#f7f8fa"
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n              " + _vm._s(choose.resource_duration) + "\n            ")]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.global_resource_id,
        expression: "choose.global_resource_id"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n          " + _vm._s(choose.global_resource_id) + "\n        ")])]);
  }), 0) : _c('div', {
    staticClass: "preview-2-btn",
    on: {
      "click": function click($event) {
        return _vm.openModel('material-model');
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "add"
    }
  })], 1)] : [_vm.showButton ? _c('ui-button', {
    attrs: {
      "color": "primary",
      "icon": "add"
    },
    on: {
      "click": function click($event) {
        return _vm.openModel('material-model');
      }
    }
  }, [_vm._v(_vm._s(_vm.btnText))]) : _vm._e(), _vm._v(" "), _vm.showSuccess ? _c('div', {
    staticClass: "ui-batch-material-box check-content"
  }, [_vm.showSuccessHeader ? _c('div', {
    staticClass: "header d-flex"
  }, [_c('h2', [_vm._v("\n          ä¸ä¼ ç´ æ"), _c('span', [_vm._v(_vm._s(_vm.successData.length) + "/" + _vm._s(_vm.maxNum))])]), _vm._v(" "), _c('ui-button', {
    staticClass: "btn-clear btn-clear1",
    attrs: {
      "type": "secondary",
      "color": "red"
    },
    on: {
      "click": _vm.clearSuccess
    }
  }, [_vm._v("æ¸ç©º")])], 1) : _vm._e(), _vm._v(" "), _c('Draggable', {
    staticClass: "choose-box ui-grid",
    style: {
      'max-height': _vm.maxHeight == 'auto' ? 'none' : _vm.maxHeight + "px"
    },
    attrs: {
      "animation": "500",
      "list": _vm.successData
    },
    on: {
      "start": _vm.draggableStart,
      "end": _vm.draggableEnd
    }
  }, [_vm.successData.length > 0 ? _vm._l(_vm.successData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-grid-cell col-2 grid-item"
    }, [choose.resource_type == 4 ? _c('a', [_c('div', {
      staticClass: "mater-item",
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "76",
        "type": _vm.mediaType(choose.resource_type),
        "audio": choose.resource_type == 4 ? choose.audio : '',
        "hover-effect": !_vm.isdraggable ? choose.resource_type == 2 ? 'play' : 'popover' : '',
        "src": choose.resource_url,
        "poster": choose.cover_img
      },
      on: {
        "click": function click($event) {
          return _vm.showMedia('ui-media-carousel', choose.resource_url, choose.audio);
        }
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                  " + _vm._s(choose.resource_duration) + "\n                ")]) : _vm._e()], 1)]) : choose.resource_type == 7 ? _c('a', [_c('div', {
      staticClass: "mater-item",
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "76",
        "type": _vm.mediaType(choose.resource_type),
        "audio": choose.resource_type == 4 ? choose.audio : '',
        "hover-effect": !_vm.isdraggable ? choose.resource_type == 2 ? 'play' : 'popover' : '',
        "src": choose.resource_url,
        "poster": choose.cover_img
      },
      on: {
        "click": function click($event) {
          return _vm.showMedia('ui-media-group', choose.resource_url, choose.audio);
        }
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                  " + _vm._s(choose.resource_duration) + "\n                ")]) : _vm._e()], 1)]) : _c('a', {
      attrs: {
        "target": "_blank",
        "href": choose.resource_url
      }
    }, [_c('div', {
      staticClass: "mater-item",
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "76",
        "type": _vm.mediaType(choose.resource_type),
        "audio": choose.resource_type == 4 ? choose.audio : '',
        "hover-effect": !_vm.isdraggable ? choose.resource_type == 2 ? 'play' : 'popover' : '',
        "src": choose.resource_url,
        "poster": choose.cover_img
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                  " + _vm._s(choose.resource_duration) + "\n                ")]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.global_resource_id,
        expression: "choose.global_resource_id"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n              " + _vm._s(choose.global_resource_id) + "\n            ")]), _vm._v(" "), !choose.isFixed ? _c('div', {
      staticClass: "del",
      on: {
        "click": function click($event) {
          return _vm.delSuccessChoose(choose.global_resource_id);
        }
      }
    }, [_c('a', [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1)]) : _vm._e()]);
  }) : _c('div', {
    staticClass: "ui-batch__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1)], 2)], 1) : _vm._e()], _vm._v(" "), _c('ui-modal', {
    ref: "material-model",
    attrs: {
      "size": "large"
    },
    on: {
      "close": _vm.onCloseModal
    }
  }, [_c('div', {
    attrs: {
      "slot": "header"
    },
    slot: "header"
  }, [_c('ui-tabs', {
    attrs: {
      "options": _vm.tabsOptions,
      "option-type": "1",
      "size": "large"
    },
    on: {
      "input": _vm.changeTabs
    },
    model: {
      value: _vm.atvTab,
      callback: function callback($$v) {
        _vm.atvTab = $$v;
      },
      expression: "atvTab"
    }
  })], 1), _vm._v(" "), _c('div', {
    staticClass: "container d-flex"
  }, [_c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "ui-grid"
  }, [_vm.$slots.search || _vm.search ? [_vm._t("search", [_vm._v("\n              " + _vm._s(_vm.search) + "\n            ")])] : [_c('div', {
    staticClass: "ui-grid-cell col-9"
  }, [_c('ui-textbox', {
    staticClass: "ui-mb-1",
    attrs: {
      "label": "ç´ ææ è¯ç ",
      "floating-label": "",
      "clearable": ""
    },
    model: {
      value: _vm.searchParams.resource_id,
      callback: function callback($$v) {
        _vm.$set(_vm.searchParams, "resource_id", $$v);
      },
      expression: "searchParams.resource_id"
    }
  })], 1), _vm._v(" "), _c('div', {
    staticClass: "ui-grid-cell col-9"
  }, [_c('ui-textbox', {
    staticClass: "ui-mb-1",
    attrs: {
      "label": "ç´ æåç§°",
      "floating-label": "",
      "clearable": ""
    },
    model: {
      value: _vm.searchParams.resource_name,
      callback: function callback($$v) {
        _vm.$set(_vm.searchParams, "resource_name", $$v);
      },
      expression: "searchParams.resource_name"
    }
  })], 1)], _vm._v(" "), _c('div', {
    staticClass: "ui-grid-cell col-4"
  }, [_c('ui-button', {
    attrs: {
      "color": "primary"
    },
    on: {
      "click": _vm.onSearch
    }
  }, [_vm._v("æ¥è¯¢")])], 1)], 2), _vm._v(" "), !_vm.loading ? _c('div', [_vm.lists[_vm.activeTab] && _vm.lists[_vm.activeTab].length > 0 ? [_c('div', {
    staticClass: "checkbox-all"
  }, [_c('ui-checkbox', {
    staticClass: "ui-mb-1",
    attrs: {
      "indeterminate": _vm.checkAllLeg > 0 && _vm.checkAllLeg < _vm.lists[_vm.activeTab].length,
      "value": _vm.checkAllLeg == _vm.lists[_vm.activeTab].length
    },
    on: {
      "change": _vm.handleCheckAllChange
    }
  }, [_vm._v("å¨é")])], 1), _vm._v(" "), _c('div', {
    staticClass: "ui-grid checkbox-group"
  }, _vm._l(_vm.lists[_vm.activeTab], function (item, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-grid-cell col-4 ui-text-truncate check-item grid-item grid-item1"
    }, [_c('ui-checkbox', {
      attrs: {
        "disabled": item.isFixed
      },
      on: {
        "change": function change($event) {
          return _vm.handleCheckChange(item);
        }
      },
      model: {
        value: _vm.checkboxGroup[item.global_resource_id],
        callback: function callback($$v) {
          _vm.$set(_vm.checkboxGroup, item.global_resource_id, $$v);
        },
        expression: "checkboxGroup[item.global_resource_id]"
      }
    }, [_c('div', {
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "100%",
        "height": "90",
        "type": _vm.mediaType(item.resource_type),
        "hover-effect": item.resource_type == 2 ? 'play' : 'popover',
        "src": item.resource_url,
        "poster": item.cover_img,
        "audio": item.resource_type == 4 ? item.audio : ''
      }
    }), _vm._v(" "), _vm.showDuration && item.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                      " + _vm._s(item.resource_duration) + "\n                    ")]) : _vm._e()], 1), _vm._v(" "), item.resource_type == 4 ? _c('a', {
      on: {
        "click": function click($event) {
          return _vm.showMedia('ui-media-carousel', item.resource_url, item.audio);
        }
      }
    }, _vm._l(_vm.textKey, function (keys, i) {
      return _c('p', {
        directives: [{
          name: "tooltip",
          rawName: "v-tooltip",
          value: item[keys],
          expression: "item[keys]"
        }],
        key: i,
        staticClass: "ui-text-truncate"
      }, [_vm._v("\n                      " + _vm._s(item[keys]) + "\n                    ")]);
    }), 0) : item.resource_type == 7 ? _c('a', {
      on: {
        "click": function click($event) {
          return _vm.showMedia('ui-media-group', item.resource_url, item.audio);
        }
      }
    }, _vm._l(_vm.textKey, function (keys, i) {
      return _c('p', {
        directives: [{
          name: "tooltip",
          rawName: "v-tooltip",
          value: item[keys],
          expression: "item[keys]"
        }],
        key: i,
        staticClass: "ui-text-truncate"
      }, [_vm._v("\n                      " + _vm._s(item[keys]) + "\n                    ")]);
    }), 0) : _c('a', {
      attrs: {
        "target": "_blank",
        "href": item.resource_url
      }
    }, _vm._l(_vm.textKey, function (keys, i) {
      return _c('p', {
        directives: [{
          name: "tooltip",
          rawName: "v-tooltip",
          value: item[keys],
          expression: "item[keys]"
        }],
        key: i,
        staticClass: "ui-text-truncate"
      }, [_vm._v("\n                      " + _vm._s(item[keys]) + "\n                    ")]);
    }), 0)])], 1);
  }), 0), _vm._v(" "), _vm.pageType == 'position' ? _c('div', {
    staticClass: "my-pagination"
  }, [_c('ui-pagination', {
    attrs: {
      "page-size": _vm.pageSize,
      "total": _vm.totalPages,
      "current": _vm.pageNos[this.activeIdx]
    },
    on: {
      "change": _vm.changePage
    }
  }), _vm._v(" "), _c('span', [_vm._v("æ»" + _vm._s(Math.ceil(_vm.totalPages / _vm.pageSize)) + "é¡µ/" + _vm._s(_vm.totalPages) + "æ¡è®°å½ æ¯é¡µæ¾ç¤º")]), _vm._v(" "), _c('ui-select', {
    attrs: {
      "options": _vm.pageSizes
    },
    on: {
      "change": _vm.pageSizeChange
    },
    model: {
      value: _vm.pageSize,
      callback: function callback($$v) {
        _vm.pageSize = $$v;
      },
      expression: "pageSize"
    }
  })], 1) : _vm._e(), _vm._v(" "), _vm.pageType == 'cursor' ? _c('div', {
    staticClass: "my-pagination"
  }, [_c('ui-button', {
    staticClass: "custom-button",
    attrs: {
      "size": _vm.small,
      "disabled": _vm.pageNos[this.activeIdx] == 1
    },
    on: {
      "click": function click($event) {
        return _vm.changeCursor('prev');
      }
    }
  }, [_vm._v("ä¸ä¸é¡µ")]), _vm._v(" "), _c('ui-button', {
    staticClass: "custom-button ml-10",
    attrs: {
      "size": _vm.small,
      "disabled": !_vm.hasMore[this.activeIdx]
    },
    on: {
      "click": function click($event) {
        return _vm.changeCursor('next');
      }
    }
  }, [_vm._v("ä¸ä¸é¡µ")]), _vm._v(" "), _c('span', [_vm._v("å½åç¬¬" + _vm._s(_vm.cursor) + "é¡µ æ¯é¡µæ¾ç¤º")]), _vm._v(" "), _c('ui-select', {
    attrs: {
      "options": _vm.pageSizes
    },
    on: {
      "change": _vm.pageSizeChange
    },
    model: {
      value: _vm.pageSize,
      callback: function callback($$v) {
        _vm.pageSize = $$v;
      },
      expression: "pageSize"
    }
  })], 1) : _vm._e()] : _c('div', {
    staticClass: "ui-batch__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1)], 2) : _c('div', {
    directives: [{
      name: "loading",
      rawName: "v-loading",
      value: _vm.loading,
      expression: "loading"
    }],
    staticClass: "stripe",
    staticStyle: {
      "height": "300px"
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "check-content"
  }, [_c('div', {
    staticClass: "header d-flex"
  }, [_c('h2', [_vm._v("\n            å·²éæ©"), _c('span', [_vm._v(_vm._s(_vm.chooseData.length) + "/" + _vm._s(_vm.maxNum))])]), _vm._v(" "), _c('ui-button', {
    staticClass: "btn-clear",
    attrs: {
      "type": "secondary",
      "color": "red"
    },
    on: {
      "click": _vm.clearChoose
    }
  }, [_vm._v("æ¸ç©º")])], 1), _vm._v(" "), _c('div', {
    staticClass: "choose-box ui-grid"
  }, [_vm.chooseData.length > 0 ? _vm._l(_vm.chooseData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-grid-cell grid-item grid-item1",
      staticStyle: {
        "width": "76px"
      }
    }, [choose.resource_type == 4 ? _c('a', {
      on: {
        "click": function click($event) {
          return _vm.showMedia('ui-media-carousel', choose.resource_url, choose.audio);
        }
      }
    }, [_c('div', {
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "50",
        "type": _vm.mediaType(choose.resource_type),
        "hover-effect": choose.resource_type == 2 ? 'play' : 'popover',
        "src": choose.resource_url,
        "poster": choose.cover_img,
        "audio": choose.resource_type == 4 ? choose.audio : ''
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                    " + _vm._s(choose.resource_duration) + "\n                  ")]) : _vm._e()], 1)]) : _c('a', {
      attrs: {
        "target": "_blank",
        "href": choose.resource_url
      }
    }, [_c('div', {
      staticStyle: {
        "position": "relative"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "50",
        "type": _vm.mediaType(choose.resource_type),
        "hover-effect": choose.resource_type == 2 ? 'play' : 'popover',
        "src": choose.resource_url,
        "poster": choose.cover_img,
        "audio": choose.resource_type == 4 ? choose.audio : ''
      }
    }), _vm._v(" "), _vm.showDuration && choose.resource_duration ? _c('div', {
      staticClass: "media-slot-time"
    }, [_vm._v("\n                    " + _vm._s(choose.resource_duration) + "\n                  ")]) : _vm._e()], 1)]), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.global_resource_id,
        expression: "choose.global_resource_id"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n                " + _vm._s(choose.global_resource_id) + "\n              ")]), _vm._v(" "), !choose.isFixed ? _c('div', {
      staticClass: "del",
      on: {
        "click": function click($event) {
          return _vm.delChoose(choose.global_resource_id);
        }
      }
    }, [_c('a', [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1)]) : _vm._e()]);
  }) : _c('div', {
    staticClass: "ui-batch__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1)], 2)])]), _vm._v(" "), _c('div', {
    attrs: {
      "slot": "footer"
    },
    slot: "footer"
  }, [_c('ui-button', {
    attrs: {
      "raised": ""
    },
    on: {
      "click": function click($event) {
        return _vm.closeModal('material-model');
      }
    }
  }, [_vm._v("åæ¶")]), _vm._v(" "), _c('ui-button', {
    attrs: {
      "color": "primary",
      "raised": ""
    },
    on: {
      "click": _vm.save
    }
  }, [_vm._v("ç¡®å®")])], 1)])], 2);
};

var __vue_staticRenderFns__$d = [];
/* style */

var __vue_inject_styles__$e = undefined;
/* scoped */

var __vue_scope_id__$e = undefined;
/* module identifier */

var __vue_module_identifier__$e = undefined;
/* functional template */

var __vue_is_functional_template__$e = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$e = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$d,
  staticRenderFns: __vue_staticRenderFns__$d
}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var dayHour = 24; // ä¸å¤©24h

var weekArr = ['ææä¸', 'ææäº', 'ææä¸', 'ææå', 'ææäº', 'ææå­', 'æææ¥'];

var createArr = function createArr(len) {
  return Array.from(Array(len)).map(function (ret, id) {
    return id;
  });
};

var formatDate = function formatDate(date, fmt) {
  var o = {
    'M+': date.getMonth() + 1,
    'd+': date.getDate(),
    'h+': date.getHours(),
    'm+': date.getMinutes(),
    's+': date.getSeconds(),
    'q+': Math.floor((date.getMonth() + 3) / 3),
    S: date.getMilliseconds()
  };

  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
  }

  for (var k in o) {
    if (new RegExp('(' + k + ')').test(fmt)) {
      fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
    }
  }

  return fmt;
};

var formatWeektime = function formatWeektime(col) {
  var timestamp = 1542384000000; // '2018-11-17 00:00:00'

  var beginstamp = timestamp + col * 1800000; // col * 30 * 60 * 1000

  var endstamp = beginstamp + 1800000;
  var begin = formatDate(new Date(beginstamp), 'hh:mm');
  var end = formatDate(new Date(endstamp), 'hh:mm');

  if (end.split(':')[0] == '00' && end.split(':')[1] == '00') {
    end = '24:00';
  }

  return "".concat(begin, "~").concat(end);
};

var handleData = function handleData(res) {
  return res.map(function (ret, index) {
    var children = function children(ret, row, max) {
      var minValue = 0;
      var maxValue = 0;
      return createArr(max).map(function (t, col) {
        var newItem = {
          week: ret.week,
          value: formatWeektime(col),
          begin: formatWeektime(col).split('~')[0],
          end: formatWeektime(col).split('~')[1],
          row: row,
          col: col
        };
        var endTime = new Date("2018-01-01 ".concat(newItem.end)).getTime();
        var retLeg = ret.value.length;

        if (retLeg > 0) {
          ret.value.map(function (v) {
            minValue = new Date("2018-01-01 ".concat(v['start'])).getTime();
            maxValue = new Date("2018-01-01 ".concat(v['end'])).getTime();

            if (endTime > minValue && endTime <= maxValue) {
              newItem.check = true;
            }
          });
        } else {
          if (endTime > minValue && endTime <= maxValue) {
            newItem.check = true;
          }
        }

        return newItem;
      });
    };

    return {
      value: ret.week,
      row: index,
      child: children(ret, index, 48)
    };
  });
};

var splicing = function splicing(list) {
  var same;
  var i = -1;
  var len = list.length;
  var arr = [];
  if (!len) return;

  while (++i < len) {
    var item = list[i];

    if (item.check) {
      if (item.check !== Boolean(same)) {
        arr.push.apply(arr, ['ã', item.begin, '~', item.end]);
      } else if (arr.length) {
        arr.pop();
        arr.push(item.end);
      }
    }

    same = Boolean(item.check);
  }

  arr.shift();
  return arr.join('');
};

var script$d = {
  name: 'ui-time-period',
  props: {
    value: {
      type: String
    },
    colspan: {
      type: Number,
      default: function _default() {
        return 2;
      }
    },
    disabled: {
      type: Boolean
    }
  },
  computed: {
    styleValue: function styleValue() {
      return {
        width: "".concat(this.width, "px"),
        height: "".concat(this.height, "px"),
        left: "".concat(this.left, "px"),
        top: "".concat(this.top, "px")
      };
    },
    combinaOrign: function combinaOrign() {
      var _this = this;

      return weekArr.reduce(function (prev, cur, idx) {
        var item = {
          id: idx,
          week: cur,
          value: ''
        };

        _this.value.map(function (v) {
          if (v.id == idx) {
            item.value = v.value;
          }
        });

        prev.push(item);
        return prev;
      }, []);
    },
    data: function data() {
      return handleData(this.combinaOrign);
    },
    selectValue: function selectValue() {
      return this.data.map(function (item) {
        return {
          id: item.row,
          week: item.value,
          value: splicing(item.child)
        };
      });
    },
    selectState: function selectState() {
      return this.selectValue.some(function (ret) {
        return ret.value;
      });
    },
    selectClasses: function selectClasses() {
      return function (n) {
        return n.check ? 'ui-selected' : '';
      };
    },
    checkboxStatus: function checkboxStatus() {
      var valueObj = {};

      if (this.value.length > 0) {
        this.value.map(function (v) {
          valueObj[v.week] = v.value;
        });
      }

      return valueObj;
    }
  },
  methods: {
    cellClick: function cellClick(t) {
      var row = t.row;
      var value = t.value;

      if (this.value.length > 0) {
        var weekIdx = this.value.findIndex(function (val) {
          return row == val.id;
        });

        if (weekIdx == -1) {
          this.$emit('input', [].concat(toConsumableArray(this.value), [{
            id: row,
            week: value,
            value: [{
              start: '00:00',
              end: '24:00'
            }]
          }]));
        } else {
          //å¤æ­æ¯å¦éä¸­äºä¸æ´å¤©ï¼å¦æä¸æ¯ä¸æ´å¤©åè¡¥é½ï¼åä¹åæ¶
          var curDayData = this.value[weekIdx];
          var start = curDayData.value[0].start;
          var end = curDayData.value[0].end;

          if (start == '00:00' && end == '24:00') {
            this.$emit('input', this.value.filter(function (val) {
              return val.id != row;
            }));
          } else {
            var nValue = this.value.reduce(function (prev, cur) {
              if (cur.id == row) {
                cur.value = [{
                  start: '00:00',
                  end: '24:00'
                }];
              }

              prev.push(cur);
              return prev;
            }, []);
            this.$emit('input', nValue);
          }
        }
      } else {
        this.$emit('input', [{
          id: row,
          week: value,
          value: [{
            start: '00:00',
            end: '24:00'
          }]
        }]);
      }
    },
    handleMouseLeave: function handleMouseLeave() {
      this.isScope = false;
    },
    isTimeRangeWithin: function isTimeRangeWithin(timeRange, targetRange) {
      var _timeRange$split$map = timeRange.split('~').map(function (time) {
        return time.trim();
      }),
          _timeRange$split$map2 = slicedToArray(_timeRange$split$map, 2),
          start = _timeRange$split$map2[0],
          end = _timeRange$split$map2[1];

      var _targetRange$split$ma = targetRange.split('~').map(function (time) {
        return time.trim();
      }),
          _targetRange$split$ma2 = slicedToArray(_targetRange$split$ma, 2),
          targetStart = _targetRange$split$ma2[0],
          targetEnd = _targetRange$split$ma2[1];

      var startTime = new Date("2000/01/01 ".concat(start));
      var endTime = new Date("2000/01/01 ".concat(end));
      var targetStartTime = new Date("2000/01/01 ".concat(targetStart));
      var targetEndTime = new Date("2000/01/01 ".concat(targetEnd));
      return startTime >= targetStartTime && endTime <= targetEndTime;
    },
    showTooltip: function showTooltip(item) {
      var _this2 = this;

      if (!this.isDown) {
        var weekIdx = this.selectValue.findIndex(function (val) {
          return item.row == val.id;
        });
        var targetValue = this.selectValue[weekIdx].value;

        if (targetValue != '') {
          var isMultipleValue = targetValue.indexOf('ã') > -1;

          if (isMultipleValue) {
            targetValue.split('ã').map(function (val) {
              var isTimeRange1 = _this2.isTimeRangeWithin(item.value, val);

              if (isTimeRange1) {
                _this2.$set(_this2, 'tooltip', val);
              }
            });
          } else {
            var isTimeRange = this.isTimeRangeWithin(item.value, targetValue);

            if (isTimeRange) {
              this.$set(this, 'tooltip', targetValue.toString());
            }
          }
        }
      }
    },
    cellEnter: function cellEnter(item) {
      this.showTooltip(item);
      this.isScope = true;
      this.lastItem = item;
      var ele = this.$el.querySelector("td[data-week='".concat(item.row, "'][data-time='").concat(item.col, "']"));

      if (ele && !this.mode) {
        this.left = ele.offsetLeft;
        this.top = ele.offsetTop;
      } else {
        if (item.col <= this.col && item.row <= this.row) {
          this.width = (this.col - item.col + 1) * ele.offsetWidth;
          this.height = (this.row - item.row + 1) * ele.offsetHeight;
          this.left = ele.offsetLeft;
          this.top = ele.offsetTop;
        } else if (item.col >= this.col && item.row >= this.row) {
          this.width = (item.col - this.col + 1) * ele.offsetWidth;
          this.height = (item.row - this.row + 1) * ele.offsetHeight;
          if (item.col > this.col && item.row === this.row) this.top = ele.offsetTop;
          if (item.col === this.col && item.row > this.row) this.left = ele.offsetLeft;
        } else if (item.col > this.col && item.row < this.row) {
          this.width = (item.col - this.col + 1) * ele.offsetWidth;
          this.height = (this.row - item.row + 1) * ele.offsetHeight;
          this.top = ele.offsetTop;
        } else if (item.col < this.col && item.row > this.row) {
          this.width = (this.col - item.col + 1) * ele.offsetWidth;
          this.height = (item.row - this.row + 1) * ele.offsetHeight;
          this.left = ele.offsetLeft;
        }
      }
    },
    cellDown: function cellDown(item) {
      this.isDown = true;
      var ele = this.$el.querySelector("td[data-week='".concat(item.row, "'][data-time='").concat(item.col, "']"));
      this.check = Boolean(item.check);
      this.mode = 1;

      if (ele) {
        this.width = ele.offsetWidth;
        this.height = ele.offsetHeight;
      }

      this.row = item.row;
      this.col = item.col;
    },
    cellUp: function cellUp(item) {
      this.isDown = false;

      if (item.col <= this.col && item.row <= this.row) {
        this.selectWeek([item.row, this.row], [item.col, this.col], !this.check);
      } else if (item.col >= this.col && item.row >= this.row) {
        this.selectWeek([this.row, item.row], [this.col, item.col], !this.check);
      } else if (item.col > this.col && item.row < this.row) {
        this.selectWeek([item.row, this.row], [this.col, item.col], !this.check);
      } else if (item.col < this.col && item.row > this.row) {
        this.selectWeek([this.row, item.row], [item.col, this.col], !this.check);
      }

      this.width = 0;
      this.height = 0;
      this.mode = 0;
    },
    selectWeek: function selectWeek(row, col, check) {
      var _this3 = this;

      var _row = slicedToArray(row, 2),
          minRow = _row[0],
          maxRow = _row[1];

      var _col = slicedToArray(col, 2),
          minCol = _col[0],
          maxCol = _col[1];

      this.data.forEach(function (item) {
        item.child.forEach(function (t) {
          if (t.row >= minRow && t.row <= maxRow && t.col >= minCol && t.col <= maxCol) {
            _this3.$set(t, 'check', check);
          }
        });
      });
      var data = [];
      this.data.map(function (item) {
        var selectTime = splicing(item.child);

        if (selectTime != '') {
          var origin = selectTime.split('ã');
          var value = origin.reduce(function (prev, cur) {
            prev.push({
              start: cur.split('~')[0],
              end: cur.split('~')[1]
            });
            return prev;
          }, []);
          data.push({
            id: item.row,
            week: item.value,
            value: value
          });
        }
      });
      this.$emit('input', data);
    },
    clearWeektime: function clearWeektime() {
      this.$emit('input', []);
    },
    beforeDestroy: function beforeDestroy() {
      document.removeEventListener('mouseup', this);
    }
  },
  mounted: function mounted() {
    var _this4 = this;

    document.addEventListener('mouseup', function () {
      if (_this4.lastItem != null && _this4.isDown && !_this4.isScope) {
        _this4.cellUp(_this4.lastItem);

        _this4.isDown = false;
        _this4.lastItem = null;
      }
    });
  },
  data: function data() {
    return {
      width: 0,
      height: 0,
      left: 0,
      top: 0,
      mode: 0,
      row: 0,
      col: 0,
      theadArr: createArr(dayHour),
      lastItem: null,
      isDown: false,
      isScope: true,
      tooltip: ''
    };
  }
};

/* script */
var __vue_script__$d = script$d;
/* template */

var __vue_render__$c = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "k-weektime"
  }, [_c('div', {
    staticClass: "k-schedue"
  }), _vm._v(" "), _c('div', {
    class: {
      'k-schedue': true,
      'k-schedue-notransi': _vm.mode
    },
    style: _vm.styleValue
  }), _vm._v(" "), _c('div', {
    staticClass: "k-weektime-wrap"
  }, [_c('table', {
    staticClass: "k-weektime-table",
    class: {
      'k-min-table': _vm.colspan < 2
    }
  }, [_c('thead', {
    staticClass: "k-weektime-head"
  }, [_c('tr', [_c('th', {
    staticClass: "week-td",
    attrs: {
      "rowspan": "8"
    }
  }, [_vm._v("ææ/æ¶é´")]), _vm._v(" "), _c('th', {
    attrs: {
      "colspan": 12 * _vm.colspan
    }
  }, [_vm._v("00:00 - 12:00")]), _vm._v(" "), _c('th', {
    attrs: {
      "colspan": 12 * _vm.colspan
    }
  }, [_vm._v("12:00 - 24:00")])]), _vm._v(" "), _c('tr', _vm._l(_vm.theadArr, function (t) {
    return _c('td', {
      key: t,
      attrs: {
        "colspan": _vm.colspan
      }
    }, [_vm._v(_vm._s(t))]);
  }), 0)]), _vm._v(" "), _c('tbody', {
    staticClass: "k-weektime-body",
    on: {
      "mouseleave": _vm.handleMouseLeave
    }
  }, _vm._l(_vm.data, function (t) {
    return _c('tr', {
      key: t.row
    }, [_c('td', [_c('div', {
      staticClass: "week-item"
    }, [_c('ui-checkbox', {
      attrs: {
        "value": _vm.checkboxStatus[t.value] && _vm.checkboxStatus[t.value][0].end === '24:00' && _vm.checkboxStatus[t.value][0].start === '00:00',
        "indeterminate": _vm.checkboxStatus[t.value] && (_vm.checkboxStatus[t.value].length > 1 || _vm.checkboxStatus[t.value][0].end !== '24:00' || _vm.checkboxStatus[t.value][0].start !== '00:00')
      },
      on: {
        "change": function change($event) {
          return _vm.cellClick(t);
        }
      }
    }, [_vm._v(_vm._s(t.value))])], 1)]), _vm._v(" "), _vm._l(t.child, function (n) {
      return _c('td', {
        key: n.row + "-" + n.col,
        staticClass: "weektime-atom-item",
        class: _vm.selectClasses(n),
        attrs: {
          "data-week": n.row,
          "data-time": n.col
        },
        on: {
          "mouseenter": function mouseenter($event) {
            return _vm.cellEnter(n);
          },
          "mousedown": function mousedown($event) {
            return _vm.cellDown(n);
          },
          "mouseup": function mouseup($event) {
            return _vm.cellUp(n);
          }
        }
      }, [!_vm.isDown ? _c('div', {
        directives: [{
          name: "tooltip",
          rawName: "v-tooltip",
          value: _vm.tooltip,
          expression: "tooltip"
        }],
        staticClass: "weektime-tooltip"
      }) : _vm._e()]);
    })], 2);
  }), 0)])]), _vm._v(" "), _c('div', {
    staticClass: "k-weektime-preview"
  }, [_c('div', {
    staticClass: "g-clearfix k-weektime-con"
  }, [_c('span', {
    staticClass: "choose-status"
  }, [_vm._v("å·²é")]), _vm._v(" "), _c('span', {
    staticClass: "unchoose-status"
  }, [_vm._v("æªé")]), _vm._v("\n      " + _vm._s(_vm.selectState ? 'å·²éæ©æ¶é´æ®µ' : 'å¯æå¨é¼ æ éæ©æ¶é´æ®µ') + "\n      "), _c('a', {
    staticClass: "g-pull-right",
    on: {
      "click": function click($event) {
        $event.preventDefault();
        return _vm.clearWeektime($event);
      }
    }
  }, [_vm._v("æ¸ç©º")])]), _vm._v(" "), _c('div', {
    staticClass: "k-weektime-time"
  }, _vm._l(_vm.selectValue, function (t) {
    return _c('div', {
      key: t.id
    }, [t.value ? _c('p', [_c('span', {
      staticClass: "g-tip-text"
    }, [_vm._v(_vm._s(t.week) + "ï¼")]), _vm._v(" "), _c('span', [_vm._v(_vm._s(t.value))])]) : _vm._e()]);
  }), 0)])]);
};

var __vue_staticRenderFns__$c = [];
/* style */

var __vue_inject_styles__$d = undefined;
/* scoped */

var __vue_scope_id__$d = "data-v-5cb675fa";
/* module identifier */

var __vue_module_identifier__$d = undefined;
/* functional template */

var __vue_is_functional_template__$d = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$d = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$c,
  staticRenderFns: __vue_staticRenderFns__$c
}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') > -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}

var script$c = {
  name: 'ui-rate',
  componentName: 'VmRate',
  props: {
    value: {
      type: Number,
      default: 0
    },
    size: {
      type: [Number, String],
      default: 18
    },
    max: {
      type: Number,
      default: 5
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    colors: {
      type: Array,
      default: function _default() {
        return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
      }
    },
    voidColor: {
      type: String,
      default: '#C6D1DE'
    },
    disabledVoidColor: {
      type: String,
      default: '#C6D1DE'
    },
    iconClasses: {
      type: Array,
      default: function _default() {
        return ['ui-rate-icon-star-full', 'ui-rate-icon-star-full', 'ui-rate-icon-star-full'];
      }
    },
    voidIconClass: {
      type: String,
      default: 'ui-rate-icon-star-empty'
    },
    disabledVoidIconClass: {
      type: String,
      default: 'ui-rate-icon-star-full'
    },
    showText: {
      type: Boolean,
      default: false
    },
    texts: {
      type: Array,
      default: function _default() {
        return ['æå·®', 'å¤±æ', 'ä¸è¬', 'æ»¡æ', 'æå'];
      }
    },
    textTemplate: {
      type: String,
      default: '{value}'
    },
    textColor: {
      type: String,
      default: '#1f2d3d'
    },
    textType: {
      type: String,
      default: 'text'
    }
  },
  data: function data() {
    return {
      colorMap: {},
      classMap: {},
      pointerAtLeftHalf: true,
      currentValue: this.value,
      hoverIndex: -1
    };
  },
  watch: {
    value: function value(val) {
      this.currentValue = val;
      this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
    }
  },
  computed: {
    text: function text() {
      var result = '';

      if (this.disabled || this.textType === 'number') {
        result = this.textTemplate.replace(/\{\s*value\s*\}/, "".concat('<i>' + this.currentValue + '</i>'));
      } else {
        result = this.texts[Math.ceil(this.currentValue / (this.max / this.texts.length)) - 1];
      }

      return result;
    },
    voidClass: function voidClass() {
      return this.disabled ? this.classMap.disabledVoidClass : this.classMap.voidClass;
    },
    activeClass: function activeClass() {
      return this.getValueFromMap(this.currentValue, this.classMap);
    },
    classes: function classes() {
      var result = [];
      var i = 0;
      var threshold = this.currentValue;

      if (this.allowHalf && this.currentValue !== Math.floor(this.currentValue)) {
        threshold--;
      }

      for (; i < threshold; i++) {
        result.push(this.activeClass);
      }

      for (; i < this.max; i++) {
        result.push(this.voidClass);
      }

      return result;
    },
    activeColor: function activeColor() {
      return this.getValueFromMap(this.currentValue, this.colorMap);
    },
    valueDecimal: function valueDecimal() {
      return this.value * 100 - Math.floor(this.value) * 100;
    },
    decimalIconClass: function decimalIconClass() {
      return this.getValueFromMap(this.value, this.classMap);
    },
    decimalStyle: function decimalStyle() {
      var width = '';

      if (this.disabled) {
        width = "".concat(this.allowHalf ? this.valueDecimal : 0, "%");
      }

      if (this.allowHalf && !this.disabled) {
        width = '50%';
      }

      return {
        color: this.activeColor,
        width: width
      };
    }
  },
  methods: {
    getValueFromMap: function getValueFromMap(value, map) {
      var result = '';

      if (value <= this.lowThreshold) {
        result = map.lowColor || map.lowClass;
      } else if (value >= this.highThreshold) {
        result = map.highColor || map.highClass;
      } else {
        result = map.mediumColor || map.mediumClass;
      }

      return result;
    },
    showDecimalIcon: function showDecimalIcon(item) {
      var showWhenDisabled = this.disabled && this.valueDecimal && item - 1 < this.value && item > this.value;
      var showWhenAllowHalf = this.allowHalf && this.pointerAtLeftHalf && this.currentValue < item && this.currentValue >= item - 0.5;
      return showWhenDisabled || showWhenAllowHalf;
    },
    getIconStyle: function getIconStyle(item) {
      var voidColor = this.disabled ? this.colorMap.disabledVoidColor : this.colorMap.voidColor;
      var UNITS = ['%', 'in', 'cm', 'mm', 'em', 'ex', 'pt', 'pc', 'px', 'rem'];
      return {
        color: item <= this.currentValue ? this.activeColor : voidColor,
        fontSize: "".concat(this.size + (typeof this.size === 'string' && UNITS.indexOf(this.size.replace(/\d*\.*\d*/, '')) > -1 ? '' : 'px'))
      };
    },
    selectValue: function selectValue(value) {
      if (this.disabled) {
        return;
      }

      if (this.allowHalf && this.pointerAtLeftHalf) {
        this.$emit('input', this.currentValue);
        this.$emit('change', this.currentValue);
      } else {
        this.$emit('input', value);
        this.$emit('change', value);
      }
    },
    setCurrentValue: function setCurrentValue(value, event) {
      if (this.disabled) {
        return;
      }

      if (this.allowHalf) {
        var target = event.target;

        if (hasClass(target, 'ui-rate__item')) {
          target = target.querySelector('.ui-rate__icon');
        }

        if (hasClass(target, 'ui-rate__decimal')) {
          target = target.parentNode;
        }

        this.pointerAtLeftHalf = event.offsetX * 2 <= target.clientWidth;
        this.currentValue = this.pointerAtLeftHalf ? value - 0.5 : value;
      } else {
        this.currentValue = value;
      }

      this.hoverIndex = value;
    },
    resetCurrentValue: function resetCurrentValue() {
      if (this.disabled) {
        return;
      }

      if (this.allowHalf) {
        this.pointerAtLeftHalf = this.value !== Math.floor(this.value);
      }

      this.currentValue = this.value;
      this.hoverIndex = -1;
    }
  },
  created: function created() {
    if (!this.value) {
      this.$emit('input', 0);
    }

    this.colorMap = {
      lowColor: this.colors[0],
      mediumColor: this.colors[1],
      highColor: this.colors[2],
      voidColor: this.voidColor,
      disabledVoidColor: this.disabledVoidColor
    };
    this.classMap = {
      lowClass: this.iconClasses[0],
      mediumClass: this.iconClasses[1],
      highClass: this.iconClasses[2],
      voidClass: this.voidIconClass,
      disabledVoidClass: this.disabledVoidIconClass
    };
  }
};

/* script */
var __vue_script__$c = script$c;
/* template */

var __vue_render__$b = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-rate"
  }, [_vm._l(_vm.max, function (item) {
    return _c('span', {
      staticClass: "ui-rate__item",
      style: {
        cursor: _vm.disabled ? 'auto' : 'pointer'
      },
      on: {
        "mousemove": function mousemove($event) {
          return _vm.setCurrentValue(item, $event);
        },
        "mouseleave": _vm.resetCurrentValue,
        "click": function click($event) {
          return _vm.selectValue(item);
        }
      }
    }, [_c('ui-icon', {
      staticClass: "ui-rate__icon",
      class: [_vm.classes[item - 1], {
        hover: _vm.hoverIndex === item
      }],
      style: _vm.getIconStyle(item)
    }, [_vm.$slots.icon ? [_vm._t("icon")] : [_c('svg', {
      staticClass: "icon",
      staticStyle: {
        "width": "1em",
        "height": "1em",
        "vertical-align": "middle",
        "fill": "currentColor",
        "overflow": "hidden"
      },
      attrs: {
        "viewBox": "0 0 1024 1024",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg",
        "p-id": "769"
      }
    }, [_c('path', {
      attrs: {
        "d": "M484.266667 272.021333l6.634666 6.72c5.973333 5.973333 13.013333 12.842667 21.098667 20.629334l9.194667-8.917334c7.253333-7.04 13.44-13.184 18.56-18.432a193.28 193.28 0 0 1 277.44 0c75.904 77.525333 76.629333 202.794667 2.133333 281.194667L512 853.333333 204.672 553.237333c-74.474667-78.421333-73.770667-203.690667 2.133333-281.216a193.28 193.28 0 0 1 277.44 0z",
        "p-id": "770"
      }
    })])]], 2), _vm._v(" "), _vm.showDecimalIcon(item) ? _c('ui-icon', {
      staticClass: "ui-rate__decimal",
      class: _vm.decimalIconClass,
      style: _vm.decimalStyle
    }, [_vm.$slots.icon ? [_vm._t("icon")] : [_c('svg', {
      staticClass: "icon",
      staticStyle: {
        "width": "1em",
        "height": "1em",
        "vertical-align": "middle",
        "fill": "currentColor",
        "overflow": "hidden"
      },
      attrs: {
        "viewBox": "0 0 1024 1024",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg",
        "p-id": "769"
      }
    }, [_c('path', {
      attrs: {
        "d": "M484.266667 272.021333l6.634666 6.72c5.973333 5.973333 13.013333 12.842667 21.098667 20.629334l9.194667-8.917334c7.253333-7.04 13.44-13.184 18.56-18.432a193.28 193.28 0 0 1 277.44 0c75.904 77.525333 76.629333 202.794667 2.133333 281.194667L512 853.333333 204.672 553.237333c-74.474667-78.421333-73.770667-203.690667 2.133333-281.216a193.28 193.28 0 0 1 277.44 0z",
        "p-id": "770"
      }
    })])]], 2) : _vm._e()], 1);
  }), _vm.showText ? _c('span', {
    staticClass: "ui-rate__text",
    style: {
      color: _vm.textColor
    },
    domProps: {
      "innerHTML": _vm._s(_vm.text)
    }
  }) : _vm._e()], 2);
};

var __vue_staticRenderFns__$b = [];
/* style */

var __vue_inject_styles__$c = undefined;
/* scoped */

var __vue_scope_id__$c = "data-v-114a8b30";
/* module identifier */

var __vue_module_identifier__$c = undefined;
/* functional template */

var __vue_is_functional_template__$c = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$c = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$b,
  staticRenderFns: __vue_staticRenderFns__$b
}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$b = {
  name: 'ui-carousel',
  computed: {
    swiper: function swiper() {
      return this.$refs.mySwiper.$swiper;
    },
    classStyle: function classStyle() {
      return {
        color: this.arrowColor
      };
    },
    placementStyle: function placementStyle() {
      return {
        'arrow-placement': this.arrowPlacement == 'outside' ? true : false
      };
    }
  },
  props: {
    slidesPerView: {
      type: Number,
      default: 1
    },
    spaceBetween: {
      type: Number,
      default: 20
    },
    autoplay: {
      type: Boolean,
      default: false
    },
    showArrow: {
      type: Boolean,
      default: false
    },
    arrowColor: {
      type: String,
      default: ''
    },
    arrowPlacement: {
      type: String,
      default: 'inside'
    }
  },
  data: function data() {
    return {
      swiperOptions: {
        autoplay: this.autoplay,
        slidesPerView: this.slidesPerView,
        spaceBetween: this.spaceBetween,
        pagination: {
          el: '.swiper-pagination',
          clickable: true
        },
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev'
        }
      }
    };
  },
  methods: {
    slideNext: function slideNext() {
      this.swiper.slideNext();
    }
  }
};

/* script */
var __vue_script__$b = script$b;
/* template */

var __vue_render__$a = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-carousel",
    class: _vm.placementStyle
  }, [_vm.arrowPlacement == 'outside' && _vm.showArrow ? [_c('div', {
    staticClass: "swiper-button-prev",
    style: _vm.classStyle,
    attrs: {
      "slot": "button-prev"
    },
    slot: "button-prev"
  }), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-next",
    style: _vm.classStyle,
    attrs: {
      "slot": "button-next"
    },
    slot: "button-next"
  })] : _vm._e(), _vm._v(" "), _c('swiper', {
    ref: "mySwiper",
    attrs: {
      "options": _vm.swiperOptions
    }
  }, [_vm._t("default"), _vm._v(" "), _c('div', {
    staticClass: "swiper-pagination",
    attrs: {
      "slot": "pagination"
    },
    slot: "pagination"
  }), _vm._v(" "), _vm.arrowPlacement == 'inside' && _vm.showArrow ? [_c('div', {
    staticClass: "swiper-button-prev",
    style: _vm.classStyle,
    attrs: {
      "slot": "button-prev"
    },
    slot: "button-prev"
  }), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-next",
    style: _vm.classStyle,
    attrs: {
      "slot": "button-next"
    },
    slot: "button-next"
  })] : _vm._e()], 2)], 2);
};

var __vue_staticRenderFns__$a = [];
/* style */

var __vue_inject_styles__$b = undefined;
/* scoped */

var __vue_scope_id__$b = undefined;
/* module identifier */

var __vue_module_identifier__$b = undefined;
/* functional template */

var __vue_is_functional_template__$b = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$b = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$a,
  staticRenderFns: __vue_staticRenderFns__$a
}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

//
//
//
//
var script$a = {
  name: 'ui-carousel-item'
};

/* script */
var __vue_script__$a = script$a;
/* template */

var __vue_render__$9 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('swiper-slide', {
    staticClass: "ui-carousel-item"
  }, [_vm._t("default")], 2);
};

var __vue_staticRenderFns__$9 = [];
/* style */

var __vue_inject_styles__$a = undefined;
/* scoped */

var __vue_scope_id__$a = undefined;
/* module identifier */

var __vue_module_identifier__$a = undefined;
/* functional template */

var __vue_is_functional_template__$a = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$a = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$9,
  staticRenderFns: __vue_staticRenderFns__$9
}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

// helper functions
var validateUserRules = function validateUserRules(tag, validation) {
  return validation.filter(function (val) {
    var text = tag.text; // if the rule is a string, we convert it to RegExp

    if (typeof val.rule === 'string') return !new RegExp(val.rule).test(text);
    if (val.rule instanceof RegExp) return !val.rule.test(text); // if we deal with a function, invoke it

    var isFunction = {}.toString.call(val.rule) === '[object Function]';
    if (isFunction) return val.rule(tag);
  }).map(function (val) {
    return val.classes;
  });
};

var clone = function clone(node) {
  return JSON.parse(JSON.stringify(node));
};

var findIndex = function findIndex(arr, callback) {
  var index = 0;

  while (index < arr.length) {
    if (callback(arr[index], index, arr)) return index;
    index++;
  }

  return -1;
};

var createClasses = function createClasses(tag, tags) {
  var validation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var customDuplicateFn = arguments.length > 3 ? arguments[3] : undefined;
  if (tag.text === undefined) tag = {
    text: tag
  }; // create css classes from the user validation array

  var classes = validateUserRules(tag, validation); // if we find the tag, it's an exsting one which is edited.
  // in this case we must splice it out

  var index = findIndex(tags, function (t) {
    return t === tag;
  });
  var tagsDiff = clone(tags);
  var inputTag = index !== -1 ? tagsDiff.splice(index, 1)[0] : clone(tag); // check whether the tag is a duplicate or not

  var duplicate = customDuplicateFn ? customDuplicateFn(tagsDiff, inputTag) : tagsDiff.map(function (t) {
    return t.text;
  }).indexOf(inputTag.text) !== -1; // if it's a duplicate, push the class duplicate to the array

  if (duplicate) classes.push('ti-duplicate'); // if we find no classes, the tag is valid â push the class valid

  classes.length === 0 ? classes.push('ti-valid') : classes.push('ti-invalid');
  return classes;
};
/**
 * @description Create one tag out of a String or validate an existing one
 * @property {helpers}
 * @param {Object|String} tag A tag which should be validated | A String to create a tag
 * @param {Array} tagsarray The tags array
 * @param {Array} [validation=[]] The validation Array is optional (pass it if you use one)
 * @returns {Object} The created (validated) tag
 */


var createTag = function createTag(tag) {
  // if text is undefined, a string is passed. let's make a tag out of it
  if (tag.text === undefined) tag = {
    text: tag
  }; // we better make a clone to not getting reference trouble

  var t = clone(tag); // create the validation classes

  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  t.tiClasses = createClasses.apply(void 0, [tag].concat(rest));
  return t;
};
/**
 * @description Create multiple tags out of Strings or validate existing tags
 * @property {helpers}
 * @param {Array} tagsarray An Array containing tags or strings. See example below.
 * @param {Array} [validation=[]] The validation Array is optional (pass it if you use one)
 * @returns {Array} An array containing (validated) tags
 * @example  &#47;* Example to call the function *&#47;
   const validatedTags = createTags(['tag1Text', 'tag2Text'], [{ type: 'length', rule: /[0-9]/ }])
 */


var createTags = function createTags(tags) {
  for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    rest[_key2 - 1] = arguments[_key2];
  }

  return tags.map(function (t) {
    return createTag.apply(void 0, [t, tags].concat(rest));
  });
};

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$9 = {
  name: 'TagInput',
  props: {
    scope: {
      type: Object
    }
  }
};

/* script */
var __vue_script__$9 = script$9;
/* template */

var __vue_render__$8 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _vm.scope.edit ? _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.scope.tag.text,
      expression: "scope.tag.text"
    }],
    staticClass: "ti-tag-input",
    attrs: {
      "maxlength": _vm.scope.maxlength,
      "type": "text",
      "size": "1"
    },
    domProps: {
      "value": _vm.scope.tag.text
    },
    on: {
      "input": [function ($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.$set(_vm.scope.tag, "text", $event.target.value);
      }, function ($event) {
        return _vm.scope.validateTag(_vm.scope.index, $event);
      }],
      "blur": function blur($event) {
        return _vm.scope.performCancelEdit(_vm.scope.index);
      },
      "keydown": function keydown($event) {
        return _vm.scope.performSaveEdit(_vm.scope.index, $event);
      }
    }
  }) : _vm._e();
};

var __vue_staticRenderFns__$8 = [];
/* style */

var __vue_inject_styles__$9 = undefined;
/* scoped */

var __vue_scope_id__$9 = "data-v-356eabd8";
/* module identifier */

var __vue_module_identifier__$9 = undefined;
/* functional template */

var __vue_is_functional_template__$9 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$9 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$8,
  staticRenderFns: __vue_staticRenderFns__$8
}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

// The file contains all props and validators which are provided by the component
var propValidatorTag = function propValidatorTag(value) {
  return !value.some(function (t) {
    var invalidText = !t.text;
    if (invalidText) console.warn('Missing property "text"', t);
    var invalidClasses = false;
    if (t.classes) invalidClasses = typeof t.classes !== 'string';
    if (invalidClasses) console.warn('Property "classes" must be type of string', t);
    return invalidText || invalidClasses;
  });
};

var propValidatorStringNumeric = function propValidatorStringNumeric(value) {
  return !value.some(function (v) {
    if (typeof v === 'number') {
      var numeric = isFinite(v) && Math.floor(v) === v;
      if (!numeric) console.warn('Only numerics are allowed for this prop. Found:', v);
      return !numeric;
    } else if (typeof v === 'string') {
      /*
       * Regex: || Not totally fool-proof yet, still matches "0a" and such
       * - allow non-word characters (aka symbols e.g. ;, :, ' etc)
       * - allow alpha characters
       * - deny numbers
       */
      var string = /\W|[a-z]|!\d/i.test(v);
      if (!string) console.warn('Only alpha strings are allowed for this prop. Found:', v);
      return !string;
    } else {
      console.warn('Only numeric and string values are allowed. Found:', v);
      return false;
    }
  });
};

var props = {
  /**
   * @description Property to bind a model to the input.
     If the user changes the input value, the model updates, too.
     If the user presses enter with an valid input,
     a new tag is created with the value of this model.
     After creating the new tag, the model is cleared.
   * @property {props}
   * @required
   * @type {String}
   * @model
   * @default ''
   */
  value: {
    type: String,
    default: '',
    required: true
  },

  /**
   * @description Pass an array containing objects like in the example below.
     The properties 'style' and 'class' are optional. Of course it is possible to add custom
     properties to a tag object. vue-tags-input won't change the key and value.
   * @property {props}
   * @type {Array}
   * @sync
   * @default []
   * @example
    {
    &emsp;text: 'My tag value', &#47;* The visible text on display *&#47;
    &emsp;style: 'background-color: #ccc', &#47;* Adding inline styles is possible *&#47;
    &emsp;classes: 'custom-class another', &#47;* The value will be added as css classes *&#47;
    }
   */
  tags: {
    type: Array,
    default: function _default() {
      return [];
    },
    validator: propValidatorTag
  },

  /**
   * @description Expects an array containing objects inside. The objects
    can have the same properties as a tag object.
   * @property {props}
   * @type {Array}
   * @default []
   */
  autocompleteItems: {
    type: Array,
    default: function _default() {
      return [];
    },
    validator: propValidatorTag
  },

  /**
   * @description Defines whether a tag is editable after creation or not.
   * @property {props}
   * @type {Boolean}
   * @default false
   */
  allowEditTags: {
    type: Boolean,
    default: false
  },

  /**
   * @description Defines if duplicate autocomplete items are filtered out from the view or not.
   * @property {props}
   * @type {Boolean}
   * @default true
   */
  autocompleteFilterDuplicates: {
    default: true,
    type: Boolean
  },

  /**
   * @description If it's true, the user can add tags only via the autocomplete layer.
   * @property {props}
   * @type {Boolean}
   * @default false
   */
  addOnlyFromAutocomplete: {
    type: Boolean,
    default: false
  },

  /**
   * @description The minimum character length which is required
     until the autocomplete layer is shown. If set to 0,
     then it'll be shown on focus.
   * @property {props}
   * @type {Number}
   * @default 1
   */
  autocompleteMinLength: {
    type: Number,
    default: 1
  },

  /**
   * @description If it's true, the autocomplete layer is always shown, regardless if
     an input or an autocomplete items exists.
   * @property {props}
   * @type {Boolean}
   * @default false
   */
  autocompleteAlwaysOpen: {
    type: Boolean,
    default: false
  },

  /**
   * @description Property to disable vue-tags-input.
   * @property {props}
   * @type {Boolean}
   * @default false
   */
  disabled: {
    type: Boolean,
    default: false
  },

  /**
   * @description The placeholder text which is shown in the input, when it's empty.
   * @property {props}
   * @type {String}
   * @default Add Tag
   */
  placeholder: {
    type: String,
    default: 'æ·»å æ ç­¾'
  },

  /**
   * @description Custom trigger key codes can be registrated. If the user presses one of these,
     a tag will be generated out of the input value. Can be either a numeric keyCode or the key
     as a string.
   * @property {props}
   * @type {Array}
   * @default [13]
   * @example add-on-key="[13, ':', ';']"
   */
  addOnKey: {
    type: Array,
    default: function _default() {
      return [13];
    },
    validator: propValidatorStringNumeric
  },

  /**
   * @description Custom trigger key codes can be registrated. If the user edits a tag
     and presses one of these, the edited tag will be saved.
     Can be either a numeric keyCode or the key as a string.
   * @property {props}
   * @type {Array}
   * @default [13]
   * @example save-on-key="[13, ':', ';']"
   */
  saveOnKey: {
    type: Array,
    default: function _default() {
      return [13];
    },
    validator: propValidatorStringNumeric
  },

  /**
   * @description The maximum amount the tags array is allowed to hold.
   * @property {props}
   * @type {Number}
   */
  maxTags: {
    type: Number
  },

  /**
   * @description The maximum amount of characters the input is allowed to hold.
   * @property {props}
   * @type {Number}
   */
  maxlength: {
    type: Number
  },

  /**
   * @description Pass an array containing objects like in the example below.
     The property 'classes' will be added as css classes, if the property 'rule' matches the text
     of a tag, an autocomplete item or the input. The property 'rule' can be type of
     RegExp or function. If the property 'disableAdd' is 'true', the item can't be added
     to the tags array, if the appropriated rule matches.
   * @property {props}
   * @type {Array}
   * @default []
   * @example
    {
    &ensp;classes: 'class', &#47;* css class *&#47;
    &ensp;rule: /^([^0-9]*)$/, &#47;* RegExp *&#47;
    }, {
    &ensp;classes: 'no-braces', &#47;* css class *&#47;
    &ensp;rule(text) { &#47;* function with text as param *&#47;
    &ensp;&ensp;return text.indexOf('{') !== -1 || text.indexOf('}') !== -1;
    &ensp;},
    &ensp;disableAdd: true, &#47;* if the rule matches, the item cannot be added *&#47;,
    },
   */
  validation: {
    type: Array,
    default: function _default() {
      return [];
    },
    validator: function validator(value) {
      return !value.some(function (v) {
        var missingRule = !v.rule;
        if (missingRule) console.warn('Property "rule" is missing', v);
        var validRule = v.rule && (typeof v.rule === 'string' || v.rule instanceof RegExp || {}.toString.call(v.rule) === '[object Function]');

        if (!validRule) {
          console.warn('A rule must be type of string, RegExp or function. Found:', JSON.stringify(v.rule));
        }

        var missingClasses = !v.classes;
        if (missingClasses) console.warn('Property "classes" is missing', v);
        var invalidType = v.type && typeof v.type !== 'string';
        if (invalidType) console.warn('Property "type" must be type of string. Found:', v);
        return !validRule || missingRule || missingClasses || invalidType;
      });
    }
  },

  /**
   * @description Defines the characters which splits a text into different pieces,
     to generate tags out of this pieces.
   * @property {props}
   * @type {Array}
   * @default [';']
   * @example
     separators: [';', ',']
     input: some; user input, has random; commas, an,d semicolons
     will split into: some - user input - has random - commas - an - d semicolons
   */
  separators: {
    type: Array,
    default: function _default() {
      return [';'];
    },
    validator: function validator(value) {
      return !value.some(function (s) {
        var invalidType = typeof s !== 'string';
        if (invalidType) console.warn('Separators must be type of string. Found:', s);
        return invalidType;
      });
    }
  },

  /**
   * @description If it's true, the user can't add or save a tag,
     if another exists, with the same text value.
   * @property {props}
   * @type {Boolean}
   * @default true
   */
  avoidAddingDuplicates: {
    type: Boolean,
    default: true
  },

  /**
   * @description If the input holds a value and loses the focus,
     a tag will be generated out of this value, if possible.
   * @property {props}
   * @type {Boolean}
   * @default true
   */
  addOnBlur: {
    type: Boolean,
    default: true
  },

  /**
   * @description Custom function to detect duplicates. If the function returns 'true',
    the tag will be marked as duplicate.
   * @property {props}
   * @type {Function}
   * @param {Array} tagsarray The Array of tags minus the one which is edited/created.
   * @param {Object} tag The tag which is edited or should be added to the tags array.
   * @example
     // The duplicate function to recreate the default behaviour, would look like this:
     isDuplicate(tags, tag) {
     &ensp;return tags.map(t => t.text).indexOf(tag.text) !== -1;
    }
   */
  isDuplicate: {
    type: Function,
    default: null
  },

  /**
   * @description If it's true, the user can paste into the input element and
     vue-tags-input will create tags out of the incoming text.
   * @property {props}
   * @type {Boolean}
   * @default true
   */
  addFromPaste: {
    type: Boolean,
    default: true
  },

  /**
   * @description Defines if it's possible to delete tags by pressing backspace.
     If so and the user wants to delete a tag,
     the tag gets the css class 'deletion-mark' for 1 second.
     If the user presses backspace again in that time period,
     the tag is removed from the tags array and the view.
   * @property {props}
   * @type {Boolean}
   * @default true
   */
  deleteOnBackspace: {
    default: true,
    type: Boolean
  }
};

var script$8 = {
  name: 'ui-tags-input',
  components: {
    TagInput: __vue_component__$9
  },
  props: props,
  data: function data() {
    return {
      newTag: null,
      tagsCopy: null,
      tagsEditStatus: null,
      deletionMark: null,
      deletionMarkTime: null,
      selectedItem: null,
      focused: null
    };
  },
  computed: {
    // Property which calculates if the autocomplete should be opened or not
    autocompleteOpen: function autocompleteOpen() {
      if (this.autocompleteAlwaysOpen) return true;
      return this.newTag !== null && this.newTag.length >= this.autocompleteMinLength && this.filteredAutocompleteItems.length > 0 && this.focused;
    },
    // Returns validated autocomplete items. Maybe duplicates are filtered out
    filteredAutocompleteItems: function filteredAutocompleteItems() {
      var _this = this;

      var is = this.autocompleteItems.map(function (i) {
        return createTag(i, _this.tags, _this.validation, _this.isDuplicate);
      });
      if (!this.autocompleteFilterDuplicates) return is;
      return is.filter(this.duplicateFilter);
    }
  },
  methods: {
    createClasses: createClasses,
    // Returns the index which item should be selected, based on the parameter 'method'
    getSelectedIndex: function getSelectedIndex(method) {
      var items = this.filteredAutocompleteItems;
      var selectedItem = this.selectedItem;
      var lastItem = items.length - 1;
      if (items.length === 0) return;
      if (selectedItem === null) return 0;
      if (method === 'before' && selectedItem === 0) return lastItem;else if (method === 'after' && selectedItem === lastItem) return 0;else return method === 'after' ? selectedItem + 1 : selectedItem - 1;
    },
    selectDefaultItem: function selectDefaultItem() {
      if (this.addOnlyFromAutocomplete && this.filteredAutocompleteItems.length > 0) {
        this.selectedItem = 0;
      } else this.selectedItem = null;
    },
    selectItem: function selectItem(e, method) {
      e.preventDefault();
      this.selectedItem = this.getSelectedIndex(method);
    },
    isSelected: function isSelected(index) {
      return this.selectedItem === index;
    },
    isMarked: function isMarked(index) {
      return this.deletionMark === index;
    },
    // Method which is called when the user presses backspace â remove the last tag
    invokeDelete: function invokeDelete() {
      var _this2 = this;

      // If we shouldn't delete tags on backspace or we have some characters in the input â stop
      if (!this.deleteOnBackspace || this.newTag.length > 0) return;
      var lastIndex = this.tagsCopy.length - 1;

      if (this.deletionMark === null) {
        this.deletionMarkTime = setTimeout(function () {
          return _this2.deletionMark = null;
        }, 1000);
        this.deletionMark = lastIndex;
      } else this.performDeleteTag(lastIndex);
    },
    addTagsFromPaste: function addTagsFromPaste() {
      var _this3 = this;

      if (!this.addFromPaste) return;
      setTimeout(function () {
        return _this3.performAddTags(_this3.newTag);
      }, 10);
    },
    // Method to call if a tag should switch to it's edit mode
    performEditTag: function performEditTag(index) {
      var _this4 = this;

      if (!this.allowEditTags) return;
      if (!this._events['before-editing-tag']) this.editTag(index);
      /**
       * @description Emits before a tag toggles to it's edit mode
       * @name before-editing-tag
       * @property {events} hook
       * @returns {Object} Contains the to editing tag: 'tag'.
         The tag's index: 'index'. And a function: 'editTag'.
         If the function is invoked, the tag toggles to it's edit mode.
       */

      this.$emit('before-editing-tag', {
        index: index,
        tag: this.tagsCopy[index],
        editTag: function editTag() {
          return _this4.editTag(index);
        }
      });
    },
    // Opens the edit mode for a tag and focuses it
    editTag: function editTag(index) {
      if (!this.allowEditTags) return;
      this.toggleEditMode(index);
      this.focus(index);
    },
    // Toggles the edit mode for a tag
    toggleEditMode: function toggleEditMode(index) {
      if (!this.allowEditTags || this.disabled) return;
      this.$set(this.tagsEditStatus, index, !this.tagsEditStatus[index]);
    },
    // only called by the @input event from TagInput.
    // Creates a new tag model and applys it to this.tagsCopy[index]
    createChangedTag: function createChangedTag(index, event) {
      // If the text of a tag changes â we create a new one with a new validation.
      // we take the value from the event if possible, because on google android phones
      // this.tagsCopy[index].text is incorrect, when typing a space on the virtual keyboard.
      // yes, this sucks ...
      var tag = this.tagsCopy[index];
      tag.text = event ? event.target.value : this.tagsCopy[index].text;
      this.$set(this.tagsCopy, index, createTag(tag, this.tagsCopy, this.validation, this.isDuplicate));
    },
    // Focuses the input of a tag
    focus: function focus(index) {
      var _this5 = this;

      this.$nextTick(function () {
        var el = _this5.$refs.tagCenter[index].querySelector('input.ti-tag-input');

        if (el) el.focus();
      });
    },
    quote: function quote(regex) {
      return regex.replace(/([()[{*+.$^\\|?])/g, '\\$1');
    },
    // Cancels the edit mode for a tag â resets the tag to it's original model!
    cancelEdit: function cancelEdit(index) {
      if (!this.tags[index]) return;
      this.tagsCopy[index] = clone(createTag(this.tags[index], this.tags, this.validation, this.isDuplicate));
      this.$set(this.tagsEditStatus, index, false);
    },
    hasForbiddingAddRule: function hasForbiddingAddRule(tiClasses) {
      var _this6 = this;

      // Does the tag has a rule, defined by the user, which prohibits adding?
      return tiClasses.some(function (type) {
        var rule = _this6.validation.find(function (rule) {
          return type === rule.classes;
        });

        return rule ? rule.disableAdd : false;
      });
    },
    // Creates multiple tags out of a string, based on the prop separators
    createTagTexts: function createTagTexts(string) {
      var _this7 = this;

      var regex = new RegExp(this.separators.map(function (s) {
        return _this7.quote(s);
      }).join('|'));
      return string.split(regex).map(function (text) {
        return {
          text: text
        };
      });
    },
    // Method to call to delete a tag
    performDeleteTag: function performDeleteTag(index) {
      var _this8 = this;

      if (!this._events['before-deleting-tag']) this.deleteTag(index);
      /**
       * @description Emits before a tag is deleted
       * @name before-deleting-tag
       * @property {events} hook
       * @returns {Object} Contains the to editing tag: 'tag'. The tag's index: 'index'
         And a function: 'deleteTag'. If the function is invoked, the tag is deleted.
       */

      this.$emit('before-deleting-tag', {
        index: index,
        tag: this.tagsCopy[index],
        deleteTag: function deleteTag() {
          return _this8.deleteTag(index);
        }
      });
    },
    deleteTag: function deleteTag(index) {
      if (this.disabled) return;
      this.deletionMark = null; // Clears the debounce for the deletion mark and removes the tag

      clearTimeout(this.deletionMarkTime);
      this.tagsCopy.splice(index, 1); // Special update for the parent if .sync is on

      if (this._events['update:tags']) this.$emit('update:tags', this.tagsCopy);
      /**
       * @description Emits if the tags array changes
       * @name tags-changed
       * @property {events}
       * @returns {Array} The modified tags array
       */

      this.$emit('tags-changed', this.tagsCopy);
    },
    // Decides wether the input keyCode is one, which is allowed to modify/add tags
    noTriggerKey: function noTriggerKey(event, category) {
      var triggerKey = this[category].indexOf(event.keyCode) !== -1 || this[category].indexOf(event.key) !== -1;
      if (triggerKey) event.preventDefault();
      return !triggerKey;
    },
    // Method to call to add a tag
    performAddTags: function performAddTags(tag, event, source) {
      var _this9 = this;

      // If the input is disabled or the function was invoked by no trigger key â stop
      if (this.disabled || event && this.noTriggerKey(event, 'addOnKey')) return; // Convert the string or object into a tags array

      var tags = [];
      if (_typeof_1(tag) === 'object') tags = [tag];
      if (typeof tag === 'string') tags = this.createTagTexts(tag); // Filter out the tags with no content

      tags = tags.filter(function (tag) {
        return tag.text.trim().length > 0;
      }); // The basic checks are done â try to add all tags

      tags.forEach(function (tag) {
        tag = createTag(tag, _this9.tags, _this9.validation, _this9.isDuplicate);
        if (!_this9._events['before-adding-tag']) _this9.addTag(tag, source);
        /**
         * @description Emits before a tag is added
         * @name before-adding-tag
         * @property {events} hook
         * @returns {Object} Contains the to editing tag: 'tag'. And a function: 'addTag'.
           If the function is invoked, the tag is added.
         */

        _this9.$emit('before-adding-tag', {
          tag: tag,
          addTag: function addTag() {
            return _this9.addTag(tag, source);
          }
        });
      });
    },
    duplicateFilter: function duplicateFilter(tag) {
      return this.isDuplicate ? !this.isDuplicate(this.tagsCopy, tag) : !this.tagsCopy.find(function (t) {
        return t.text === tag.text;
      });
    },
    addTag: function addTag(tag) {
      var _this10 = this;

      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'new-tag-input';
      // Check if we should only add items from autocomplete and if so,
      // does the tag exists as an option
      var options = this.filteredAutocompleteItems.map(function (i) {
        return i.text;
      });
      if (this.addOnlyFromAutocomplete && options.indexOf(tag.text) === -1) return; // We use $nextTick here, because this.tagsCopy.length would be wrong if tags are added fast
      // like in a loop. With $nextTick we get the correct length value

      this.$nextTick(function () {
        // Maybe we should not add a tag because the maximum has reached already
        var maximumReached = _this10.maxTags && _this10.maxTags <= _this10.tagsCopy.length;
        /**
         * @description Emits if the maximum, the tags array is allowed to hold, is reached.
           The maximum can be defined by the prop 'max-tags'.
         * @name max-tags-reached
         * @property {events}
         * @returns {Object} The 'tag' which could not be added because of the length limitation.
         */

        if (maximumReached) return _this10.$emit('max-tags-reached', tag); // If we shouldn't add duplicates and that is one â stop

        var dup = _this10.avoidAddingDuplicates && !_this10.duplicateFilter(tag);
        /**
         * @description Emits if the user tries to add a duplicate to the tag's array
           and adding duplicates is prevented by the prop 'avoid-adding-duplicates'
         * @name adding-duplicate
         * @property {events}
         */

        if (dup) return _this10.$emit('adding-duplicate', tag); // If we find a rule which avoids that the tag is added â stop

        if (_this10.hasForbiddingAddRule(tag.tiClasses)) return; // Everything is okay â add the tag

        _this10.$emit('input', '');

        _this10.newTag = '';

        _this10.tagsCopy.push(tag); // Special update for the parent if .sync is on


        if (_this10._events['update:tags']) _this10.$emit('update:tags', _this10.tagsCopy); // if the tag was added by autocomplete, focus the input

        if (source === 'autocomplete') _this10.$refs.newTagInput.focus();

        _this10.$emit('tags-changed', _this10.tagsCopy);
      });
    },
    // Method to call to save a tag
    performSaveTag: function performSaveTag(index, event) {
      var _this11 = this;

      var tag = this.tagsCopy[index]; // If the input is disabled or the function was invoked by no trigger key â stop

      if (this.disabled || event && this.noTriggerKey(event, 'addOnKey')) return; // If the tag has no content â stop

      if (tag.text.trim().length === 0) return; // The basic checks are done â try to save the tag

      if (!this._events['before-saving-tag']) this.saveTag(index, tag);
      /**
       * @description Emits before a tag is saved
       * @name before-saving-tag
       * @property {events} hook
       * @returns {Object} Contains the to editing tag: 'tag'.
         The tag's index: 'index'. And a function: 'saveTag'.
         If the function is invoked, the tag is saved.
       */

      this.$emit('before-saving-tag', {
        index: index,
        tag: tag,
        saveTag: function saveTag() {
          return _this11.saveTag(index, tag);
        }
      });
    },
    saveTag: function saveTag(index, tag) {
      // If we shouldn't save duplicates â stop
      if (this.avoidAddingDuplicates) {
        var tagsDiff = clone(this.tagsCopy);
        var inputTag = tagsDiff.splice(index, 1)[0];
        var dup = this.isDuplicate ? this.isDuplicate(tagsDiff, inputTag) : tagsDiff.map(function (t) {
          return t.text;
        }).indexOf(inputTag.text) !== -1;
        /**
         * @description Emits if the user tries to save a duplicate in the tag's array
           and saving duplicates is prevented by the prop 'avoid-adding-duplicates'
         * @name saving-duplicate
         * @property {events}
         */

        if (dup) return this.$emit('saving-duplicate', tag);
      } // If we find a rule which avoids that the tag is added â stop


      if (this.hasForbiddingAddRule(tag.tiClasses)) return; // Everything is okay â save the tag

      this.$set(this.tagsCopy, index, tag);
      this.toggleEditMode(index); // Special update for the parent if .sync is on

      if (this._events['update:tags']) this.$emit('update:tags', this.tagsCopy);
      this.$emit('tags-changed', this.tagsCopy);
    },
    tagsEqual: function tagsEqual() {
      var _this12 = this;

      return !this.tagsCopy.some(function (t, i) {
        return !fastDeepEqual(t, _this12.tags[i]);
      });
    },
    updateNewTag: function updateNewTag(ievent) {
      if (!this.composing) {
        var value = ievent.target.value;
        this.newTag = value;
        this.$emit('input', value);
      }
    },
    compositionStart: function compositionStart() {
      // å¼å§è¾å¥æ³ç»åå­ç¬¦æ¶ï¼æ è®°ä¸ºç»åæ¨¡å¼
      this.composing = true;
    },
    compositionEnd: function compositionEnd(e) {
      // ç»æè¾å¥æ³ç»åå­ç¬¦æ¶ï¼æ´æ°å¼å¹¶å¤ç
      this.newTag = e.target.value;
      this.composing = false; // å¨è¿éè¿è¡ä½ çä¸å¡é»è¾å¤ç
    },
    initTags: function initTags() {
      // We always work with a copy of the "real" tags, to easier edit them
      this.tagsCopy = createTags(this.tags, this.validation, this.isDuplicate); // Let's create an array which defines whether a tag is in edit mode or not

      this.tagsEditStatus = clone(this.tags).map(function () {
        return false;
      }); // We check if the original and the copied and validated tags are equal â
      // Update the parent if not and sync is on.

      if (this._events['update:tags'] && !this.tagsEqual()) {
        this.$emit('update:tags', this.tagsCopy);
      }
    },
    blurredOnClick: function blurredOnClick(e) {
      // if the click occurs on tagsinput â don't hide
      if (this.$el.contains(e.target) || this.$el.contains(document.activeElement)) return;
      this.performBlur(e);
    },
    performBlur: function performBlur() {
      // If we should add tags before blurring â add tag
      if (this.addOnBlur && this.focused) this.performAddTags(this.newTag); // Hide autocomplete layer

      this.focused = false;
    }
  },
  watch: {
    value: function value(newValue) {
      // If v-model change outside, update the newTag model
      if (!this.addOnlyFromAutocomplete) this.selectedItem = null;
      this.newTag = newValue.replace(/\s/g, '');
    },
    tags: {
      handler: function handler() {
        // If the tags change outside, update the tagsCopy model
        this.initTags();
      },
      deep: true
    },
    autocompleteOpen: 'selectDefaultItem'
  },
  created: function created() {
    this.newTag = this.value;
    this.initTags();
  },
  mounted: function mounted() {
    // We select a default item based on props in the autocomplete
    this.selectDefaultItem(); // We add a event listener to hide autocomplete on blur

    document.addEventListener('click', this.blurredOnClick);
  },
  destroyed: function destroyed() {
    document.removeEventListener('click', this.blurredOnClick);
  }
};

/* script */
var __vue_script__$8 = script$8;
/* template */

var __vue_render__$7 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "vue-tags-input",
    class: [{
      'ti-disabled': _vm.disabled
    }, {
      'ti-focus': _vm.focused
    }]
  }, [_c('div', {
    staticClass: "ti-input"
  }, [_vm.tagsCopy ? _c('ul', {
    staticClass: "ti-tags"
  }, [_vm._l(_vm.tagsCopy, function (tag, index) {
    return _c('li', {
      key: index,
      staticClass: "ti-tag",
      class: [{
        'ti-editing': _vm.tagsEditStatus[index]
      }, tag.tiClasses, tag.classes, {
        'ti-deletion-mark': _vm.isMarked(index)
      }],
      style: tag.style,
      attrs: {
        "tabindex": "0"
      },
      on: {
        "click": function click($event) {
          return _vm.$emit('tag-clicked', {
            tag: tag,
            index: index
          });
        }
      }
    }, [_c('div', {
      staticClass: "ti-content"
    }, [_vm.$scopedSlots['tag-left'] ? _c('div', {
      staticClass: "ti-tag-left"
    }, [_vm._t("tag-left", null, {
      "tag": tag,
      "index": index,
      "edit": _vm.tagsEditStatus[index],
      "performSaveEdit": _vm.performSaveTag,
      "performDelete": _vm.performDeleteTag,
      "performCancelEdit": _vm.cancelEdit,
      "performOpenEdit": _vm.performEditTag,
      "deletionMark": _vm.isMarked(index)
    })], 2) : _vm._e(), _vm._v(" "), _c('div', {
      ref: "tagCenter",
      refInFor: true,
      staticClass: "ti-tag-center"
    }, [!_vm.$scopedSlots['tag-center'] ? _c('span', {
      class: {
        'ti-hidden': _vm.tagsEditStatus[index]
      },
      on: {
        "click": function click($event) {
          return _vm.performEditTag(index);
        }
      }
    }, [_vm._v(_vm._s(tag.text))]) : _vm._e(), _vm._v(" "), !_vm.$scopedSlots['tag-center'] ? _c('tag-input', {
      attrs: {
        "scope": {
          edit: _vm.tagsEditStatus[index],
          maxlength: _vm.maxlength,
          tag: tag,
          index: index,
          validateTag: _vm.createChangedTag,
          performCancelEdit: _vm.cancelEdit,
          performSaveEdit: _vm.performSaveTag
        }
      }
    }) : _vm._e(), _vm._v(" "), _vm._t("tag-center", null, {
      "tag": tag,
      "index": index,
      "maxlength": _vm.maxlength,
      "edit": _vm.tagsEditStatus[index],
      "performSaveEdit": _vm.performSaveTag,
      "performDelete": _vm.performDeleteTag,
      "performCancelEdit": _vm.cancelEdit,
      "validateTag": _vm.createChangedTag,
      "performOpenEdit": _vm.performEditTag,
      "deletionMark": _vm.isMarked(index)
    })], 2), _vm._v(" "), _vm.$scopedSlots['tag-right'] ? _c('div', {
      staticClass: "ti-tag-right"
    }, [_vm._t("tag-right", null, {
      "tag": tag,
      "index": index,
      "edit": _vm.tagsEditStatus[index],
      "performSaveEdit": _vm.performSaveTag,
      "performDelete": _vm.performDeleteTag,
      "performCancelEdit": _vm.cancelEdit,
      "performOpenEdit": _vm.performEditTag,
      "deletionMark": _vm.isMarked(index)
    })], 2) : _vm._e()]), _vm._v(" "), _c('div', {
      staticClass: "ti-actions"
    }, [!_vm.$scopedSlots['tag-actions'] ? _c('ui-icon', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.tagsEditStatus[index],
        expression: "tagsEditStatus[index]"
      }],
      attrs: {
        "icon": "undo"
      },
      on: {
        "click": function click($event) {
          return _vm.cancelEdit(index);
        }
      }
    }) : _vm._e(), _vm._v(" "), !_vm.$scopedSlots['tag-actions'] ? _c('ui-icon', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.tagsEditStatus[index],
        expression: "!tagsEditStatus[index]"
      }],
      staticClass: "ti-icon-close",
      attrs: {
        "icon": "close"
      },
      on: {
        "click": function click($event) {
          return _vm.performDeleteTag(index);
        }
      }
    }) : _vm._e(), _vm._v(" "), _vm.$scopedSlots['tag-actions'] ? _vm._t("tag-actions", null, {
      "tag": tag,
      "index": index,
      "edit": _vm.tagsEditStatus[index],
      "performSaveEdit": _vm.performSaveTag,
      "performDelete": _vm.performDeleteTag,
      "performCancelEdit": _vm.cancelEdit,
      "performOpenEdit": _vm.performEditTag,
      "deletionMark": _vm.isMarked(index)
    }) : _vm._e()], 2)]);
  }), _vm._v(" "), _c('li', {
    staticClass: "ti-new-tag-input-wrapper"
  }, [_c('input', _vm._b({
    ref: "newTagInput",
    staticClass: "ti-new-tag-input",
    class: [_vm.createClasses(_vm.newTag, _vm.tags, _vm.validation, _vm.isDuplicate)],
    attrs: {
      "placeholder": _vm.placeholder,
      "maxlength": _vm.maxlength,
      "disabled": _vm.disabled,
      "type": "text",
      "size": "1"
    },
    domProps: {
      "value": _vm.newTag
    },
    on: {
      "keydown": [function ($event) {
        return _vm.performAddTags(_vm.filteredAutocompleteItems[_vm.selectedItem] || _vm.newTag, $event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && $event.keyCode !== 8) {
          return null;
        }

        return _vm.invokeDelete($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && $event.keyCode !== 9) {
          return null;
        }

        return _vm.performBlur($event);
      }, function ($event) {
        if (!$event.type.indexOf('key') && $event.keyCode !== 38) {
          return null;
        }

        return _vm.selectItem($event, 'before');
      }, function ($event) {
        if (!$event.type.indexOf('key') && $event.keyCode !== 40) {
          return null;
        }

        return _vm.selectItem($event, 'after');
      }],
      "paste": _vm.addTagsFromPaste,
      "input": _vm.updateNewTag,
      "compositionstart": _vm.compositionStart,
      "compositionend": _vm.compositionEnd,
      "blur": function blur($event) {
        return _vm.$emit('blur', $event);
      },
      "focus": function focus($event) {
        _vm.focused = true;

        _vm.$emit('focus', $event);
      },
      "click": function click($event) {
        _vm.addOnlyFromAutocomplete ? false : _vm.selectedItem = null;
      }
    }
  }, 'input', _vm.$attrs, false))])], 2) : _vm._e()]), _vm._v(" "), _vm._t("between-elements"), _vm._v(" "), _vm.autocompleteOpen ? _c('div', {
    staticClass: "ti-autocomplete",
    on: {
      "mouseout": function mouseout($event) {
        _vm.selectedItem = null;
      }
    }
  }, [_vm._t("autocomplete-header"), _vm._v(" "), _c('ul', _vm._l(_vm.filteredAutocompleteItems, function (item, index) {
    return _c('li', {
      key: index,
      staticClass: "ti-item",
      class: [item.tiClasses, item.classes, {
        'ti-selected-item': _vm.isSelected(index)
      }],
      style: item.style,
      on: {
        "mouseover": function mouseover($event) {
          _vm.disabled ? false : _vm.selectedItem = index;
        }
      }
    }, [!_vm.$scopedSlots['autocomplete-item'] ? _c('div', {
      on: {
        "click": function click($event) {
          return _vm.performAddTags(item, undefined, 'autocomplete');
        }
      }
    }, [_vm._v("\n          " + _vm._s(item.text) + "\n        ")]) : _vm._t("autocomplete-item", null, {
      "item": item,
      "index": index,
      "performAdd": function performAdd(item) {
        return _vm.performAddTags(item, undefined, 'autocomplete');
      },
      "selected": _vm.isSelected(index)
    })], 2);
  }), 0), _vm._v(" "), _vm._t("autocomplete-footer")], 2) : _vm._e()], 2);
};

var __vue_staticRenderFns__$7 = [];
/* style */

var __vue_inject_styles__$8 = undefined;
/* scoped */

var __vue_scope_id__$8 = "data-v-dda01060";
/* module identifier */

var __vue_module_identifier__$8 = undefined;
/* functional template */

var __vue_is_functional_template__$8 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$8 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$7,
  staticRenderFns: __vue_staticRenderFns__$7
}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

var _components$name$prop;

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var TAG_TYPES = ['primary', 'accent', 'green', 'orange', 'red'];
var instance$4 = axios.create({});
var TABS_OPTIONS = [{
  label: 'å¨é¨',
  value: '0'
}];
var script$7 = (_components$name$prop = {
  components: {
    UiCheckbox: __vue_component__$1p
  },
  name: 'ui-asset-lib',
  props: {
    baseUrl: {
      type: String,
      default: 'http://lzh.3kwan.com/api/getAssetLib'
    },
    //éå¶å¯éç´ ææ°é
    maxNum: {
      type: Number,
      default: 100
    },
    //åæ¢å¡åæ°
    tabsOptions: {
      type: Array,
      default: []
    },
    //é»è®¤æ°æ®æº
    options: {
      type: Array,
      default: []
    },
    //æ¯å¦æ¾ç¤ºå¼¹åºå±
    visible: {
      type: Boolean,
      default: false
    },
    tabsActive: {
      type: String,
      default: '0'
    },
    //è¯·æ±åæ°
    requestParams: {
      type: Object,
      default: {}
    },
    //æç´¢åæ°
    searchParams: {
      type: Object,
      default: {}
    },
    clearForm: {
      type: Boolean,
      default: false
    },
    //æ ç­¾ç±»åæ°æ®ï¼ä¸»è¦æ¯ç¨äºæ ·å¼åé
    tagList: {
      type: Array,
      default: []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    modalSize: {
      type: String,
      default: 'large'
    }
  },
  watch: {
    visible: function visible(val) {
      if (val) {
        this.atvTab = this.tabsActive;
        this.activeTab = this.tabsActive;
        this.getData();
      }
    }
  },
  data: function data() {
    return {
      loading: false,
      atvTab: '0',
      activeTab: '',
      checkboxGroup: [],
      pageSizes: [6, 12, 36, 90],
      // åé¡µå¤§å°
      totalPages: 1,
      pageSize: 6,
      //ä¸é¡µå¤å°æ¡æ°é
      pageNos: [1],
      //é¡µç 
      activeIdx: 0,
      chooseData: [],
      successData: [],
      lists: [],
      checkAllLeg: 0,
      otherNum: 0,
      uncheckboxAllStatus: false
    };
  },
  created: function created() {
    this.setAxios();
  },
  mounted: function mounted() {
    // this.openModel('assetlib-model')
    if (this.tabsOptions) {
      this.pageNos = new Array(this.tabsOptions.length).fill(1);
    }

    this.atvTab = this.activeTab = this.tabsActive;
    this.successData = JSON.parse(JSON.stringify(this.options));

    if (this.visible) {
      this.openModel('assetlib-model');
    }
  },
  computed: {
    tabsOptionsComputed: function tabsOptionsComputed() {
      return [].concat(TABS_OPTIONS, toConsumableArray(this.tabsOptions));
    }
  }
}, defineProperty$2(_components$name$prop, "watch", {
  visible: function visible(val) {
    if (val) {
      this.openModel('assetlib-model');
    }
  },
  options: function options(val) {
    this.successData = JSON.parse(JSON.stringify(val));
  }
}), defineProperty$2(_components$name$prop, "methods", {
  showMedia: function showMedia(type, src) {
    this.$message({
      mode: '',
      title: '',
      size: 'auto',
      content: function content(h) {
        return h(type, {
          attrs: {
            style: 'max-height: ' + ('video' === type ? '80vh' : '') + '; max-width: 80vw; object-fit: contain;',
            controls: true,
            src: src
          }
        });
      }
    }).catch(function () {});
  },
  copyText: function copyText(text) {
    this.$Clipboard({
      text: text
    });
  },
  getTagType: function getTagType(name) {
    var classPre = 'ui-tag--color-';
    var styleIndex = 0;
    if (this.tagList.length === 0) return "".concat(classPre).concat(TAG_TYPES[styleIndex]);
    var tagIndex = this.tagList.findIndex(function (tag) {
      return tag.name === name;
    });

    if (tagIndex > 0) {
      styleIndex = tagIndex % TAG_TYPES.length;
    }

    return "".concat(classPre).concat(TAG_TYPES[styleIndex]);
  },
  openModel: function openModel(ref) {
    this.$refs[ref].open();

    if (this.successData.length > 0) {
      this.chooseData = JSON.parse(JSON.stringify(this.successData));
    }

    this.onSearch();
  },
  onCloseModal: function onCloseModal() {
    this.$emit('update:visible', false);

    if (this.clearForm) {
      this.clearValidate();
    }
  },
  changeTabs: function changeTabs(i) {
    var _this = this;

    if (this.activeTab == i) return;
    this.activeTab = i;
    this.loading = true;

    if (this.clearForm) {
      this.clearValidate();
    }

    this.tabsOptions.map(function (item, idx) {
      if (item.value == i) {
        _this.activeIdx = idx;
      }
    });
    this.getDataByParams(i);
  },
  changePage: function changePage(i) {
    this.loading = true;
    if (this.pageNos[this.activeIdx] == i) return;
    this.pageNos[this.activeIdx] = i;
    this.getDataByParams(this.activeTab);
  },
  pageSizeChange: function pageSizeChange(num) {
    this.pageNos[this.activeIdx] = 1;
    this.pageSize = num;
    this.getDataByParams(this.activeTab);
  },
  onSearch: function onSearch() {
    this.loading = true;
    this.pageNos[this.activeIdx] = 1;
    this.getDataByParams(this.activeIdx);
  },
  onSave: function onSave() {
    this.$emit('success', this.chooseData);
    this.$emit('input', this.chooseData);
    this.$emit('change', this.chooseData);
    this.successData = JSON.parse(JSON.stringify(this.chooseData));
    this.$refs['assetlib-model'].close();

    if (this.clearForm) {
      this.clearValidate();
    }
  },
  setAxios: function setAxios() {
    //è®¾ç½®baseUrl
    instance$4.defaults.baseURL = this.baseUrl;
  },
  axiosApi: function axiosApi(src, params) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      instance$4.get(src, {
        params: params
      }).then(function (res) {
        resolve(res.data);
      }).catch(function () {
        reject();
      });
      instance$4.interceptors.response.use(function (response) {
        var res = response.data;

        if (res == '') {
          _this2.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');

          return reject();
        }

        if (res['code'] != 0) {
          _this2.$toast(res.msg);

          return reject();
        }

        return response;
      }, function (error) {
        this.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');
        return reject(error);
      });
    });
  },
  clearValidate: function clearValidate() {
    for (var _i = 0, _Object$entries = Object.entries(this.searchParams); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0];
          _Object$entries$_i[1];

      this.searchParams[key] = '';
    }
  },
  getDataByParams: function getDataByParams(id) {
    this.getDataByType(id, _objectSpread$5(_objectSpread$5({}, this.requestParams), this.searchParams));
  },
  getDataByType: function getDataByType(type) {
    var _this3 = this;

    var extParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var params, _yield$_this3$axiosAp, code, data, msg;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this3.uncheckboxAllStatus = false;
              _this3.checkAllLeg = 0;
              params = _objectSpread$5(_objectSpread$5({
                type: type,
                pageNo: _this3.pageNos[_this3.activeIdx],
                pageSize: _this3.pageSize
              }, _this3.requestParams), extParams);
              _context.next = 5;
              return _this3.axiosApi(_this3.baseUrl, params);

            case 5:
              _yield$_this3$axiosAp = _context.sent;
              code = _yield$_this3$axiosAp.code;
              data = _yield$_this3$axiosAp.data;
              msg = _yield$_this3$axiosAp.msg;

              if (!(code && code != 0)) {
                _context.next = 11;
                break;
              }

              return _context.abrupt("return", _this3.$toast(msg));

            case 11:
              _this3.totalPages = data.count;

              _this3.$set(_this3, 'lists', data.list);

              setTimeout(function () {
                _this3.$nextTick(function () {
                  _this3.initChooseStatus();
                });
              }, 1);
              _this3.loading = false;

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  initChooseStatus: function initChooseStatus() {
    var _this4 = this;

    if (this.chooseData.length != 0) {
      this.lists.map(function (item) {
        var index = _this4.chooseData.findIndex(function (v) {
          return v.id == item.id;
        });

        if (index != -1) {
          _this4.checkAllLeg++;
        }
      });
      this.chooseData.forEach(function (item) {
        for (var prop in _this4.checkboxGroup) {
          if (_this4.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
            _this4.checkboxGroup[item.id] = true;
          }
        }
      });
    }
  },
  handleOtherNum: function handleOtherNum() {
    var _this5 = this;

    return new Promise(function (resolve) {
      _this5.otherNum = 0;
      _this5.chooseData.length > 0 && _this5.chooseData.map(function (item, i) {
        var index = _this5.lists.findIndex(function (v) {
          return v.id == item.id;
        });

        if (index == -1) {
          _this5.otherNum++;
        }
      });
      resolve();
    });
  },
  handleCheckAllChange: function handleCheckAllChange() {
    var _this6 = this;

    return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(_this6.checkAllLeg == _this6.lists.length)) {
                _context2.next = 3;
                break;
              }

              _this6.lists.map(function (item) {
                if (item.disabled) {
                  _this6.checkAllLeg--;
                  return;
                }

                var index = _this6.chooseData.findIndex(function (v) {
                  return v.id == item.id;
                });

                if (index != -1) {
                  _this6.chooseData.splice(index, 1);

                  _this6.checkAllLeg--;
                } else {
                  _this6.checkAllLeg++;

                  _this6.chooseData.push(item);
                }

                for (var prop in _this6.checkboxGroup) {
                  if (_this6.checkboxGroup.hasOwnProperty(prop) && prop == item.id) {
                    _this6.checkboxGroup[item.id] = !_this6.checkboxGroup[item.id];
                  }
                }
              });

              return _context2.abrupt("return", false);

            case 3:
              _context2.next = 5;
              return _this6.handleOtherNum();

            case 5:
              if (!(_this6.lists.length + _this6.otherNum > _this6.maxNum)) {
                _context2.next = 8;
                break;
              }

              _this6.$toast({
                type: 'warning',
                message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(_this6.maxNum, "\u6761\u7D20\u6750")
              });

              return _context2.abrupt("return", false);

            case 8:
              _this6.checkAllLeg = _this6.lists.length;
              _this6.uncheckboxAllStatus = false;

              _this6.lists.map(function (item) {
                if (item.disabled) return;

                var index = _this6.chooseData.findIndex(function (v) {
                  return v.id == item.id;
                });

                if (index == -1) {
                  _this6.chooseData.push(item);
                }

                _this6.chooseData.map(function (item) {
                  _this6.checkboxGroup[item.id] = true;
                });
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }))();
  },
  handleCheckChange: function handleCheckChange(item) {
    if (item.disabled) return;
    var index = this.chooseData.findIndex(function (v) {
      return v.id == item.id;
    });

    if (index == -1) {
      if (this.chooseData.length < this.maxNum) {
        this.checkAllLeg++;
        this.chooseData.push(item);
      } else {
        this.$toast({
          type: 'warning',
          message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
        });

        for (var prop in this.checkboxGroup) {
          if (this.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
            this.checkboxGroup[item.id] = false;
          }
        }

        return false;
      }
    } else {
      this.checkAllLeg--;
      this.chooseData.splice(index, 1);
    }
  },
  handleUnCheckAllChange: function handleUnCheckAllChange() {
    var _this7 = this;

    if (this.lists.length > this.maxNum) {
      this.$toast({
        type: 'warning',
        message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
      });
      return false;
    }

    this.uncheckboxAllStatus = true;
    this.lists.map(function (item) {
      var index = _this7.chooseData.findIndex(function (v) {
        return v.id == item.id;
      });

      if (index != -1) {
        _this7.chooseData.splice(index, 1);

        _this7.checkAllLeg--;
      } else {
        _this7.chooseData.push(item);
      }

      for (var prop in _this7.checkboxGroup) {
        if (_this7.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
          _this7.checkboxGroup[item.id] = !_this7.checkboxGroup[item.id];
        }
      }
    });
  },
  delSuccessChoose: function delSuccessChoose(id) {
    var _this8 = this;

    this.delChoose(id);
    this.successData.length > 0 && this.successData.forEach(function (item, i) {
      if (item.id == id) {
        _this8.successData.splice(i, 1);

        _this8.$emit('success', _this8.successData);

        _this8.$emit('input', _this8.successData);

        _this8.$emit('change', _this8.successData);
      }
    });
  },
  delChoose: function delChoose(id) {
    var _this9 = this;

    this.lists.map(function (item) {
      if (id == item.id) {
        _this9.checkAllLeg--;
      }
    });

    for (var key in this.checkboxGroup) {
      if (Object.hasOwnProperty.call(this.checkboxGroup, key) && key == id) {
        this.checkboxGroup[key] = false;
      }
    }

    this.chooseData.length > 0 && this.chooseData.forEach(function (item, i) {
      if (item.id == id) {
        _this9.chooseData.splice(i, 1);
      }
    });
  }
}), _components$name$prop);

var __vue_script__$7 = script$7;
/* template */

var __vue_render__$6 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-asset-lib"
  }, [_c('div', {
    staticClass: "list-visible"
  }, [_c('ul', _vm._l(_vm.successData, function (item, i) {
    return _c('li', {
      key: i,
      staticClass: "d-flex"
    }, [_c('div', {
      staticClass: "preview"
    }, [_c('ui-media', {
      attrs: {
        "width": "100%",
        "height": "100%",
        "type": "img",
        "hover-effect": "popover",
        "src": item.url,
        "poster": item.url
      },
      on: {
        "click": function click($event) {
          return _vm.showMedia('img', item.url);
        }
      }
    })], 1), _vm._v(" "), _c('div', {
      staticClass: "text"
    }, [_c('div', {
      staticClass: "title ui-text-truncate"
    }, [_vm._v(_vm._s(item.name))]), _vm._v(" "), _c('div', {
      staticClass: "desc ui-text-truncate"
    }, [_vm._v(_vm._s(item.id))])]), _vm._v(" "), !_vm.disabled ? _c('div', {
      staticClass: "btn-close",
      on: {
        "click": function click($event) {
          return _vm.delSuccessChoose(item.id);
        }
      }
    }, [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1) : _vm._e()]);
  }), 0), _vm._v(" "), !_vm.disabled ? _c('div', {
    staticClass: "btn-open",
    on: {
      "click": function click($event) {
        return _vm.openModel('assetlib-model');
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "add"
    }
  })], 1) : _vm._e()]), _vm._v(" "), _c('ui-modal', {
    ref: "assetlib-model",
    attrs: {
      "size": _vm.modalSize
    },
    on: {
      "close": _vm.onCloseModal
    }
  }, [_c('div', {
    attrs: {
      "slot": "header"
    },
    slot: "header"
  }, [_vm._v("èµäº§åº")]), _vm._v(" "), _c('div', {
    staticClass: "d-flex container"
  }, [_c('div', {
    staticClass: "left-tabs"
  }, [_c('ui-tabs', {
    attrs: {
      "options": _vm.tabsOptionsComputed,
      "option-type": "1",
      "size": "large"
    },
    on: {
      "input": _vm.changeTabs
    },
    model: {
      value: _vm.atvTab,
      callback: function callback($$v) {
        _vm.atvTab = $$v;
      },
      expression: "atvTab"
    }
  })], 1), _vm._v(" "), _c('div', {
    staticClass: "main"
  }, [_vm.$slots.search ? _c('div', {
    staticClass: "ui-grid"
  }, [[_vm._t("search", [_vm._v("\n              " + _vm._s(_vm.search) + "\n            ")])], _vm._v(" "), _c('div', {
    staticClass: "ui-grid-cell col-4"
  }, [_c('ui-button', {
    attrs: {
      "color": "primary"
    },
    on: {
      "click": _vm.onSearch
    }
  }, [_vm._v("æ¥è¯¢")])], 1)], 2) : _vm._e(), _vm._v(" "), !_vm.loading ? _c('div', {
    staticClass: "card-container"
  }, [_vm.lists.length > 0 ? [_c('div', {
    staticClass: "checkbox-all"
  }, [_c('ui-checkbox', {
    staticClass: "ui-mb-1",
    attrs: {
      "indeterminate": _vm.checkAllLeg > 0 && _vm.checkAllLeg < _vm.lists.length,
      "value": _vm.checkAllLeg === _vm.lists.length
    },
    on: {
      "change": _vm.handleCheckAllChange
    }
  }, [_vm._v("å¨é")])], 1), _vm._v(" "), _c('ul', {
    staticClass: "data-list"
  }, _vm._l(_vm.lists, function (item, i) {
    return _c('li', {
      key: i,
      class: {
        'item-disabled': item.disabled
      }
    }, [_c('ui-checkbox', {
      attrs: {
        "disabled": item.disabled
      },
      on: {
        "change": function change($event) {
          return _vm.handleCheckChange(item);
        }
      },
      model: {
        value: _vm.checkboxGroup[item.id],
        callback: function callback($$v) {
          _vm.$set(_vm.checkboxGroup, item.id, $$v);
        },
        expression: "checkboxGroup[item.id]"
      }
    }, [_c('div', {
      staticClass: "picture"
    }, [_c('img', {
      attrs: {
        "src": item.url
      }
    }), _vm._v(" "), _c('div', {
      staticClass: "tags"
    }, _vm._l(item.type, function (type, i) {
      return _c('ui-tag', {
        key: i,
        class: _vm.getTagType(type)
      }, [_vm._v(_vm._s(type))]);
    }), 1), _vm._v(" "), _c('div', {
      staticClass: "remarks"
    }, [_vm._v("\n                      " + _vm._s(item.remark) + "\n                    ")])]), _vm._v(" "), _c('div', {
      staticClass: "text-box"
    }, [_c('div', {
      staticClass: "d-flex",
      staticStyle: {
        "align-items": "center",
        "justify-content": "space-between"
      }
    }, [_c('h2', {
      staticClass: "title ui-text-truncate",
      staticStyle: {
        "flex": "1"
      }
    }, [_vm._v("\n                        " + _vm._s(item.name) + "\n                      ")]), _vm._v(" "), _c('div', {
      staticClass: "unique-id",
      staticStyle: {
        "color": "#409eff"
      },
      on: {
        "click": function click($event) {
          return _vm.copyText(item.unique_id);
        }
      }
    }, [_vm._v("\n                        " + _vm._s(item.unique_id) + "\n                      ")])]), _vm._v(" "), _c('div', {
      staticClass: "d-flex",
      staticStyle: {
        "align-items": "center",
        "justify-content": "space-between"
      }
    }, [_c('div', {
      staticClass: "details-tags",
      staticStyle: {
        "flex": "1"
      }
    }, _vm._l(item.tag, function (tag, j) {
      return _c('ui-tag', {
        key: j
      }, [_vm._v(_vm._s(tag))]);
    }), 1), _vm._v(" "), _c('div', {
      staticClass: "cate-name"
    }, [_vm._v("\n                        " + _vm._s(item.cate_name) + "\n                      ")])])])])], 1);
  }), 0)] : _c('div', {
    staticClass: "ui-asset__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1), _vm._v(" "), _vm.lists.length > 0 ? _c('div', {
    staticClass: "my-pagination"
  }, [_c('ui-pagination', {
    attrs: {
      "page-size": _vm.pageSize,
      "total": _vm.totalPages,
      "current": _vm.pageNos[this.activeIdx]
    },
    on: {
      "change": _vm.changePage
    }
  }), _vm._v(" "), _c('span', [_vm._v("æ»" + _vm._s(Math.ceil(_vm.totalPages / _vm.pageSize)) + "é¡µ/" + _vm._s(_vm.totalPages) + "æ¡è®°å½ æ¯é¡µæ¾ç¤º")]), _vm._v(" "), _c('ui-select', {
    attrs: {
      "options": _vm.pageSizes
    },
    on: {
      "change": _vm.pageSizeChange
    },
    model: {
      value: _vm.pageSize,
      callback: function callback($$v) {
        _vm.pageSize = $$v;
      },
      expression: "pageSize"
    }
  })], 1) : _vm._e()], 2) : _c('div', {
    directives: [{
      name: "loading",
      rawName: "v-loading",
      value: _vm.loading,
      expression: "loading"
    }],
    staticClass: "stripe",
    staticStyle: {
      "height": "300px"
    }
  })])]), _vm._v(" "), _c('template', {
    slot: "footer"
  }, [_c('div', {
    staticClass: "txt"
  }, [_vm._v("\n        å·²éæ©"), _c('span', [_vm._v(_vm._s(_vm.chooseData.length))]), _vm._v("ä¸ªç´ æ\n      ")]), _vm._v(" "), _c('ui-button', {
    attrs: {
      "color": "primary",
      "raised": ""
    },
    on: {
      "click": _vm.onSave
    }
  }, [_vm._v("éå¥½äº")])], 1)], 2)], 1);
};

var __vue_staticRenderFns__$6 = [];
/* style */

var __vue_inject_styles__$7 = undefined;
/* scoped */

var __vue_scope_id__$7 = undefined;
/* module identifier */

var __vue_module_identifier__$7 = undefined;
/* functional template */

var __vue_is_functional_template__$7 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$7 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$6,
  staticRenderFns: __vue_staticRenderFns__$6
}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

var script$6 = {
  name: 'ui-dynamic-tabs',
  data: function data() {
    return {
      activeValue: this.value,
      scrollable: false,
      activeIdx: 0,
      rightModuleOffset: 25,
      searchText: '',
      isShowSearch: false,
      searchLists: [],
      inputFocus: true
    };
  },
  props: {
    showNavigation: {
      type: Boolean,
      default: false
    },

    /** æ°æ®æº */
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    value: {
      type: String,
      default: ''
    },

    /** éé¡¹å¡æ ·å¼ */
    type: {
      type: String,
      default: 'default'
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    labelKey: {
      type: String,
      default: 'label'
    },
    inline: {
      type: Boolean,
      default: false
    },

    /**
     * @name å é¤æ ç­¾ä¹åè§¦å
     * @prop {Function} beforeRemove
     * @param {Object} item å½åå é¤çæ ç­¾
     * @param {Number} index å½åå é¤çæ ç­¾çç´¢å¼
     * @return {Boolean} æ¯å¦å é¤
     */
    beforeRemove: Function,
    beforeHide: Function,
    beforeCancelHide: Function
  },
  watch: {
    value: function value(val) {
      if (val !== this.activeValue) {
        this.activeValue = val;
      }
    }
  },
  components: {
    UiRippleInk: __vue_component__$1A,
    Draggable: Draggable
  },
  mounted: function mounted() {
    var _this = this;

    window.addEventListener('resize', this.update);
    this.update();
    window.addEventListener('click', this.searchClickOutside);
    setTimeout(function () {
      _this.scrollToActiveTab();
    }, 0);
  },
  computed: {
    dynamicClass: function dynamicClass() {
      return {
        'padding-right': "".concat(this.rightModuleOffset, "px")
      };
    },
    rightModuleClass: function rightModuleClass() {
      return {
        width: "".concat(this.rightModuleOffset, "px")
      };
    },
    typeClass: function typeClass() {
      return ["dynamic-tabs-".concat(this.type), {
        inline: this.inline
      }];
    }
  },
  methods: {
    draggableEnd: function draggableEnd() {
      this.$emit('change-drag', this.options);
    },
    jumpNextTagByHide: function jumpNextTagByHide(i) {
      var optionsLeg = this.options.length;

      if (i === optionsLeg - 1) {
        for (var index = optionsLeg - 1; index >= 0; index--) {
          if (i > index) {
            var option = this.options[index];

            if (!option.hide) {
              this.activeIdx = index;
              this.activeValue = option[this.valueKey];
              break;
            }
          }
        }
      } else {
        var isHas = false;

        for (var _index = i; _index < optionsLeg; _index++) {
          var _option = this.options[_index];

          if (!_option.hide) {
            this.activeIdx = _index;
            this.activeValue = _option[this.valueKey];
            isHas = true;
            break;
          }
        }

        if (!isHas) {
          for (var _index2 = optionsLeg - 1; _index2 >= 0; _index2--) {
            if (i > _index2) {
              var _option2 = this.options[_index2];

              if (!_option2.hide) {
                this.activeIdx = _index2;
                this.activeValue = _option2[this.valueKey];
                break;
              }
            }
          }
        }
      }
    },
    onHideTag: function onHideTag(item, i) {
      var _this2 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var bool;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return new Promise(function (res) {
                  if (typeof _this2.beforeHide === 'function') {
                    _this2.beforeHide(item, function (bool) {
                      return res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 2:
                bool = _context.sent;

                if (!bool) {
                  _context.next = 12;
                  break;
                }

                item.hide = true;

                _this2.jumpNextTagByHide(i);

                _this2.$emit('hide-tag', item);

                _this2.$toast({
                  message: "\u5DF2\u9690\u85CF\u3010".concat(item[_this2.labelKey], "\u3011"),
                  type: 'success',
                  duration: 1000
                });

                if (!(_this2.activeValue === item[_this2.valueKey])) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return");

              case 10:
                _this2.$emit('input', _this2.activeValue);

                _this2.$emit('change', _this2.activeValue);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    onDelTag: function onDelTag(item, i) {
      var _this3 = this;

      NUI.$confirm("\u786E\u5B9A\u8981\u5220\u9664\u3010".concat(item[this.labelKey], "\u3011\u5417\uFF1F"), 'å é¤').then(function () {
        _this3.delTag(item, i);
      }).catch(function () {
      });
    },
    jumpNextTagByDel: function jumpNextTagByDel(i) {
      var optionsLeg = this.options.length;

      if (i === optionsLeg - 1) {
        for (var index = optionsLeg - 1; index >= 0; index--) {
          if (i === index) {
            this.options.splice(index, 1);
          }

          if (i > index) {
            var option = this.options[index];

            if (!option.hide) {
              this.activeIdx = index;
              this.activeValue = option[this.valueKey];
              break;
            }
          }
        }
      } else {
        var isHas = false;

        for (var _index3 = i; _index3 < optionsLeg; _index3++) {
          if (i === _index3) {
            this.options.splice(_index3, 1);
          }

          var _option3 = this.options[_index3 - 1];

          if (!_option3.hide) {
            this.activeIdx = _index3;
            this.activeValue = _option3[this.valueKey];
            isHas = true;
            break;
          }
        }

        if (!isHas) {
          for (var _index4 = this.options.length - 1; _index4 >= 0; _index4--) {
            if (i === _index4) {
              this.options.splice(_index4, 1);
            }

            if (i > _index4) {
              var _option4 = this.options[_index4];

              if (!_option4.hide) {
                this.activeIdx = _index4;
                this.activeValue = _option4[this.valueKey];
                break;
              }
            }
          }
        }
      }
    },
    delTag: function delTag(item, i) {
      var _this4 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var bool;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return new Promise(function (res) {
                  if (typeof _this4.beforeRemove === 'function') {
                    _this4.beforeRemove(item, function (bool) {
                      return res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 2:
                bool = _context2.sent;

                if (!bool) {
                  _context2.next = 11;
                  break;
                }

                _this4.jumpNextTagByDel(i);

                _this4.$emit('del-tag', item);

                _this4.$toast({
                  message: "\u5220\u9664\u3010".concat(item[_this4.labelKey], "\u3011\u6210\u529F"),
                  type: 'success',
                  duration: 1000
                });

                if (!(_this4.activeValue === item[_this4.valueKey])) {
                  _context2.next = 9;
                  break;
                }

                return _context2.abrupt("return");

              case 9:
                _this4.$emit('input', _this4.activeValue);

                _this4.$emit('change', _this4.activeValue);

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    checkIsAtv: function checkIsAtv(item) {
      return item[this.valueKey] === this.activeValue;
    },
    getLabel: function getLabel(item) {
      return item[this.labelKey];
    },
    onTagClick: function onTagClick(item, i) {
      var _this5 = this;

      this.activeIdx = i;
      NUI.nextTick(function () {
        _this5.scrollToActiveTab();
      });
      if (this.activeValue === item[this.valueKey]) return;
      this.activeValue = item[this.valueKey];
      this.$emit('input', this.activeValue);
      this.$emit('change', this.activeValue);
    },
    searchClickOutside: function searchClickOutside(e) {
      if (this.$refs.searchContainer && !this.$refs.searchContainer.contains(e.target)) {
        this.isShowSearch = false;
      }
    },
    onSearchItem: function onSearchItem(item, i) {
      var _this6 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
        var bool;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return new Promise(function (res) {
                  if (typeof _this6.beforeCancelHide === 'function') {
                    _this6.beforeCancelHide(item, function (bool) {
                      return res(bool);
                    });
                  } else {
                    res(true);
                  }
                });

              case 2:
                bool = _context3.sent;

                if (!bool) {
                  _context3.next = 14;
                  break;
                }

                _this6.activeIdx = i;
                _this6.isShowSearch = false;
                NUI.nextTick(function () {
                  if (!_this6.scrollable) return;

                  var activeTab = _this6.$refs.navScroll.querySelector('.is-active');

                  if (!activeTab) return;
                  activeTab.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'center'
                  });
                });
                item.hide && _this6.$emit('cancel-hide-tag', item);

                if (!(_this6.activeValue === item[_this6.valueKey])) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return");

              case 10:
                _this6.activeValue = item[_this6.valueKey];

                _this6.$emit('change', _this6.activeValue);

                _this6.options.forEach(function (option, i) {
                  if (option[_this6.valueKey] == _this6.activeValue) {
                    _this6.options[i].hide = false;
                  }
                });

                _this6.$emit('input', _this6.activeValue);

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    onChangeSearch: function onChangeSearch() {
      var _this7 = this;

      this.searchLists = this.options.filter(function (item) {
        return item[_this7.labelKey].indexOf(_this7.searchText) > -1;
      });
      var isSearch = this.searchText == '';

      if (isSearch) {
        if (this.optionType === '2') {
          var options = Object.entries(this.options).map(function (_ref) {
            var _ref2 = slicedToArray(_ref, 2),
                key = _ref2[0],
                value = _ref2[1];

            return {
              label: key,
              value: value
            };
          });
          this.activeIdx = options.findIndex(function (item) {
            return item[_this7.valueKey] === _this7.activeValue;
          });
        } else {
          this.activeIdx = this.options.findIndex(function (item) {
            return item[_this7.valueKey] === _this7.activeValue;
          });
        }

        this.scrollToActiveSearch();
      } else {
        this.activeIdx = 0;
      }
    },
    update: function update() {
      if (!this.$refs.nav) return;
      var navSize = this.$refs.nav.offsetWidth;
      var containerSize = this.$refs.navScroll.offsetWidth;

      if (containerSize >= navSize) {
        this.scrollable = false;
      } else {
        this.scrollable = this.scrollable || {};
      }

      var activeTab = this.$refs.navScroll.querySelector('.is-active');
      if (!activeTab) return;
      this.scrollToActiveTab();
    },
    scrollPrev: function scrollPrev() {},
    scrollNext: function scrollNext() {},
    scrollToActiveSearch: function scrollToActiveSearch() {
      var _this8 = this;

      NUI.nextTick(function () {
        var activeTab = _this8.$refs.searchContainer.querySelector('.active');

        if (!activeTab) return;
        activeTab.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
          inline: 'center'
        });
      });
    },
    scrollToActiveTab: function scrollToActiveTab() {
      var _this9 = this;

      this.$nextTick(function () {
        var activeTab = _this9.$refs.navScroll.querySelector('.is-active');

        if (!activeTab) return;
        activeTab.scrollIntoView({
          behavior: 'instant',
          block: 'center',
          inline: 'center'
        });
      });
    },
    changeTab: function changeTab(e) {
      var keyCode = e.keyCode;
      if ([37, 38, 39, 40, 13].indexOf(keyCode) === -1) return;

      if (keyCode === 13) {
        //enter
        this.onSearchItem(this.searchLists[this.activeIdx], this.activeIdx);
      } else if (keyCode === 38) {
        //ä¸
        if (this.activeIdx === 0) return;
        this.activeIdx--;
        this.scrollToActiveSearch();
      } else if (keyCode === 40) {
        //ä¸
        if (this.activeIdx === this.searchLists.length - 1) return;
        this.activeIdx++;
        this.scrollToActiveSearch();
      }
    },
    onShowSearch: function onShowSearch() {
      var _this10 = this;

      this.isShowSearch = !this.isShowSearch;

      if (this.isShowSearch) {
        this.searchText = '';

        if (Object.prototype.toString.call(this.options) === '[object Array]') {
          this.searchLists = JSON.parse(JSON.stringify(this.options));
          this.activeIdx = this.options.findIndex(function (item) {
            return item[_this10.valueKey] === _this10.activeValue;
          });
        } else {
          var options = Object.entries(this.options).map(function (_ref3) {
            var _ref4 = slicedToArray(_ref3, 2),
                key = _ref4[0],
                value = _ref4[1];

            return {
              label: key,
              value: value
            };
          });
          this.searchLists = JSON.parse(JSON.stringify(options));
          this.activeIdx = options.findIndex(function (item) {
            return item[_this10.valueKey] === _this10.activeValue;
          });
        }

        NUI.nextTick(function () {
          _this10.$refs.search.focus();

          _this10.scrollToActiveSearch();
        });
      }
    }
  }
};

/* script */
var __vue_script__$6 = script$6;
/* template */

var __vue_render__$5 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "dynamic-tabs",
    class: _vm.typeClass,
    style: _vm.dynamicClass
  }, [_vm.scrollable && _vm.showNavigation ? _c('ui-icon', {
    staticClass: "icon dynamic-tabs_nav-prev",
    attrs: {
      "icon": "chevron_left"
    },
    on: {
      "click": _vm.scrollPrev
    }
  }) : _vm._e(), _vm._v(" "), _c('div', {
    ref: "rightModule",
    staticClass: "dynamic-tabs_nav-right",
    style: _vm.rightModuleClass
  }, [_c('div', {
    ref: "searchContainer",
    staticClass: "more-container"
  }, [_vm.scrollable ? _c('ui-icon', {
    staticClass: "icon more-icon",
    class: {
      'is-active': _vm.isShowSearch
    },
    attrs: {
      "icon": "more_horiz"
    },
    on: {
      "click": _vm.onShowSearch
    }
  }) : _vm._e(), _vm._v(" "), _vm.isShowSearch ? _c('div', {
    staticClass: "search-container",
    on: {
      "keydown": _vm.changeTab
    }
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.searchText,
      expression: "searchText"
    }, {
      name: "autofocus",
      rawName: "v-autofocus.dynamic",
      value: _vm.inputFocus,
      expression: "inputFocus",
      modifiers: {
        "dynamic": true
      }
    }],
    ref: "search",
    attrs: {
      "placeholder": "è¯·è¾å¥æç´¢å³é®å­",
      "clearable": ""
    },
    domProps: {
      "value": _vm.searchText
    },
    on: {
      "input": [function ($event) {
        if ($event.target.composing) {
          return;
        }

        _vm.searchText = $event.target.value;
      }, _vm.onChangeSearch],
      "blur": function blur($event) {
        _vm.inputFocus = false;
      }
    }
  }), _vm._v(" "), _vm.searchLists.length > 0 ? _c('ul', {
    staticClass: "search-lists",
    attrs: {
      "refs": "searchLists"
    }
  }, _vm._l(_vm.searchLists, function (item, i) {
    return _c('li', {
      key: i,
      staticClass: "search-item",
      class: {
        active: _vm.activeIdx === i
      },
      attrs: {
        "role": "tab"
      },
      on: {
        "click": function click($event) {
          return _vm.onSearchItem(item, i);
        }
      }
    }, [_c('div', {
      staticClass: "check-box"
    }, [_vm.activeValue === item[_vm.valueKey] ? _c('ui-icon', {
      staticStyle: {
        "color": "#409eff",
        "font-size": "14px"
      },
      attrs: {
        "icon": "check"
      }
    }) : _vm._e()], 1), _vm._v(" "), _c('p', [_vm._v(_vm._s(_vm.getLabel(item)))]), _vm._v(" "), item.hide ? _c('ui-icon', {
      attrs: {
        "icon": "visibility_off"
      }
    }) : _vm._e()], 1);
  }), 0) : _c('ul', {
    staticClass: "search-lists"
  }, [_c('li', {
    staticClass: "aligin-center"
  }, [_vm._v("æ²¡ææ°æ®")])])]) : _vm._e()], 1), _vm._v(" "), _vm.scrollable && _vm.showNavigation ? _c('ui-icon', {
    staticClass: "icon",
    attrs: {
      "icon": "chevron_right"
    },
    on: {
      "click": _vm.scrollNext
    }
  }) : _vm._e()], 1), _vm._v(" "), _c('div', {
    ref: "navScroll",
    staticClass: "dynamic-tabs_nav-scroll"
  }, [_c('Draggable', {
    ref: "nav",
    staticClass: "dynamic-tabs_nav",
    attrs: {
      "role": "tablist",
      "animation": "500",
      "list": _vm.options,
      "options": {
        draggable: '.draggableItem'
      }
    },
    on: {
      "end": _vm.draggableEnd
    }
  }, [_vm._l(_vm.options, function (item, i) {
    return [!item.hide ? _c('div', {
      key: i,
      staticClass: "dynamic-tag",
      class: {
        'is-active': _vm.checkIsAtv(item),
        'is-disabled': item.disabled,
        draggableItem: !item.disabled
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.onTagClick(item, i);
        }
      }
    }, [_vm._v("\n          " + _vm._s(_vm.getLabel(item)) + "\n          "), !item.disabled ? _c('ui-dropdown', {
      staticClass: "curtom-dropdown",
      attrs: {
        "type": "secondary",
        "color": "primary"
      }
    }, [_c('ui-menu', {
      directives: [{
        name: "close-popover",
        rawName: "v-close-popover"
      }],
      attrs: {
        "slot": "dropdown"
      },
      slot: "dropdown"
    }, [_c('ui-menu-item', {
      on: {
        "click": function click($event) {
          return _vm.onHideTag(item, i);
        }
      }
    }, [_vm._v("éè")]), _vm._v(" "), _c('ui-menu-item', {
      on: {
        "click": function click($event) {
          return _vm.onDelTag(item, i);
        }
      }
    }, [_vm._v("å é¤")])], 1), _vm._v(" "), _c('ui-icon', {
      staticClass: "icon-close",
      attrs: {
        "icon": "arrow_drop_down"
      }
    })], 1) : _vm._e()], 1) : _vm._e()];
  })], 2)], 1)], 1);
};

var __vue_staticRenderFns__$5 = [];
/* style */

var __vue_inject_styles__$6 = undefined;
/* scoped */

var __vue_scope_id__$6 = "data-v-1d2b8a5a";
/* module identifier */

var __vue_module_identifier__$6 = undefined;
/* functional template */

var __vue_is_functional_template__$6 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$6 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$5,
  staticRenderFns: __vue_staticRenderFns__$5
}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var instance$3 = axios.create({});
var script$5 = {
  name: 'ui-creative-material',
  props: {
    // axios baseUrl
    baseUrl: {
      type: String,
      default: 'http://lzh.3kwan.com/api/get_resources'
    },
    //è¯·æ±åæ°
    requestParams: {
      type: Object,
      default: {}
    },
    value: {
      type: Array,
      default: []
    },
    //éå¶å¯éç´ ææ°é
    maxNum: {
      type: Number,
      default: 10
    },
    //æ¯å¦æ¾ç¤ºå¼¹åºå±
    visible: {
      type: Boolean,
      default: false
    },
    showButton: {
      type: Boolean,
      default: true
    },
    showSuccess: {
      type: Boolean,
      default: true
    },
    showSuccessHeader: {
      type: Boolean,
      default: false
    },
    previewType: {
      type: String,
      default: '1'
    },
    maxHeight: {
      type: Number || String,
      default: 'auto'
    },
    width: {
      type: Number,
      default: 60
    },
    height: {
      type: Number,
      default: 35
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      lists: [],
      checkboxGroup: {},
      chooseData: [],
      loading: true,
      copyOrigin: {},
      successData: [],
      uncheckboxAllStatus: false,
      checkAllLeg: 0,
      otherNum: 0,
      btnText: ''
    };
  },
  components: {
    UiButton: __vue_component__$1v,
    UiModal: __vue_component__$1e,
    UiTabs: __vue_component__$C,
    UiMedia: __vue_component__$X,
    UiCheckbox: __vue_component__$1p,
    UiTextbox: __vue_component__$1r
  },
  created: function created() {
    this.setAxios();
  },
  mounted: function mounted() {
    var nOptions;

    if (this.value.length > 0) {
      nOptions = this.value.reduce(function (prev, cur) {
        if (cur.url != '' && cur.url != null && cur.url != undefined) {
          prev.push(cur);
        }

        return prev;
      }, []);
    }

    if (nOptions && nOptions.length > 0) {
      this.successData = JSON.parse(JSON.stringify(nOptions));

      if (this.visible) {
        this.openModel('material-model');
      }
    }
  },
  watch: {
    visible: function visible(val) {
      if (val) {
        this.openModel('material-model');
      }
    },
    value: function value(val) {
      var nOptions = val.reduce(function (prev, cur) {
        if (cur.url != '' && cur.url != null && cur.url != undefined) {
          prev.push(cur);
        }

        return prev;
      }, []);
      this.successData = JSON.parse(JSON.stringify(nOptions));
    }
  },
  methods: {
    /* å±ç¤ºåªä½èµæº */
    showMedia: function showMedia(type, src, title) {
      this.$message({
        mode: '',
        title: title || '',
        size: 'auto',
        content: function content(h) {
          return h(type, {
            ref: 'video' === type ? 'media' : '',
            attrs: {
              style: 'max-height: ' + ('video' === type ? '80vh' : '') + '; max-width: 80vw; object-fit: contain;',
              controls: true,
              src: src
            }
          });
        }
      }, {
        mounted: function mounted() {
          if (this.$refs.media && this.$refs.media.paused) {
            var fn = this.$refs.media.play();
            fn && fn.catch(function () {});
          }
        }
      }).catch(function () {});
    },
    getMediaType: function getMediaType(url) {
      if (url.indexOf('mp4') != -1) {
        return 'video';
      } else {
        return 'img';
      }
    },
    onCloseModal: function onCloseModal() {
      this.$emit('update:visible', false);
    },
    openModel: function openModel(ref) {
      this.$refs[ref].open();

      if (this.successData.length > 0) {
        this.chooseData = JSON.parse(JSON.stringify(this.successData));
      }

      this.getMediaDataByParams();
    },
    closeModal: function closeModal(ref) {
      this.$refs[ref].close();
      this.$emit('update:visible', false);
    },
    //è®¾ç½®axiosåæ°
    setAxios: function setAxios() {
      //è®¾ç½®baseUrl
      instance$3.defaults.baseURL = this.baseUrl;
    },
    axiosApi: function axiosApi(src, params) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        instance$3.get(src, {
          params: params
        }).then(function (res) {
          resolve(res.data);
        }).catch(function () {
          reject();
        });
        instance$3.interceptors.response.use(function (response) {
          var res = response.data;

          if (res == '') {
            _this.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');

            return reject();
          }

          if (res['code'] != 0) {
            _this.$toast(res.msg);

            return reject();
          }

          return response;
        }, function (error) {
          this.$toast('è¯·æ±å¤±è´¥ï¼è¯·æ£æ¥ç½ç»åéè¯');
          return reject(error);
        });
      });
    },
    getMediaDataByType: function getMediaDataByType() {
      var _this2 = this;

      var extParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var params, _yield$_this2$axiosAp, code, data, msg;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this2.uncheckboxAllStatus = false;
                _this2.checkAllLeg = 0;
                params = _objectSpread$4(_objectSpread$4({}, _this2.requestParams), extParams);
                _context.next = 5;
                return _this2.axiosApi(_this2.baseUrl, params);

              case 5:
                _yield$_this2$axiosAp = _context.sent;
                code = _yield$_this2$axiosAp.code;
                data = _yield$_this2$axiosAp.data;
                msg = _yield$_this2$axiosAp.msg;

                if (!(code && code != 0)) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return", _this2.$toast(msg));

              case 11:
                _this2.$set(_this2, 'lists', data.list);

                _this2.checkboxGroup = {};

                _this2.lists.map(function (item) {
                  _this2.checkboxGroup[item.id] = false;
                });

                setTimeout(function () {
                  _this2.$nextTick(function () {
                    _this2.initChooseStatus();
                  });
                }, 1);
                _this2.loading = false;

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    initChooseStatus: function initChooseStatus() {
      var _this3 = this;

      if (this.chooseData.length != 0) {
        this.lists.map(function (item) {
          var index = _this3.chooseData.findIndex(function (value) {
            return value.id == item.id;
          });

          if (index != -1) {
            _this3.checkAllLeg++;
          }
        });
        this.chooseData.forEach(function (item) {
          for (var prop in _this3.checkboxGroup) {
            if (_this3.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
              _this3.checkboxGroup[item.id] = true;
            }
          }
        });
      }
    },
    handleUnCheckAllChange: function handleUnCheckAllChange() {
      var _this4 = this;

      if (this.lists.length > this.maxNum) {
        this.$toast({
          type: 'warning',
          message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
        });
        return false;
      }

      this.uncheckboxAllStatus = true;
      this.lists.map(function (item) {
        var index = _this4.chooseData.findIndex(function (value) {
          return value.id == item.id;
        });

        if (index != -1) {
          _this4.chooseData.splice(index, 1);

          _this4.checkAllLeg--;
        } else {
          _this4.chooseData.push(item);
        }

        for (var prop in _this4.checkboxGroup) {
          if (_this4.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
            _this4.checkboxGroup[item.id] = !_this4.checkboxGroup[item.id];
          }
        }
      });
    },
    handleOtherNum: function handleOtherNum() {
      var _this5 = this;

      return new Promise(function (resolve) {
        _this5.otherNum = 0;
        _this5.chooseData.length > 0 && _this5.chooseData.map(function (item, i) {
          var index = _this5.lists.findIndex(function (value) {
            return value.id == item.id;
          });

          if (index == -1) {
            _this5.otherNum++;
          }
        });
        resolve();
      });
    },
    handleCheckAllChange: function handleCheckAllChange() {
      var _this6 = this;

      return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this6.handleOtherNum();

              case 2:
                if (!(_this6.lists.length + _this6.otherNum > _this6.maxNum)) {
                  _context2.next = 5;
                  break;
                }

                _this6.$toast({
                  type: 'warning',
                  message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(_this6.maxNum, "\u6761\u7D20\u6750")
                });

                return _context2.abrupt("return", false);

              case 5:
                _this6.checkAllLeg = _this6.lists.length;
                _this6.uncheckboxAllStatus = false;

                _this6.lists.map(function (item) {
                  var index = _this6.chooseData.findIndex(function (value) {
                    return value.id == item.id;
                  });

                  if (index == -1) {
                    _this6.chooseData.push(item);
                  }

                  _this6.chooseData.map(function (item) {
                    _this6.checkboxGroup[item.id] = true;
                  });
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    handleCheckChange: function handleCheckChange(item) {
      var index = this.chooseData.findIndex(function (value) {
        return value.id == item.id;
      });

      if (index == -1) {
        if (this.chooseData.length < this.maxNum) {
          this.checkAllLeg++;
          this.chooseData.push(item);
        } else {
          this.$toast({
            type: 'warning',
            message: "\u6700\u591A\u53EA\u5141\u8BB8\u9009\u62E9".concat(this.maxNum, "\u6761\u7D20\u6750")
          });

          for (var prop in this.checkboxGroup) {
            if (this.checkboxGroup.hasOwnProperty(prop) && prop === item.id) {
              this.checkboxGroup[item.id] = false;
            }
          }

          return false;
        }
      } else {
        this.checkAllLeg--;
        this.chooseData.splice(index, 1);
      }
    },
    getMediaDataByParams: function getMediaDataByParams() {
      this.getMediaDataByType(_objectSpread$4({}, this.requestParams));
    },
    clearChoose: function clearChoose() {
      this.checkAllLeg = 0;
      this.chooseData = [];

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key)) {
          this.checkboxGroup[key] = false;
        }
      }
    },
    clearAll: function clearAll() {
      this.clearSuccess();
    },
    clearSuccess: function clearSuccess() {
      this.chooseData = this.successData = [];

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key)) {
          this.checkboxGroup[key] = false;
        }
      }

      this.$emit('success', this.successData);
      this.$emit('input', this.successData);
      this.$emit('change', this.successData);
    },
    clearItem: function clearItem(id) {
      this.delSuccessChoose(id);
    },
    delSuccessChoose: function delSuccessChoose(id) {
      var _this7 = this;

      this.delChoose(id);
      this.successData.length > 0 && this.successData.forEach(function (item, i) {
        if (item.id == id) {
          _this7.successData.splice(i, 1);

          _this7.$emit('success', _this7.successData);

          _this7.$emit('input', _this7.successData);

          _this7.$emit('change', _this7.successData);
        }
      });
    },
    delChoose: function delChoose(id) {
      var _this8 = this;

      this.lists.map(function (item) {
        if (id == item.id) {
          _this8.checkAllLeg--;
        }
      });

      for (var key in this.checkboxGroup) {
        if (Object.hasOwnProperty.call(this.checkboxGroup, key) && key == id) {
          this.checkboxGroup[key] = false;
        }
      }

      this.chooseData.length > 0 && this.chooseData.forEach(function (item, i) {
        if (item.id == id) {
          _this8.chooseData.splice(i, 1);
        }
      });
    },
    save: function save() {
      this.$emit('success', this.chooseData);
      this.$emit('input', this.chooseData);
      this.$emit('change', this.chooseData);
      this.successData = JSON.parse(JSON.stringify(this.chooseData));
      this.$refs['material-model'].close();
    }
  }
};

var __vue_script__$5 = script$5;
/* template */

var __vue_render__$4 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-creative-material"
  }, [_vm.previewType == 2 ? [_vm.successData.length > 0 ? _c('div', {
    staticClass: "preview-2"
  }, _vm._l(_vm.successData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "preview-item"
    }, [_c('ui-media', {
      attrs: {
        "width": _vm.width,
        "height": _vm.height,
        "type": _vm.getMediaType(choose.url),
        "hover-effect": "popover",
        "src": choose.url,
        "background-color": "#f1f1f1"
      },
      on: {
        "click": function click($event) {
          !_vm.disabled && _vm.openModel('material-model');
        }
      }
    }), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.name,
        expression: "choose.name"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n          " + _vm._s(choose.name) + "\n        ")])], 1);
  }), 0) : _vm.successData.length == 0 && _vm.showButton ? _c('div', {
    staticClass: "preview-2-btn",
    class: {
      disabled: _vm.disabled
    },
    style: {
      width: _vm.width + 'px'
    },
    on: {
      "click": function click($event) {
        !_vm.disabled && _vm.openModel('material-model');
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "add"
    }
  })], 1) : _vm._e()] : [_vm.showSuccess ? _c('div', {
    staticClass: "ui-batch-material-box check-content"
  }, [_vm.showSuccessHeader ? _c('div', {
    staticClass: "header d-flex"
  }, [_c('h2', [_vm._v("\n          ä¸ä¼ ç´ æ"), _c('span', [_vm._v(_vm._s(_vm.successData.length) + "/" + _vm._s(_vm.maxNum))])]), _vm._v(" "), _c('ui-button', {
    staticClass: "btn-clear btn-clear1",
    attrs: {
      "type": "secondary",
      "color": "red"
    },
    on: {
      "click": _vm.clearSuccess
    }
  }, [_vm._v("æ¸ç©º")])], 1) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "success-choose-box",
    style: {
      'max-height': _vm.maxHeight == 'auto' ? 'none' : _vm.maxHeight + "px"
    }
  }, [_vm.successData.length > 0 ? [_vm._l(_vm.successData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "grid-item",
      style: {
        width: _vm.width + 'px'
      }
    }, [_c('ui-media', {
      attrs: {
        "width": _vm.width,
        "height": _vm.height,
        "type": _vm.getMediaType(choose.url),
        "hover-effect": "popover",
        "src": choose.url
      },
      on: {
        "click": function click($event) {
          _vm.showMedia(_vm.getMediaType(choose.url), choose.url);
        }
      }
    }), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.name,
        expression: "choose.name"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n              " + _vm._s(choose.name) + "\n            ")]), _vm._v(" "), !choose.isFixed && !_vm.disabled ? _c('div', {
      staticClass: "del",
      on: {
        "click": function click($event) {
          return _vm.delSuccessChoose(choose.id);
        }
      }
    }, [_c('a', [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1)]) : _vm._e()], 1);
  }), _vm._v(" "), _vm.showButton ? _c('div', {
    staticClass: "preview-2-btn",
    class: {
      disabled: _vm.disabled
    },
    style: {
      width: _vm.width + 'px',
      height: Number(_vm.height) + 25 + 'px'
    },
    on: {
      "click": function click($event) {
        !_vm.disabled && _vm.openModel('material-model');
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "add"
    }
  })], 1) : _vm._e()] : _vm.successData.length == 0 && _vm.showButton ? _c('div', {
    staticClass: "preview-2-btn",
    style: {
      width: _vm.width + 'px',
      height: Number(_vm.height) + 25 + 'px'
    },
    on: {
      "click": function click($event) {
        return _vm.openModel('material-model');
      }
    }
  }, [_c('ui-icon', {
    attrs: {
      "icon": "add"
    }
  })], 1) : _vm._e()], 2)]) : _vm._e()], _vm._v(" "), _c('ui-modal', {
    ref: "material-model",
    attrs: {
      "title": "è¯·éæ©",
      "size": "large"
    },
    on: {
      "close": _vm.onCloseModal
    }
  }, [_c('div', {
    staticClass: "container d-flex"
  }, [_c('div', {
    staticClass: "content"
  }, [!_vm.loading ? _c('div', [_vm.lists.length > 0 ? [_c('div', {
    staticClass: "checkbox-all"
  }, [_c('ui-checkbox', {
    staticClass: "ui-mb-1",
    attrs: {
      "indeterminate": _vm.checkAllLeg > 0 && _vm.checkAllLeg < _vm.lists.length,
      "value": _vm.checkAllLeg == _vm.lists.length
    },
    on: {
      "change": _vm.handleCheckAllChange
    }
  }, [_vm._v("å¨é")])], 1), _vm._v(" "), _c('div', {
    staticClass: "ui-grid checkbox-group"
  }, _vm._l(_vm.lists, function (item, i) {
    return _c('div', {
      key: i,
      staticClass: "\n                  ui-grid-cell\n                  col-4\n                  ui-text-truncate\n                  check-item\n                  grid-item grid-item1\n                "
    }, [_c('ui-checkbox', {
      attrs: {
        "disabled": item.isFixed
      },
      on: {
        "change": function change($event) {
          return _vm.handleCheckChange(item);
        }
      },
      model: {
        value: _vm.checkboxGroup[item.id],
        callback: function callback($$v) {
          _vm.$set(_vm.checkboxGroup, item.id, $$v);
        },
        expression: "checkboxGroup[item.id]"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "100%",
        "height": "90",
        "type": _vm.getMediaType(item.url),
        "hover-effect": "popover",
        "src": item.url
      }
    }), _vm._v(" "), _c('p', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: item.name,
        expression: "item.name"
      }],
      staticClass: "ui-text-truncate",
      on: {
        "click": function click($event) {
          _vm.showMedia(_vm.getMediaType(item.url), item.url);
        }
      }
    }, [_vm._v("\n                    " + _vm._s(item.name) + "\n                  ")])], 1)], 1);
  }), 0)] : _c('div', {
    staticClass: "ui-batch__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1)], 2) : _c('div', {
    directives: [{
      name: "loading",
      rawName: "v-loading",
      value: _vm.loading,
      expression: "loading"
    }],
    staticClass: "stripe",
    staticStyle: {
      "height": "300px"
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "check-content"
  }, [_c('div', {
    staticClass: "header d-flex"
  }, [_c('h2', [_vm._v("\n            å·²éæ©"), _c('span', [_vm._v(_vm._s(_vm.chooseData.length) + "/" + _vm._s(_vm.maxNum))])]), _vm._v(" "), _c('ui-button', {
    staticClass: "btn-clear",
    attrs: {
      "type": "secondary",
      "color": "red"
    },
    on: {
      "click": _vm.clearChoose
    }
  }, [_vm._v("æ¸ç©º")])], 1), _vm._v(" "), _c('div', {
    staticClass: "choose-box ui-grid"
  }, [_vm.chooseData.length > 0 ? _vm._l(_vm.chooseData, function (choose, i) {
    return _c('div', {
      key: i,
      staticClass: "ui-grid-cell grid-item grid-item1",
      staticStyle: {
        "width": "76px"
      }
    }, [_c('ui-media', {
      attrs: {
        "width": "auto",
        "height": "50",
        "type": _vm.getMediaType(choose.url),
        "hover-effect": "popover",
        "src": choose.url
      },
      on: {
        "click": function click($event) {
          _vm.showMedia(_vm.getMediaType(choose.url), choose.url);
        }
      }
    }), _vm._v(" "), _c('div', {
      directives: [{
        name: "tooltip",
        rawName: "v-tooltip",
        value: choose.name,
        expression: "choose.name"
      }],
      staticClass: "name ui-text-truncate"
    }, [_vm._v("\n                " + _vm._s(choose.name) + "\n              ")]), _vm._v(" "), !choose.isFixed ? _c('div', {
      staticClass: "del",
      on: {
        "click": function click($event) {
          return _vm.delChoose(choose.id);
        }
      }
    }, [_c('a', [_c('ui-icon', {
      attrs: {
        "icon": "close"
      }
    })], 1)]) : _vm._e()], 1);
  }) : _c('div', {
    staticClass: "ui-batch__empty"
  }, [_c('ui-icon', [_c('svg', {
    attrs: {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41",
      "xmlns": "http://www.w3.org/2000/svg"
    }
  }, [_c('g', {
    attrs: {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }
  }, [_c('ellipse', {
    attrs: {
      "fill": "#f5f5f5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }
  }), _vm._v(" "), _c('g', {
    attrs: {
      "stroke": "#d9d9d9",
      "fill-rule": "nonzero"
    }
  }, [_c('path', {
    attrs: {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }
  }), _vm._v(" "), _c('path', {
    attrs: {
      "fill": "#fafafa",
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z"
    }
  })])])])]), _vm._v(" "), _c('p', {
    staticClass: "ui-batch__empty-text"
  }, [_vm._v("ææ æ°æ®")])], 1)], 2)])]), _vm._v(" "), _c('div', {
    attrs: {
      "slot": "footer"
    },
    slot: "footer"
  }, [_c('ui-button', {
    attrs: {
      "raised": ""
    },
    on: {
      "click": function click($event) {
        return _vm.closeModal('material-model');
      }
    }
  }, [_vm._v("åæ¶")]), _vm._v(" "), _c('ui-button', {
    attrs: {
      "color": "primary",
      "raised": ""
    },
    on: {
      "click": _vm.save
    }
  }, [_vm._v("ç¡®å®")])], 1)])], 2);
};

var __vue_staticRenderFns__$4 = [];
/* style */

var __vue_inject_styles__$5 = undefined;
/* scoped */

var __vue_scope_id__$5 = undefined;
/* module identifier */

var __vue_module_identifier__$5 = undefined;
/* functional template */

var __vue_is_functional_template__$5 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$5 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$4,
  staticRenderFns: __vue_staticRenderFns__$4
}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

//
var script$4 = {
  name: 'ui-textbox-group',
  components: {
    UiTextbox: __vue_component__$1r
  },
  props: {
    label: {
      type: String,
      default: ''
    },
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    floatingLabel: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      isActive: false,
      minValue: '',
      maxValue: '',
      warning: ''
    };
  },
  watch: {
    value: {
      handler: function handler(val) {
        var isArr = NUI.$tools.rule.array(val);

        if (isArr && val.length > 0) {
          this.minValue = val.slice(0, 1)[0];
          this.maxValue = val.slice(1, 2)[0];
        }
      },
      immediate: true,
      deep: true
    }
  },
  computed: {
    classes: function classes() {
      return {
        'is-active': this.isActive
      };
    },
    placeholderText: function placeholderText() {
      var minText = "".concat(this.label, "\u6700\u5C0F\u503C");
      var maxText = "".concat(this.label, "\u6700\u5927\u503C");
      return {
        min: minText,
        max: maxText
      };
    }
  },
  methods: {
    onFocus: function onFocus() {
      this.isActive = true;
    },
    onBlur: function onBlur() {
      this.isActive = false;
    },
    onMinValueUpdate: function onMinValueUpdate(newValue) {
      // const parsedValue = this.parseValue(newValue)
      // if (parsedValue >= this.value[1]) {
      //   this.warning = 'æå°å¼ä¸è½å¤§äºæå¤§å¼'
      // }
      this.$set(this.value, 0, newValue);
      this.$emit('input', this.value);
    },
    onMaxValueUpdate: function onMaxValueUpdate(newValue) {
      // const parsedValue = this.parseValue(newValue)
      // if (parsedValue <= this.value[0]) {
      //   this.warning = 'æå¤§å¼ä¸è½å°äºæå°å¼'
      // }
      this.$set(this.value, 1, newValue);
      this.$emit('input', this.value);
    },
    parseValue: function parseValue(value) {
      var parsed = parseFloat(value);
      return isNaN(parsed) ? NaN : parsed;
    }
  }
};

/* script */
var __vue_script__$4 = script$4;
/* template */

var __vue_render__$3 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-textbox-group-container"
  }, [_c('div', {
    staticClass: "ui-textbox-group",
    class: _vm.classes
  }, [_c('ui-textbox', {
    attrs: {
      "type": "number",
      "placeholder": _vm.placeholderText.min,
      "label": _vm.placeholderText.min,
      "floatingLabel": _vm.floatingLabel
    },
    on: {
      "focus": _vm.onFocus,
      "blur": _vm.onBlur,
      "input": _vm.onMinValueUpdate
    },
    model: {
      value: _vm.minValue,
      callback: function callback($$v) {
        _vm.minValue = $$v;
      },
      expression: "minValue"
    }
  }), _vm._v(" "), _c('span', [_vm._v("~")]), _vm._v(" "), _c('ui-textbox', {
    attrs: {
      "type": "number",
      "placeholder": _vm.placeholderText.max,
      "label": _vm.placeholderText.max,
      "floatingLabel": _vm.floatingLabel
    },
    on: {
      "focus": _vm.onFocus,
      "blur": _vm.onBlur,
      "input": _vm.onMaxValueUpdate
    },
    model: {
      value: _vm.maxValue,
      callback: function callback($$v) {
        _vm.maxValue = $$v;
      },
      expression: "maxValue"
    }
  })], 1), _vm._v(" "), _vm.warning != '' ? _c('div', {
    staticClass: "warning"
  }, [_vm._v(_vm._s(_vm.warning))]) : _vm._e()]);
};

var __vue_staticRenderFns__$3 = [];
/* style */

var __vue_inject_styles__$4 = undefined;
/* scoped */

var __vue_scope_id__$4 = "data-v-5c008070";
/* module identifier */

var __vue_module_identifier__$4 = undefined;
/* functional template */

var __vue_is_functional_template__$4 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$4 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$3 = {
  name: 'ui-media-carousel',
  props: {
    src: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    audio: {
      type: String,
      default: ''
    },
    play: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      url: '',
      currentIndex: 0,
      swiperOptions: {
        slidesPerView: 1,
        centeredSlides: true,
        loop: false,
        spaceBetween: 0,
        initialSlide: 0,
        speed: 300,
        preventClicks: false,
        preventClicksPropagation: false,
        threshold: 5,
        touchStartPreventDefault: false,
        allowTouchMove: true,
        simulateTouch: true,
        touchRatio: 1,
        autoplay: {
          delay: 3000,
          disableOnInteraction: false,
          stopOnLastSlide: true
        },
        pagination: {
          el: '.custom-pagination',
          type: 'custom',
          clickable: true
        },
        navigation: false,
        observer: true,
        observeParents: true,
        resistanceRatio: 0,
        watchOverflow: true,
        watchSlidesProgress: true,
        on: {
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.$el[0].__vue__) {
              var vm = swiper.$el[0].__vue__.$parent;
              vm.currentIndex = swiper.activeIndex;
              vm.scrollThumbIntoView(swiper.activeIndex);
            }
          },
          init: function init() {
            if (this.$el[0].__vue__) {
              var vm = this.$el[0].__vue__.$parent;
              vm.currentIndex = 0;
            }
          }
        }
      },
      userActivated: false,
      audioInstance: null
    };
  },
  watch: {
    src: {
      handler: function handler(val) {
        var _this = this;

        this.url = toConsumableArray(val);
        this.$nextTick(function () {
          _this.resetSwiper();

          _this.stopPlay();
        });
      },
      deep: true,
      immediate: true
    },
    audio: function audio(val) {
      this.$refs.bgm.src = val;
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.initSwiper();
    NUI.nextTick(function () {
      _this2.stopPlay();

      if (_this2.play) {
        _this2.playAudio();
      }
    });
  },
  methods: {
    initSwiper: function initSwiper() {
      var _this3 = this;

      this.$nextTick(function () {
        if (_this3.$refs.mySwiper && _this3.$refs.mySwiper.$swiper) {
          _this3.$refs.mySwiper.$swiper.update();
        }
      });
    },
    resetSwiper: function resetSwiper() {
      this.initSwiper();
      this.stopPlay();
      var audioInstance = this.$refs.bgm;
      audioInstance.setAttribute('src', this.audio);
      audioInstance.load();
      audioInstance.play();
    },
    handleUserInteraction: function handleUserInteraction() {
      if (!this.userActivated) {
        this.userActivated = true;
        this.$refs.bgm.muted = false;
        this.playAudio();
      }
    },
    scrollThumbIntoView: function scrollThumbIntoView(index) {
      var _this4 = this;

      this.$nextTick(function () {
        var pagination = _this4.$el.querySelector('.custom-pagination');

        var thumbItem = _this4.$el.querySelector(".thumb-item:nth-child(".concat(index, ")"));

        if (pagination && thumbItem) {
          var paginationRect = pagination.getBoundingClientRect();
          var thumbRect = thumbItem.getBoundingClientRect();
          var scrollLeft = pagination.scrollLeft + (thumbRect.left - paginationRect.left) - (paginationRect.width - thumbRect.width) / 2;
          pagination.scrollTo({
            left: scrollLeft,
            behavior: 'smooth'
          });
        }
      });
    },
    slideTo: function slideTo(index) {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper.slideTo(index);
        this.currentIndex = index;
        this.scrollThumbIntoView(index);
      }
    },
    prevSlide: function prevSlide() {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper;

        if (this.currentIndex > 0) {
          this.slideTo(this.currentIndex - 1);
        }
      }
    },
    nextSlide: function nextSlide() {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper;

        if (this.currentIndex < this.src.length - 1) {
          this.slideTo(this.currentIndex + 1);
        }
      }
    },
    playAudio: function playAudio() {
      var audioInstance = this.$refs.bgm;
      audioInstance.setAttribute('src', this.audio);
      audioInstance.load();
      audioInstance.play();
    },
    stopPlay: function stopPlay() {
      var media = this.$refs.bgm;
      media.currentTime = 0;
      media.removeAttribute('src');
      media.load();
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
      this.$refs.mySwiper.$swiper.destroy();
    }

    this.stopPlay();
  }
};

/* script */
var __vue_script__$3 = script$3;
/* template */

var __vue_render__$2 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-media-carousel",
    on: {
      "click": _vm.handleUserInteraction,
      "touchstart": _vm.handleUserInteraction
    }
  }, [_c('div', {
    staticClass: "posi"
  }, [_vm._v(_vm._s(_vm.src.length) + "å¼ ")]), _vm._v(" "), _c('swiper', {
    ref: "mySwiper",
    staticClass: "swiper-container",
    staticStyle: {
      "width": "100%",
      "overflow": "hidden"
    },
    attrs: {
      "options": _vm.swiperOptions
    }
  }, [_vm._l(_vm.src, function (image, index) {
    return _c('swiper-slide', {
      key: index,
      staticClass: "swiper-slide",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "display": "flex",
        "align-items": "center",
        "justify-content": "center"
      }
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain",
        "flex-shrink": "0"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  }), _vm._v(" "), _c('div', {
    staticClass: "custom-pagination",
    attrs: {
      "slot": "pagination"
    },
    slot: "pagination"
  }, _vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "thumb-item",
      class: {
        active: _vm.currentIndex === index
      },
      on: {
        "click": function click($event) {
          return _vm.slideTo(index);
        }
      }
    });
  }), 0), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-prev",
    attrs: {
      "slot": "button-prev"
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.prevSlide($event);
      }
    },
    slot: "button-prev"
  }), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-next",
    attrs: {
      "slot": "button-next"
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.nextSlide($event);
      }
    },
    slot: "button-next"
  })], 2), _vm._v(" "), _c('audio', {
    ref: "bgm",
    attrs: {
      "muted": "",
      "preload": "auto",
      "src": _vm.audio
    }
  })], 1);
};

var __vue_staticRenderFns__$2 = [];
/* style */

var __vue_inject_styles__$3 = undefined;
/* scoped */

var __vue_scope_id__$3 = undefined;
/* module identifier */

var __vue_module_identifier__$3 = undefined;
/* functional template */

var __vue_is_functional_template__$3 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$3 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var script$2 = {
  name: 'ui-media-group',
  props: {
    src: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    play: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      url: '',
      currentIndex: 0,
      swiperOptions: {
        slidesPerView: 1,
        centeredSlides: true,
        loop: false,
        spaceBetween: 0,
        initialSlide: 0,
        speed: 300,
        preventClicks: false,
        preventClicksPropagation: false,
        threshold: 5,
        touchStartPreventDefault: false,
        allowTouchMove: false,
        simulateTouch: false,
        touchRatio: 0,
        pagination: {
          el: '.custom-pagination',
          type: 'custom',
          clickable: true
        },
        navigation: false,
        observer: true,
        observeParents: true,
        resistanceRatio: 0,
        watchOverflow: true,
        watchSlidesProgress: true,
        on: {
          slideChange: function slideChange() {
            var swiper = this;

            if (swiper.$el[0].__vue__) {
              var vm = swiper.$el[0].__vue__.$parent;
              vm.currentIndex = swiper.activeIndex;
              vm.scrollThumbIntoView(swiper.activeIndex);
            }
          },
          init: function init() {
            if (this.$el[0].__vue__) {
              var vm = this.$el[0].__vue__.$parent;
              vm.currentIndex = 0;
            }
          }
        }
      },
      userActivated: false
    };
  },
  watch: {
    src: {
      handler: function handler(val) {
        var _this = this;

        this.url = toConsumableArray(val);
        this.$nextTick(function () {
          _this.resetSwiper();
        });
      },
      deep: true,
      immediate: true
    }
  },
  mounted: function mounted() {
    this.initSwiper();
  },
  methods: {
    numberToChinese: function numberToChinese(num) {
      var chineseNumbers = ['é¶', 'ä¸', 'äº', 'ä¸', 'å', 'äº', 'å­', 'ä¸', 'å«', 'ä¹', 'å'];
      if (num <= 10) return chineseNumbers[num];
      if (num < 20) return 'å' + (num % 10 === 0 ? '' : chineseNumbers[num % 10]);
      var tens = Math.floor(num / 10);
      return chineseNumbers[tens] + 'å' + (num % 10 === 0 ? '' : chineseNumbers[num % 10]);
    },
    initSwiper: function initSwiper() {
      var _this2 = this;

      this.$nextTick(function () {
        if (_this2.$refs.mySwiper && _this2.$refs.mySwiper.$swiper) {
          _this2.$refs.mySwiper.$swiper.update();
        }
      });
    },
    resetSwiper: function resetSwiper() {
      this.initSwiper();
    },
    handleUserInteraction: function handleUserInteraction() {
      if (!this.userActivated) {
        this.userActivated = true;
      }
    },
    scrollThumbIntoView: function scrollThumbIntoView(index) {
      var _this3 = this;

      this.$nextTick(function () {
        var pagination = _this3.$el.querySelector('.custom-pagination');

        var thumbItem = _this3.$el.querySelector(".thumb-item:nth-child(".concat(index + 1, ")"));

        if (pagination && thumbItem) {
          var paginationRect = pagination.getBoundingClientRect();
          var thumbRect = thumbItem.getBoundingClientRect();
          var scrollLeft = pagination.scrollLeft + (thumbRect.left - paginationRect.left) - (paginationRect.width - thumbRect.width) / 2;
          pagination.scrollTo({
            left: scrollLeft,
            behavior: 'smooth'
          });
        }
      });
    },
    slideTo: function slideTo(index) {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper.slideTo(index);
        this.currentIndex = index;
        this.scrollThumbIntoView(index);
      }
    },
    prevSlide: function prevSlide() {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper;

        if (this.currentIndex > 0) {
          this.slideTo(this.currentIndex - 1);
        }
      }
    },
    nextSlide: function nextSlide() {
      if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
        this.$refs.mySwiper.$swiper;

        if (this.currentIndex < this.src.length) {
          this.slideTo(this.currentIndex + 1);
        }
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$refs.mySwiper && this.$refs.mySwiper.$swiper) {
      this.$refs.mySwiper.$swiper.destroy();
    }
  }
};

/* script */
var __vue_script__$2 = script$2;
/* template */

var __vue_render__$1 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "ui-media-group",
    on: {
      "click": _vm.handleUserInteraction,
      "touchstart": _vm.handleUserInteraction
    }
  }, [_c('div', {
    staticClass: "posi"
  }, [_vm._v("1:1(" + _vm._s(_vm.numberToChinese(_vm.src.length)) + "å¾)")]), _vm._v(" "), _c('swiper', {
    ref: "mySwiper",
    staticClass: "swiper-container",
    staticStyle: {
      "width": "100%",
      "overflow": "hidden"
    },
    attrs: {
      "options": _vm.swiperOptions
    }
  }, [_c('swiper-slide', [_c('div', {
    staticClass: "all-image-grid",
    class: 'grid-' + _vm.src.length
  }, [_vm.src.length === 3 ? [_vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "all-image-grid-item"
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  }), _vm._v(" "), _c('div', {
    staticClass: "all-image-grid-item empty"
  })] : _vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "all-image-grid-item"
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  })], 2)]), _vm._v(" "), _vm._l(_vm.src, function (image, index) {
    return _c('swiper-slide', {
      key: index,
      staticClass: "swiper-slide",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "display": "flex",
        "align-items": "center",
        "justify-content": "center"
      }
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain",
        "flex-shrink": "0"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  }), _vm._v(" "), _c('div', {
    staticClass: "custom-pagination",
    attrs: {
      "slot": "pagination"
    },
    slot: "pagination"
  }, [_c('div', {
    staticClass: "thumb-item",
    class: {
      active: _vm.currentIndex === 0
    },
    on: {
      "click": function click($event) {
        return _vm.slideTo(0);
      }
    }
  }, [_c('div', {
    staticClass: "all-image-grid",
    class: 'grid-' + _vm.src.length
  }, [_vm.src.length === 3 ? [_vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "all-image-grid-item"
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  }), _vm._v(" "), _c('div', {
    staticClass: "all-image-grid-item empty"
  })] : _vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "all-image-grid-item"
    }, [_c('img', {
      staticClass: "swiper-image",
      staticStyle: {
        "width": "100%",
        "height": "100%",
        "object-fit": "contain"
      },
      attrs: {
        "loading": "lazy",
        "src": image
      }
    })]);
  })], 2)]), _vm._v(" "), _vm._l(_vm.src, function (image, index) {
    return _c('div', {
      key: index,
      staticClass: "thumb-item",
      class: {
        active: _vm.currentIndex === index + 1
      },
      on: {
        "click": function click($event) {
          return _vm.slideTo(index + 1);
        }
      }
    }, [_c('img', {
      attrs: {
        "src": image,
        "alt": "ç¼©ç¥å¾ " + (index + 1)
      }
    })]);
  })], 2), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-prev",
    attrs: {
      "slot": "button-prev"
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.prevSlide($event);
      }
    },
    slot: "button-prev"
  }), _vm._v(" "), _c('div', {
    staticClass: "swiper-button-next",
    attrs: {
      "slot": "button-next"
    },
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.nextSlide($event);
      }
    },
    slot: "button-next"
  })], 2)], 1);
};

var __vue_staticRenderFns__$1 = [];
/* style */

var __vue_inject_styles__$2 = undefined;
/* scoped */

var __vue_scope_id__$2 = undefined;
/* module identifier */

var __vue_module_identifier__$2 = undefined;
/* functional template */

var __vue_is_functional_template__$2 = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$2 = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

var instance$2 = 'v-drag';
var DDrag = {
  bind: function bind(el, _ref) {
    var value = _ref.value,
        modifiers = _ref.modifiers;
    var drag = new Drag(el, modifiers.touch);
    el[instance$2] = drag; // el[instance].disabled = value === false;

    Object.assign(el.style, {
      position: modifiers.fixed ? 'fixed' : 'absolute',
      zIndex: 9,
      cursor: 'grab'
    });
    var offset = {};
    var targetRect = null;

    var updatePos = function updatePos(pos, draging) {
      var x = pos.x,
          y = pos.y;
      var boundingRect = 'string' === typeof value ? document.querySelector(value) && document.querySelector(value).getBoundingClientRect() : value;

      if (boundingRect && targetRect) {
        // è¶åºå·¦è¾¹ç
        if (x + targetRect.left < boundingRect.left) x = boundingRect.left - targetRect.left; // è¶åºå³è¾¹ç
        else if (x + targetRect.right > boundingRect.right) x = boundingRect.right - targetRect.right; // è¶åºä¸è¾¹ç

        if (y + targetRect.top < boundingRect.top) y = boundingRect.top - targetRect.top; // è¶åºä¸è¾¹ç
        else if (y + targetRect.bottom > boundingRect.bottom) y = boundingRect.bottom - targetRect.bottom;
      }

      Object.assign(el.style, {
        left: numToPx(x + offset.x),
        top: numToPx(y + offset.y),
        userSelect: draging ? 'none' : 'auto',
        cursor: draging ? 'grabbing' : 'grab'
      });
    };

    drag.start(function (pos, e) {
      targetRect = el.getBoundingClientRect();
      offset = {
        x: el.offsetLeft,
        y: el.offsetTop
      };
      Object.assign(el.style, {
        cursor: 'grabbing'
      });
    });
    drag.drag(function (pos) {
      return updatePos(pos, true);
    });
    drag.end(function (pos) {
      return updatePos(pos, false);
    });
  },

  /* update: function (el, { value, modifiers }) {
    el[instance].disabled = value === false;
  }, */
  unbind: function unbind(el) {
    if (el[instance$2]) el[instance$2].destory();
  }
};

function getComponent(el, componentName) {
  var parent = el.parentNode;

  while (parent) {
    var componentInstance = parent.__vue__;

    if (componentInstance && componentInstance.$options.componentName === componentName) {
      return componentInstance;
    }

    parent = parent.parentNode;
  }

  return null;
}

function getEvents(modifiers) {
  var events = Object.keys(modifiers);
  return events.length > 0 ? events : ['input'];
}

function addEvents(el, type, handler) {
  if (el.__vue__) el.__vue__.$on(type, handler.bind(el.__vue__));else el.addEventListener(type, handler.bind(el));
}

function removeEvents(el, type, handler) {
  if (el.__vue__) el.__vue__.$off(type, handler);else el.removeEventListener(type, handler);
}

var DForm = {
  inserted: function inserted(el, _ref, vnode) {
    var modifiers = _ref.modifiers,
        _ref$value = _ref.value,
        value = _ref$value === void 0 ? 'value' : _ref$value;
    var formItem = getComponent(el, 'UiFormItem');

    if (formItem) {
      formItem._addControl(el);

      el.__form_event = {};

      var handler = function handler() {
        var _this = this;

        Vue.nextTick(function () {
          formItem._updateValue(Function.prototype.constructor("return this.".concat(value)).call(_this));
        });
      };

      getEvents(modifiers).forEach(function (type) {
        addEvents(el, type, handler);
        el.__form_event[type] = handler;
      });

      formItem._updateValue(vnode.data.model.value);
    }
  },

  /*componentUpdated(el, { modifiers, value = 'value' }) {
    el.__form_event = el.__form_event || {};
     let events = getEvents(modifiers);
    Object.keys(el.__form_event).forEach(type => {
      if (!~events.indexOf(type)) {
        removeEvents(el, type, el.__form_event[type]);
        delete el.__form_event[type];
      }
    })
     let formItem = getComponent(el, 'UiFormItem');
    if (formItem) {
      let handler = function () { Vue.nextTick(() => formItem._updateValue(Function.prototype.constructor('return this.value')(this)), this) };
      events.forEach(type => {
        if (!el.__form_event[type]) {
          addEvents(el, type, handler);
          el.__form_event[type] = handler;
        }
      });
    }
  },*/
  unbind: function unbind(el) {
    Object.keys(el.__form_event || {}).forEach(function (type) {
      return removeEvents(el, type, el.__form_event[type]);
    });
    var formItem = getComponent(el, 'UiFormItem');
    formItem && formItem._removeControl();
  },
  update: function update(el, _ref2, vnode) {
    var modifiers = _ref2.modifiers,
        _ref2$value = _ref2.value,
        value = _ref2$value === void 0 ? 'value' : _ref2$value;
    var formItem = getComponent(el, 'UiFormItem');

    if (formItem) {
      formItem._addControl(el);

      el.__form_event = {};

      var handler = function handler() {
        var _this2 = this;

        Vue.nextTick(function () {
          formItem._updateValue(Function.prototype.constructor("return this.".concat(value)).call(_this2));
        });
      };

      getEvents(modifiers).forEach(function (type) {
        addEvents(el, type, handler);
        el.__form_event[type] = handler;
      });

      formItem._updateValue(vnode.data.model.value);
    }
  }
};

var afterLeave = createCommonjsModule(function (module, exports) {

exports.__esModule = true;

exports.default = function (instance, callback) {
  var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
  var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (!instance || !callback) throw new Error('instance & callback is required');
  var called = false;

  var afterLeaveCallback = function afterLeaveCallback() {
    if (called) return;
    called = true;

    if (callback) {
      callback.apply(null, arguments);
    }
  };

  if (once) {
    instance.$once('after-leave', afterLeaveCallback);
  } else {
    instance.$on('after-leave', afterLeaveCallback);
  }

  setTimeout(function () {
    afterLeaveCallback();
  }, speed + 100);
};
/**
 * Bind after-leave event for vue instance. Make sure after-leave is called in any browsers.
 *
 * @param {Vue} instance Vue instance.
 * @param {Function} callback callback of after-leave event
 * @param {Number} speed the speed of transition, default value is 300ms
 * @param {Boolean} once weather bind after-leave once. default value is false.
 */
});

var afterLeave$1 = unwrapExports(afterLeave);

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var instance$1 = 'v-loading';
var Loading = {
  components: {
    UiIcon: __vue_component__$1B
  },
  data: function data() {
    return {
      text: null,
      icon: null,
      background: null,
      fullscreen: true,
      visible: false,
      progress: false,
      customClass: '',
      percent: 1,
      countId: ''
    };
  },
  watch: {
    visible: function visible(val) {
      if (val) {
        this.startCount();
      } else {
        this.endCount();
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.endCount();
  },
  methods: {
    handleAfterLeave: function handleAfterLeave() {
      this.$emit('after-leave');
    },
    setText: function setText(text) {
      this.text = text;
    },
    startCount: function startCount() {
      var _this = this;

      if (!this.progress) return;
      this.percent = 1;
      this.countId = setInterval(function (_) {
        if (_this.percent === 99) {
          clearInterval(_this.countId);
          return;
        }

        _this.percent++;
      }, 80);
    },
    endCount: function endCount() {
      clearInterval(this.countId);
      this.percent = 100;
    }
  },
  render: function render(h) {
    var text = "".concat(this.text || 'å è½½ä¸­') + (this.progress ? " ".concat(this.percent, "%") : '');
    return h("transition", {
      "attrs": {
        "name": "ui-loading__fade"
      },
      "on": {
        "afterLeave": this.handleAfterLeave
      }
    }, [h("div", helper([{
      "class": ['ui-loading__mask', this.customClass, {
        'is-fullscreen': this.fullscreen
      }],
      "style": {
        backgroundColor: this.background || ''
      }
    }, {
      directives: [{
        name: 'show',
        value: this.visible
      }]
    }]), [h("div", {
      "class": "ui-loading__spinner"
    }, [!this.icon ? h("svg", {
      "class": "ui-loading__icon",
      "attrs": {
        "viewBox": "25 25 50 50"
      }
    }, [h("circle", {
      "attrs": {
        "cx": "50",
        "cy": "50",
        "r": "20",
        "fill": "none"
      }
    })]) : h("ui-icon", {
      "class": "ui-loading__icon",
      "attrs": {
        "icon": this.icon
      }
    }), h("p", {
      "class": "ui-loading__text"
    }, [text])])])]);
  }
};

var toggleLoading = function toggleLoading(el, data) {
  if (data.value) {
    Vue.nextTick(function () {
      if (data.fullscreen) {
        el.originalPosition = getStyle(document.body, 'position');
        el.originalOverflow = getStyle(document.body, 'overflow');
        el.maskStyle.zIndex = 100;
        addClass(el.mask, 'is-fullscreen');
        insertDom(document.body, el, data);
      } else {
        removeClass(el.mask, 'is-fullscreen');

        if (data.body) {
          el.originalPosition = getStyle(document.body, 'position');
          ['top', 'left'].forEach(function (property) {
            var scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
            el.maskStyle[property] = el.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(getStyle(document.body, "margin-".concat(property)), 10) + 'px';
          });
          ['height', 'width'].forEach(function (property) {
            el.maskStyle[property] = el.getBoundingClientRect()[property] + 'px';
          });
          insertDom(document.body, el, data);
        } else {
          el.originalPosition = getStyle(el, 'position');
          insertDom(el, el, data);
        }
      }
    });
  } else {
    afterLeave$1(el[instance$1], function (_) {
      if (!el[instance$1].hiding) return;
      el.domVisible = false;
      var target = data.fullscreen || data.body ? document.body : el;
      removeClass(target, 'ui-loading__parent--relative');
      removeClass(target, 'ui-loading__parent--hidden');
      el[instance$1].hiding = false;
    }, 300, true);
    el[instance$1].visible = false;
    el[instance$1].hiding = true;
  }
};

var insertDom = function insertDom(parent, el, data) {
  if (!el.domVisible && getStyle(el, 'display') !== 'none' && getStyle(el, 'visibility') !== 'hidden') {
    Object.keys(el.maskStyle).forEach(function (property) {
      el.mask.style[property] = el.maskStyle[property];
    });

    if (el.originalPosition !== 'absolute' && el.originalPosition !== 'fixed') {
      addClass(parent, 'ui-loading__parent--relative');
    }

    if (data.fullscreen && data.lock) {
      addClass(parent, 'ui-loading__parent--hidden');
    }

    el.domVisible = true;
    parent.appendChild(el.mask);
    Vue.nextTick(function () {
      if (el[instance$1].hiding) {
        el[instance$1].$emit('after-leave');
      } else {
        el[instance$1].visible = true;
      }
    });
    el.domInserted = true;
  } else if (el.domVisible && el[instance$1].hiding === true) {
    el[instance$1].visible = true;
    el[instance$1].hiding = false;
  }
};

var Mask = Vue.extend(Loading);

var getValue = function getValue(value) {
  return 'object' === _typeof_1(value) ? value : {
    value: value
  };
};

var DLoading = {
  bind: function bind(el, binding) {
    var value = getValue(binding.value);
    var mask = new Mask({
      el: document.createElement('div'),
      data: {
        text: value.text,
        icon: value.icon,
        background: value.background,
        customClass: value.customClass,
        progress: !!binding.modifiers.progress || value.progress,
        fullscreen: !!binding.modifiers.fullscreen || value.fullscreen
      }
    });
    el[instance$1] = mask;
    el.mask = mask.$el;
    el.maskStyle = {};
    value.value && toggleLoading(el, _objectSpread$3(_objectSpread$3({}, binding.modifiers), value));
  },
  update: function update(el, binding) {
    var oldValue = getValue(binding.oldValue);
    var value = getValue(binding.value); // el[instance].setText(el.getAttribute('ui-loading__text'))

    el[instance$1].setText(value.text);

    if (oldValue.value !== value.value) {
      toggleLoading(el, _objectSpread$3(_objectSpread$3({}, binding.modifiers), value));
    }
  },
  unbind: function unbind(el, binding) {
    if (el.domInserted) {
      el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask);
      toggleLoading(el, _objectSpread$3(_objectSpread$3({}, binding.modifiers), {}, {
        value: false
      }));
    }

    el[instance$1] && el[instance$1].$destroy();
  }
};

var script$1 = {
  name: 'ui-message',
  components: {
    UiButton: __vue_component__$1v,
    UiModal: __vue_component__$1e
  },
  props: {
    title: String,
    icon: String,
    mode: {
      type: String,
      default: 'alert',
      validator: function validator(val) {
        return ['', 'alert', 'confirm', 'prompt'].indexOf(val) !== -1;
      }
    },
    type: {
      type: String,
      default: '',
      validator: function validator(val) {
        return ['', 'success', 'info', 'warning', 'error'].indexOf(val) !== -1;
      }
    },
    size: {
      type: String,
      default: 'small',
      // 'small', 'normal', 'large', 'auto'
      validator: function validator(val) {
        return ['', 'small', 'normal', 'large', 'auto'].indexOf(val) !== -1;
      }
    },
    content: [String, Function],
    className: String,
    transition: String,
    beforeClose: Function,
    okLabel: String,
    cancelLabel: String,
    inputType: String,
    inputPlaceholder: String,
    inputValue: [String, Number],
    validator: Function
  },
  data: function data() {
    return {
      value: this.inputValue,
      errorText: ''
    };
  },
  methods: {
    handleClose: function handleClose(result) {
      var _this = this;

      if (this.beforeClose) {
        return this.beforeClose(result, this, function () {
          return _this.close(result);
        });
      }

      return this.close(result);
    },
    open: function open() {
      this.$refs['modal'].open();
      this.$emit('open');
    },
    close: function close(isOk) {
      if (isOk && this.mode === 'prompt' && this.validator) {
        var result = this.validator(this.value);

        if (!result.valid) {
          this.errorText = result.message;
          return;
        }

        this.errorText = '';
      }

      this.$refs['modal'].close();
      this.$emit('close', isOk, this.value);
      return isOk;
    },
    createInput: function createInput(h) {
      var _this2 = this;

      if (this.mode !== 'prompt') return;
      return h('ui-textbox', {
        attrs: {
          type: this.inputType,
          placeholder: this.inputPlaceholder
        },
        props: {
          value: this.value,
          errorText: this.errorText,
          fullWidth: true
        },
        on: {
          input: function input(val) {
            return _this2.value = val;
          },
          keydown: function keydown(e) {
            if (e.keyCode === 13) {
              _this2.handleClose(true);
            }
          }
        }
      });
    },
    createContent: function createContent(h) {
      var content = typeof this.content === 'function' ? this.content(h) : this.content;
      return h('div', {
        class: 'ui-message__content'
      }, [this.icon ? h('ui-icon', {
        staticClass: 'ui-message__icon',
        class: defineProperty$2({}, "ui-message__icon--".concat(this.type), this.type),
        props: {
          icon: this.icon
        }
      }) : undefined, h('div', {
        staticClass: 'ui-message__inner'
      }, [content, this.createInput(h)])]);
    },
    createActions: function createActions(h) {
      var _this3 = this;

      var actions = [];
      actions.push(h('ui-button', {
        props: {
          flat: true,
          color: 'primary'
        },
        on: {
          click: function click() {
            return _this3.handleClose(true);
          }
        }
      }, this.okLabel));

      if (this.mode !== 'alert') {
        actions.unshift(h('ui-button', {
          props: {
            flat: true
          },
          slot: 'actions',
          on: {
            click: function click() {
              return _this3.handleClose(false);
            }
          }
        }, this.cancelLabel));
      }

      return actions;
    }
  },
  render: function render(h) {
    var _this4 = this;

    return h('ui-modal', {
      props: {
        title: this.title,
        size: this.size,
        removeCloseButton: Boolean(this.mode)
      },
      on: {
        close: function close() {
          return _this4.handleClose(false);
        }
      },
      ref: 'modal'
    }, [this.createContent(h), this.mode && h('template', {
      slot: 'footer'
    }, toConsumableArray(this.createActions(h)))]);
  }
};

/* script */
var __vue_script__$1 = script$1;
/* template */

/* style */

var __vue_inject_styles__$1 = undefined;
/* scoped */

var __vue_scope_id__$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1 = /*#__PURE__*/normalizeComponent$3({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var config = {
  successIcon: 'check_circle',
  infoIcon: 'info',
  warningIcon: 'priority_high',
  errorIcon: 'warning',
  iconSize: 24,
  width: 350,
  maxWidth: '80%',
  className: '',
  okLabel: 'ç¡®å®',
  cancelLabel: 'åæ¶',
  transition: 'scale' // 'slide-top', 'slide-bottom', 'slide-left', 'slide-right', 'fade', 'scale'

};
var isServer = typeof window === 'undefined';

var noop = function noop() {};

var instances$1 = [];
var VMessage = Vue.extend(__vue_component__$1);

var Message = function Message(options, vOptions) {
  if (isServer) return;
  return new Promise(function () {
    var resolve = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;
    var reject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    var modal = new VMessage(_objectSpread$2(_objectSpread$2({}, vOptions), {}, {
      el: document.createElement('div'),
      propsData: _objectSpread$2(_objectSpread$2({}, config), {}, {
        icon: config[options.type + 'Icon'] || ''
      }, options)
    }));
    document.body.appendChild(modal.$el);
    modal.open();

    if (modal.mode === 'prompt') {
      setTimeout(function () {
        modal.$el && modal.$el.querySelector('input').focus();
      }, 200);
    }

    instances$1.push(modal);
    modal.$on('close', function (result, value) {
      setTimeout(function () {
        if (modal) {
          modal.$el && modal.$el.parentNode && modal.$el.parentNode.removeChild(modal.$el);
          modal.$destroy();
          modal = null;
        }
      }, 500);
      var index = instances$1.indexOf(modal);

      if (index !== -1) {
        instances$1.splice(index, 1);
      }

      return result ? resolve(value) : reject();
    });
  });
};

Message.config = function (options) {
  if (!options || Array.isArray(options) || _typeof_1(options) !== 'object') return config;

  for (var key in options) {
    if (!options.hasOwnProperty(key)) continue;
    config[key] = options[key];
  }

  return config;
};

Message.close = function () {
  instances$1.forEach(function (modal) {
    modal.close(false);
  });
};

['alert', 'confirm', 'prompt'].forEach(function (mode) {
  Message[mode] = function (content, options) {
    if (!content && arguments.length < 2) return;
    var title = '';

    switch (arguments.length) {
      case 1:
        options = {};
        break;

      case 2:
        if (typeof options === 'string') {
          title = options;
          options = {};
        }

        break;

      default:
        title = arguments[1];
        options = arguments[2];
        break;
    }

    return Message(_objectSpread$2(_objectSpread$2({
      title: title,
      content: content
    }, options), {}, {
      mode: mode
    }));
  };
});

Message.install = function (Vue, options) {
  Message.config(options);
  Vue.prototype.$message = Message;
  Vue.prototype.$alert = Message.alert;
  Vue.prototype.$confirm = Message.confirm;
  Vue.prototype.$prompt = Message.prompt;
};

var typeMap = {
  success: {
    color: 'green',
    icon: 'check_circle'
  },
  info: {
    color: 'primary',
    icon: 'info'
  },
  warning: {
    color: 'orange',
    icon: 'error'
  },
  error: {
    color: 'red',
    icon: 'cancel'
  }
};
var script = {
  data: function data() {
    return {
      visible: false,
      message: '',
      duration: 3000,
      type: 'info',
      iconClass: '',
      customClass: '',
      onClose: null,
      showClose: false,
      closed: false,
      verticalOffset: 20,
      timer: null,
      dangerouslyUseHTMLString: false,
      center: false
    };
  },
  computed: {
    classes: function classes() {
      var _ref;

      return ['ui-toast', (_ref = {}, defineProperty$2(_ref, "ui-toast--color-".concat(this.typeData.color), this.type && !this.iconClass), defineProperty$2(_ref, 'is-center', this.center), defineProperty$2(_ref, 'is-closable', this.showClose), _ref), this.customClass];
    },
    typeData: function typeData() {
      return typeMap[this.type] || {};
    },
    positionStyle: function positionStyle() {
      return {
        top: "".concat(this.verticalOffset, "px")
      };
    }
  },
  watch: {
    closed: function closed(newVal) {
      if (newVal) {
        this.visible = false;
      }
    }
  },
  methods: {
    handleAfterLeave: function handleAfterLeave() {
      this.$destroy(true);
      this.$el.parentNode.removeChild(this.$el);
    },
    close: function close() {
      this.closed = true;

      if (typeof this.onClose === 'function') {
        this.onClose(this);
      }
    },
    clearTimer: function clearTimer() {
      clearTimeout(this.timer);
    },
    startTimer: function startTimer() {
      var _this = this;

      if (this.duration > 0) {
        this.timer = setTimeout(function () {
          if (!_this.closed) {
            _this.close();
          }
        }, this.duration);
      }
    },
    keydown: function keydown(e) {
      if (e.keyCode === 27) {
        // escå³é­æ¶æ¯
        if (!this.closed) {
          this.close();
        }
      }
    }
  },
  mounted: function mounted() {
    this.startTimer();
    document.addEventListener('keydown', this.keydown);
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('keydown', this.keydown);
  }
};

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('transition', {
    attrs: {
      "name": "ui-toast-fade"
    },
    on: {
      "after-leave": _vm.handleAfterLeave
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.visible,
      expression: "visible"
    }],
    class: _vm.classes,
    style: _vm.positionStyle,
    attrs: {
      "role": "alert"
    },
    on: {
      "mouseenter": _vm.clearTimer,
      "mouseleave": _vm.startTimer
    }
  }, [_c('ui-icon', {
    staticClass: "ui-toast__icon",
    attrs: {
      "icon": _vm.iconClass || _vm.typeData.icon
    }
  }), _vm._v(" "), _vm._t("default", [!_vm.dangerouslyUseHTMLString ? _c('p', {
    staticClass: "ui-toast__content"
  }, [_vm._v("\n        " + _vm._s(_vm.message) + "\n      ")]) : _c('p', {
    staticClass: "ui-toast__content",
    domProps: {
      "innerHTML": _vm._s(_vm.message)
    }
  })]), _vm._v(" "), _vm.showClose ? _c('ui-icon', {
    staticClass: "ui-toast__closeBtn",
    attrs: {
      "icon": "close"
    },
    nativeOn: {
      "click": function click($event) {
        return _vm.close($event);
      }
    }
  }) : _vm._e()], 2)]);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__ = /*#__PURE__*/normalizeComponent$3({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

var ToastConstructor = Vue.extend(__vue_component__);
var instance;
var instances = [];
var seed = 1;
var zIndex = 9999;

var Toast = function Toast(options) {
  if (Vue.prototype.$isServer) return;
  options = options || {};

  if (typeof options === 'string') {
    options = {
      message: options
    };
  }

  var userOnClose = options.onClose;
  var id = 'toast_' + seed++;

  options.onClose = function () {
    Toast.close(id, userOnClose);
  };

  instance = new ToastConstructor({
    data: options
  });
  instance.id = id;

  if (isVNode(instance.message)) {
    instance.$slots.default = [instance.message];
    instance.message = null;
  }

  instance.$mount();
  document.body.appendChild(instance.$el);
  var verticalOffset = options.offset || 20;
  instances.forEach(function (item) {
    verticalOffset += item.$el.offsetHeight + 16;
  });
  instance.verticalOffset = verticalOffset;
  instance.visible = true;
  instance.$el.style.zIndex = zIndex++;
  instances.push(instance);
  return instance;
};

['success', 'warning', 'info', 'error'].forEach(function (type) {
  Toast[type] = function (options) {
    if (typeof options === 'string') {
      options = {
        message: options
      };
    }

    options.type = type;
    return Toast(options);
  };
});

Toast.close = function (id, userOnClose) {
  var len = instances.length;
  var index = -1;
  var removedHeight;

  for (var i = 0; i < len; i++) {
    if (id === instances[i].id) {
      removedHeight = instances[i].$el.offsetHeight;
      index = i;

      if (typeof userOnClose === 'function') {
        userOnClose(instances[i]);
      }

      instances.splice(i, 1);
      break;
    }
  }

  if (len <= 1 || index === -1 || index > instances.length - 1) return;

  for (var _i = index; _i < len - 1; _i++) {
    var dom = instances[_i].$el;
    dom.style['top'] = parseInt(dom.style['top'], 10) - removedHeight - 16 + 'px';
  }
};

Toast.closeAll = function () {
  for (var i = instances.length - 1; i >= 0; i--) {
    instances[i].close();
  }
};

Toast.install = function (Vue) {
  Vue.prototype.$toast = Toast;
};

function select(element) {
  var selectedText;

  if (element.nodeName === 'SELECT') {
    element.focus();
    selectedText = element.value;
  } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
    var isReadOnly = element.hasAttribute('readonly');

    if (!isReadOnly) {
      element.setAttribute('readonly', '');
    }

    element.select();
    element.setSelectionRange(0, element.value.length);

    if (!isReadOnly) {
      element.removeAttribute('readonly');
    }

    selectedText = element.value;
  } else {
    if (element.hasAttribute('contenteditable')) {
      element.focus();
    }

    var selection = window.getSelection();
    var range = document.createRange();
    range.selectNodeContents(element);
    selection.removeAllRanges();
    selection.addRange(range);
    selectedText = selection.toString();
  }

  return selectedText;
}

var Clipboard = function Clipboard(_ref) {
  var text = _ref.text,
      _ref$showSuccessTip = _ref.showSuccessTip,
      showSuccessTip = _ref$showSuccessTip === void 0 ? 'å¤å¶æå' : _ref$showSuccessTip,
      _ref$showFailureTip = _ref.showFailureTip,
      showFailureTip = _ref$showFailureTip === void 0 ? 'å¤å¶å¤±è´¥' : _ref$showFailureTip,
      successCallback = _ref.successCallback,
      failureCallback = _ref.failureCallback;
  var container = document.body;
  var isRTL = document.documentElement.getAttribute('dir') == 'rtl';
  var fakeElem = document.createElement('textarea');
  fakeElem.style.fontSize = '12px';
  fakeElem.style.border = '0';
  fakeElem.style.padding = '0';
  fakeElem.style.margin = '0';
  fakeElem.style.position = 'absolute';
  fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
  fakeElem.style.top = "".concat(yPosition, "px");
  fakeElem.setAttribute('readonly', '');
  fakeElem.value = text;
  container.appendChild(fakeElem);
  select(fakeElem);

  try {
    document.execCommand('copy');

    if (showSuccessTip) {
      Toast({
        message: showSuccessTip,
        type: 'success'
      });
    }

    if (successCallback) {
      successCallback.call();
    }
  } catch (err) {
    if (showFailureTip) {
      Toast.error(showFailureTip);
    }

    if (failureCallback) {
      failureCallback.call();
    }
  }
};

Clipboard.install = function (Vue) {
  Vue.prototype.$Clipboard = Clipboard;
};

/**
scrollIntoView(someElement, {
  time: 500, // half a second
  ease: function(value){
    return Math.pow(value,2) - value; // Do something weird.
  },
  validTarget: function(target, parentsScrolled){
    // Only scroll the first two elements that don't have the class "dontScroll"
    return parentsScrolled < 2 && target !== window && !target.matches('.dontScroll');
  },
  align:{
    top: 0 to 1, default 0.5 (center)
    left: 0 to 1, default 0.5 (center)
    topOffset: pixels to offset top alignment
    leftOffset: pixels to offset left alignment
  },
  isScrollable: function(target, defaultIsScrollable){
    // By default scroll-into-view will only attempt to scroll elements that have overflow not set to `"hidden"` and who's scroll width/height is larger than their client height.
    // You can override this check by passing an `isScrollable` function to settings:
    return defaultIsScrollable(target) || ~target.className.indexOf('scrollable');
  }
});
*/
var COMPLETE = 'COMPLETE';
var CANCELED = 'CANCELED';

function requestAnimation(task) {
  if ('requestAnimationFrame' in window) {
    return window.requestAnimationFrame(task);
  }

  setTimeout(task, 16);
}

function setElementScroll(element, x, y) {
  if (element === window) {
    element.scrollTo(x, y);
  } else {
    element.scrollLeft = x;
    element.scrollTop = y;
  }
}

function getTargetScrollLocation(target, parent, align) {
  var targetPosition = target.getBoundingClientRect();
  var parentPosition = null;
  var x = null;
  var y = null;
  var differenceX = null;
  var differenceY = null;
  var targetWidth = null;
  var targetHeight = null;
  var leftAlign = align && align.left != null ? align.left : 0.5;
  var topAlign = align && align.top != null ? align.top : 0.5;
  var leftOffset = align && align.leftOffset != null ? align.leftOffset : 0;
  var topOffset = align && align.topOffset != null ? align.topOffset : 0;
  var leftScalar = leftAlign;
  var topScalar = topAlign;

  if (parent === window) {
    targetWidth = Math.min(targetPosition.width, window.innerWidth);
    targetHeight = Math.min(targetPosition.height, window.innerHeight);
    x = targetPosition.left + window.pageXOffset - window.innerWidth * leftScalar + targetWidth * leftScalar;
    y = targetPosition.top + window.pageYOffset - window.innerHeight * topScalar + targetHeight * topScalar;
    x -= leftOffset;
    y -= topOffset;
    differenceX = x - window.pageXOffset;
    differenceY = y - window.pageYOffset;
  } else {
    targetWidth = targetPosition.width;
    targetHeight = targetPosition.height;
    parentPosition = parent.getBoundingClientRect();
    var offsetLeft = targetPosition.left - (parentPosition.left - parent.scrollLeft);
    var offsetTop = targetPosition.top - (parentPosition.top - parent.scrollTop);
    x = offsetLeft + targetWidth * leftScalar - parent.clientWidth * leftScalar;
    y = offsetTop + targetHeight * topScalar - parent.clientHeight * topScalar;
    x = Math.max(Math.min(x, parent.scrollWidth - parent.clientWidth), 0);
    y = Math.max(Math.min(y, parent.scrollHeight - parent.clientHeight), 0);
    x -= leftOffset;
    y -= topOffset;
    differenceX = x - parent.scrollLeft;
    differenceY = y - parent.scrollTop;
  }

  return {
    x: x,
    y: y,
    differenceX: differenceX,
    differenceY: differenceY
  };
}

function animate(parent) {
  requestAnimation(function () {
    var scrollSettings = parent.scrollOption;

    if (!scrollSettings) {
      return;
    }

    var location = getTargetScrollLocation(scrollSettings.target, parent, scrollSettings.align);
    var time = Date.now() - scrollSettings.startTime;
    var timeValue = Math.min(1 / scrollSettings.time * time, 1);

    if (time > scrollSettings.time + 20) {
      setElementScroll(parent, location.x, location.y);
      parent.scrollOption = null;
      return scrollSettings.end(COMPLETE);
    }

    var easeValue = 1 - scrollSettings.ease(timeValue);
    setElementScroll(parent, location.x - location.differenceX * easeValue, location.y - location.differenceY * easeValue);
    animate(parent);
  });
}

function transitionScrollTo(target, parent, settings, callback) {
  var idle = !parent.scrollOption;
  var lastSettings = parent.scrollOption;
  var now = Date.now();
  var endHandler;

  if (lastSettings) {
    lastSettings.end(CANCELED);
  }

  function end(endType) {
    parent.scrollOption = null;

    if (parent.parentElement && parent.parentElement.scrollOption) {
      parent.parentElement.scrollOption.end(endType);
    }

    callback(endType);
    parent.removeEventListener('touchstart', endHandler);
  }

  parent.scrollOption = {
    startTime: lastSettings ? lastSettings.startTime : Date.now(),
    target: target,
    time: settings.time + (lastSettings ? now - lastSettings.startTime : 0),
    ease: settings.ease,
    align: settings.align,
    end: end
  };
  endHandler = end.bind(null, CANCELED);
  parent.addEventListener('touchstart', endHandler);

  if (idle) {
    animate(parent);
  }
}

function defaultIsScrollable(element) {
  return element === window || (element.scrollHeight !== element.clientHeight || element.scrollWidth !== element.clientWidth) && getComputedStyle(element).overflow !== 'hidden';
}

function defaultValidTarget() {
  return true;
}

var ScrollIntoView = function ScrollIntoView(target, settings, callback) {
  if (!target) {
    return;
  }

  if (typeof settings === 'function') {
    callback = settings;
    settings = null;
  }

  if (!settings) {
    settings = {};
  }

  settings.time = isNaN(settings.time) ? 1000 : settings.time;

  settings.ease = settings.ease || function (v) {
    return 1 - Math.pow(1 - v, v / 2);
  };

  var parent = target.parentElement;
  var parents = 0;

  function done(endType) {
    parents -= 1;

    if (!parents && callback) {
      callback(endType);
    }
  }

  var validTarget = settings.validTarget || defaultValidTarget;
  var isScrollable = settings.isScrollable;

  while (parent) {
    if (validTarget(parent, parents) && (isScrollable ? isScrollable(parent, defaultIsScrollable) : defaultIsScrollable(parent))) {
      parents += 1;
      transitionScrollTo(target, parent, settings, done);
    }

    parent = parent.parentElement;

    if (!parent) {
      return;
    }

    if (parent.tagName === 'BODY') {
      parent = window;
    }
  }
};

ScrollIntoView.install = function (Vue) {
  Vue.prototype.$ScrollIntoView = ScrollIntoView;
};

/*!
 * Intro.js v8.0.0-beta.1
 * https://introjs.com
 *
 * Copyright (C) 2012-2024 Afshin Mehrabani (@afshinmeh).
 * https://introjs.com
 *
 * Date: Sun, 21 Jul 2024 11:55:52 GMT
 */
var t=function(e,n){return t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);},t(e,n)};function e(t,e,n,o){return new(n||(n=Promise))((function(i,r){function s(t){try{l(o.next(t));}catch(t){r(t);}}function a(t){try{l(o.throw(t));}catch(t){r(t);}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e);}))).then(s,a);}l((o=o.apply(t,e||[])).next());}))}function n(t,e){var n,o,i,r,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return r={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function a(a){return function(l){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;r&&(r=0,a[0]&&(s=0)),s;)try{if(n=1,o&&(i=2&a[0]?o.return:a[0]?o.throw||((i=o.return)&&i.call(o),0):o.next)&&!(i=i.call(o,a[1])).done)return i;switch(o=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,o=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(i=s.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=e.call(t,s);}catch(t){a=[6,t],o=0;}finally{n=i=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:!0}}([a,l])}}}"function"==typeof SuppressedError&&SuppressedError;function o(t){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},o(t)}function i(t){if(null===t||"object"!==o(t)||"nodeType"in t)return t;var e={};for(var n in t)"jQuery"in window&&window.jQuery&&t[n]instanceof window.jQuery?e[n]=t[n]:e[n]=i(t[n]);return e}var r=function(t,e){return (null!=e?e:document).querySelector(t)},s=function(t,e){return (null!=e?e:document).querySelectorAll(t)},a=function(t,e){return r(".".concat(t),e)},l=function(t,e){return s(".".concat(t),e)},c=function(t,e){var n=a(t,e);if(!n)throw new Error("Element with class name ".concat(t," not found"));return n};function u(t,e,n){return t[e]=n,t}function p(t,e){for(var n=0,o=Object.entries(e);n<o.length;n++){var i=o[n];t=u(t,i[0],i[1]);}return t}var h=function(t){return "function"==typeof t};function d(t,e){var n="";return "currentStyle"in t?n=t.currentStyle[e]:document.defaultView&&document.defaultView.getComputedStyle&&(n=document.defaultView.getComputedStyle(t,null).getPropertyValue(e)),n&&n.toLowerCase?n.toLowerCase():n}function f(t){var e=t.parentElement;return !(!e||"HTML"===e.nodeName)&&("fixed"===d(t,"position")||f(e))}function g(t,e){var n=document.body,o=document.documentElement,i=window.pageYOffset||o.scrollTop||n.scrollTop,r=window.pageXOffset||o.scrollLeft||n.scrollLeft;e=e||n;var s=t.getBoundingClientRect(),a=e.getBoundingClientRect(),l=d(e,"position"),c={width:s.width,height:s.height};return "body"!==e.tagName.toLowerCase()&&"relative"===l||"sticky"===l?Object.assign(c,{top:s.top-a.top,left:s.left-a.left}):f(t)?Object.assign(c,{top:s.top,left:s.left}):Object.assign(c,{top:s.top+i,left:s.left+r})}var v=function(t,e,n){if(void 0!==n){var o=g(n),i=20,r=20;switch(t){default:case"top-left":e.style.left="".concat(o.left,"px"),e.style.top="".concat(o.top,"px");break;case"top-right":e.style.left="".concat(o.left+o.width-i,"px"),e.style.top="".concat(o.top,"px");break;case"bottom-left":e.style.left="".concat(o.left,"px"),e.style.top="".concat(o.top+o.height-r,"px");break;case"bottom-right":e.style.left="".concat(o.left+o.width-i,"px"),e.style.top="".concat(o.top+o.height-r,"px");break;case"middle-left":e.style.left="".concat(o.left,"px"),e.style.top="".concat(o.top+(o.height-r)/2,"px");break;case"middle-right":e.style.left="".concat(o.left+o.width-i,"px"),e.style.top="".concat(o.top+(o.height-r)/2,"px");break;case"middle-middle":e.style.left="".concat(o.left+(o.width-i)/2,"px"),e.style.top="".concat(o.top+(o.height-r)/2,"px");break;case"bottom-middle":e.style.left="".concat(o.left+(o.width-i)/2,"px"),e.style.top="".concat(o.top+o.height-r,"px");break;case"top-middle":e.style.left="".concat(o.left+(o.width-i)/2,"px"),e.style.top="".concat(o.top,"px");}}};var b=new(function(){function t(){}return t.prototype.on=function(t,e,n,o){"addEventListener"in t?t.addEventListener(e,n,o):"attachEvent"in t&&t.attachEvent("on".concat(e),n);},t.prototype.off=function(t,e,n,o){"removeEventListener"in t?t.removeEventListener(e,n,o):"detachEvent"in t&&t.detachEvent("on".concat(e),n);},t}()),m=function(t){return t?"string"==typeof t?function(t,e){var n=r(t,e);if(!n)throw new Error("Element with selector ".concat(t," not found"));return n}(t):t:document.body};function y(t,e){var n="";if(t.style.cssText&&(n+=t.style.cssText),"string"==typeof e)n+=e;else for(var o in e)n+="".concat(o,":").concat(e[o],";");t.style.cssText=n;}function w(t,e){var n=document.createElement(t);e=e||{};var o=/^(?:role|data-|aria-)/;for(var i in e){var r=e[i];"style"===i&&"function"!=typeof r?y(n,r):"string"==typeof r&&i.match(o)?n.setAttribute(i,r):n[i]=r;}return n}function C(t){t.setAttribute("role","button"),t.tabIndex=0;}var S=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var o=0,i=e;o<i.length;o++){var r=i[o];if(t instanceof SVGElement){var s=t.getAttribute("class")||"";s.match(r)||O(t,s,r);}else void 0!==t.classList?t.classList.add(r):t.className.match(r)||O(t,t.className,r);}},O=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];var o=e.filter(Boolean).join(" ");t instanceof SVGElement?t.setAttribute("class",o):void 0!==t.classList?t.classList.value=o:t.className=o;},j=function(t,e){if(t instanceof SVGElement){var n=t.getAttribute("class")||"";t.setAttribute("class",n.replace(e,"").replace(/\s\s+/g," ").trim());}else t.className=t.className.replace(e,"").replace(/\s\s+/g," ").trim();},k=function(){return a("introjs-hints")},x=function(){return l("introjs-hint",k())},A=function(t){return l("".concat("introjs-hint","[").concat("data-step",'="').concat(t,'"]'),k())[0]};function E(t,o){var i;return e(this,void 0,void 0,(function(){var e;return n(this,(function(n){return e=A(o),M(),e&&S(e,"introjs-hidehint"),null===(i=t.callback("hintClose"))||void 0===i||i.call(t,o),[2]}))}))}function T(t){return e(this,void 0,void 0,(function(){var e,o,i,r,s;return n(this,(function(n){switch(n.label){case 0:e=x(),o=0,i=Array.from(e),n.label=1;case 1:return o<i.length?(r=i[o],(s=r.getAttribute("data-step"))?[4,E(t,parseInt(s,10))]:[3,3]):[3,4];case 2:n.sent(),n.label=3;case 3:return o++,[3,1];case 4:return [2]}}))}))}var _=function(t,e,n,o){if(e&&t&&n){n instanceof Element&&f(n)?S(e,"introjs-fixedTooltip"):j(e,"introjs-fixedTooltip");var i=g(n,t);y(e,{width:"".concat(i.width+o,"px"),height:"".concat(i.height+o,"px"),top:"".concat(i.top-o/2,"px"),left:"".concat(i.left-o/2,"px")});}};function H(){if(void 0!==window.innerWidth)return {width:window.innerWidth,height:window.innerHeight};var t=document.documentElement;return {width:t.clientWidth,height:t.clientHeight}}function N(t,e,n,o,i){return t.left+e+n.width>o.width?(i.style.left="".concat(o.width-n.width-t.left,"px"),!1):(i.style.left="".concat(e,"px"),!0)}function L(t,e,n,o){return t.left+t.width-e-n.width<0?(o.style.left="".concat(-t.left,"px"),!1):(o.style.right="".concat(e,"px"),!0)}function P(t,e){t.includes(e)&&t.splice(t.indexOf(e),1);}function R(t,e,n,o){var i=t.slice(),r=H(),s=g(n).height+10,a=g(n).width+20,l=e.getBoundingClientRect(),c="floating";if(l.bottom+s>r.height&&P(i,"bottom"),l.top-s<0&&P(i,"top"),l.right+a>r.width&&P(i,"right"),l.left-a<0&&P(i,"left"),o&&(o=o.split("-")[0]),i.length&&(c=i[0],i.includes(o)&&(c=o)),"top"===c||"bottom"===c){var u=void 0,p=[];"top"===c?(u="top-middle-aligned",p=["top-left-aligned","top-middle-aligned","top-right-aligned"]):(u="bottom-middle-aligned",p=["bottom-left-aligned","bottom-middle-aligned","bottom-right-aligned"]),c=function(t,e,n,o){var i=e/2,r=Math.min(n,window.screen.width);return r-t<e&&(P(o,"top-left-aligned"),P(o,"bottom-left-aligned")),(t<i||r-t<i)&&(P(o,"top-middle-aligned"),P(o,"bottom-middle-aligned")),t<e&&(P(o,"top-right-aligned"),P(o,"bottom-right-aligned")),o.length?o[0]:null}(l.left,a,r.width,p)||u;}return c}var B,I=function(t,e,n,o,i,r,s,a,l){var c,u,p;void 0===r&&(r=!1),void 0===s&&(s=!0),void 0===a&&(a=""),void 0===l&&(l=!1),t.style.top="",t.style.right="",t.style.bottom="",t.style.left="",t.style.marginLeft="",t.style.marginTop="",e.style.display="inherit",O(t,"introjs-tooltip",a),t.setAttribute("role","dialog"),"floating"!==o&&s&&(o=R(i,n,t,o)),u=g(n),c=g(t),p=H(),S(t,"introjs-".concat(o));var h=u.width/2-c.width/2;switch(o){case"top-right-aligned":O(e,"introjs-arrow bottom-right");var d=0;L(u,d,c,t),t.style.bottom="".concat(u.height+20,"px");break;case"top-middle-aligned":O(e,"introjs-arrow bottom-middle"),l&&(h+=5),L(u,h,c,t)&&(t.style.right="",N(u,h,c,p,t)),t.style.bottom="".concat(u.height+20,"px");break;case"top-left-aligned":case"top":O(e,"introjs-arrow bottom"),N(u,l?0:15,c,p,t),t.style.bottom="".concat(u.height+20,"px");break;case"right":t.style.left="".concat(u.width+20,"px"),u.top+c.height>p.height?(O(e,"introjs-arrow left-bottom"),t.style.top="-".concat(c.height-u.height-20,"px")):O(e,"introjs-arrow left");break;case"left":l||!0!==r||(t.style.top="15px"),u.top+c.height>p.height?(t.style.top="-".concat(c.height-u.height-20,"px"),O(e,"introjs-arrow right-bottom")):O(e,"introjs-arrow right"),t.style.right="".concat(u.width+20,"px");break;case"floating":e.style.display="none",t.style.left="50%",t.style.top="50%",t.style.marginLeft="-".concat(c.width/2,"px"),t.style.marginTop="-".concat(c.height/2,"px");break;case"bottom-right-aligned":O(e,"introjs-arrow top-right"),L(u,d=0,c,t),t.style.top="".concat(u.height+20,"px");break;case"bottom-middle-aligned":O(e,"introjs-arrow top-middle"),l&&(h+=5),L(u,h,c,t)&&(t.style.right="",N(u,h,c,p,t)),t.style.top="".concat(u.height+20,"px");break;default:O(e,"introjs-arrow top"),N(u,0,c,p,t),t.style.top="".concat(u.height+20,"px");}};function M(){var t=a("introjs-hintReference");if(t&&t.parentNode){var e=t.getAttribute("data-step");if(!e)return;return t.parentNode.removeChild(t),e}}function D(t,o){var i,s;return e(this,void 0,void 0,(function(){var e,a,l,c,u,p,h,d,f,g,v,m;return n(this,(function(n){switch(n.label){case 0:return e=r(".".concat("introjs-hint","[").concat("data-step",'="').concat(o,'"]')),a=t.getHint(o),e&&a?[4,null===(i=t.callback("hintClick"))||void 0===i?void 0:i.call(t,e,a,o)]:[2];case 1:return n.sent(),void 0!==(l=M())&&parseInt(l,10)===o?[2]:(c=w("div",{className:"introjs-tooltip"}),u=w("div"),p=w("div"),h=w("div"),c.onclick=function(t){t.stopPropagation?t.stopPropagation():t.cancelBubble=!0;},O(u,"introjs-tooltiptext"),(d=w("p")).innerHTML=a.hint||"",u.appendChild(d),t.getOption("hintShowButton")&&((f=w("a")).className=t.getOption("buttonClass"),f.setAttribute("role","button"),f.innerHTML=t.getOption("hintButtonLabel"),f.onclick=function(){return E(t,o)},u.appendChild(f)),O(p,"introjs-arrow"),c.appendChild(p),c.appendChild(u),g=e.getAttribute("data-step")||"",(v=t.getHint(parseInt(g,10)))?(O(h,"introjs-tooltipReferenceLayer","introjs-hintReference"),h.setAttribute("data-step",g),m=t.getOption("helperElementPadding"),_(t.getTargetElement(),h,v.element,m),h.appendChild(c),document.body.appendChild(h),I(c,p,v.element,v.position,t.getOption("positionPrecedence"),!1,t.getOption("autoPosition"),null!==(s=v.tooltipClass)&&void 0!==s?s:t.getOption("tooltipClass")),B=function(){M(),b.off(document,"click",B,!1);},b.on(document,"click",B,!1),[2]):[2])}}))}))}var z=function(t,e){return function(n){var o=n||window.event;o&&o.stopPropagation&&o.stopPropagation(),o&&null!==o.cancelBubble&&(o.cancelBubble=!0),D(t,e);}};function F(t){var o;return e(this,void 0,void 0,(function(){var e,i,s,l,c,u,p;return n(this,(function(n){for(null===(e=a("introjs-hints"))&&(e=w("div",{className:"introjs-hints"})),i=t.getHints(),s=0;s<i.length;s++){if(l=i[s],r(".".concat("introjs-hint","[").concat("data-step",'="').concat(s,'"]')))return [2];C(c=w("a",{className:"introjs-hint"})),c.onclick=z(t,s),l.hintAnimation||S(c,"introjs-hint-no-anim"),f(l.element)&&S(c,"introjs-fixedhint"),u=w("div",{className:"introjs-hint-dot"}),p=w("div",{className:"introjs-hint-pulse"}),c.appendChild(u),c.appendChild(p),c.setAttribute("data-step",s.toString()),l.hintTargetElement=l.element,l.element=c,v(l.hintPosition,c,l.hintTargetElement),e.appendChild(c);}return document.body.appendChild(e),null===(o=t.callback("hintsAdded"))||void 0===o||o.call(t),t.enableHintAutoRefresh(),[2]}))}))}function J(t){return e(this,void 0,void 0,(function(){var e,o,i,r,s;return n(this,(function(n){switch(n.label){case 0:if(!(null==(e=x())?void 0:e.length))return [3,1];for(o=0,i=Array.from(e);o<i.length;o++)r=i[o],(s=r.getAttribute("data-step"))&&V(parseInt(s,10));return [3,3];case 1:return [4,t.render()];case 2:n.sent(),n.label=3;case 3:return [2]}}))}))}function V(t){var e=A(t);e&&j(e,new RegExp("introjs-hidehint","g"));}function G(t){var e=A(t);e&&e.parentNode&&e.parentNode.removeChild(e);}var q=function(){function t(t,e){this._hints=[],this.callbacks={},this._targetElement=m(t),this._options=e?p(this._options,e):{hints:[],isActive:!0,tooltipPosition:"bottom",tooltipClass:"",hintPosition:"top-middle",hintButtonLabel:"Got it",hintShowButton:!0,hintAutoRefreshInterval:10,hintAnimation:!0,buttonClass:"introjs-button",helperElementPadding:10,autoPosition:!0,positionPrecedence:["bottom","top","right","left"]};}return t.prototype.callback=function(t){var e=this.callbacks[t];if(h(e))return e},t.prototype.getTargetElement=function(){return this._targetElement},t.prototype.getHints=function(){return this._hints},t.prototype.getHint=function(t){return this._hints[t]},t.prototype.setHints=function(t){return this._hints=t,this},t.prototype.addHint=function(t){return this._hints.push(t),this},t.prototype.render=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return this.isActive()?(function(t){t.setHints([]);var e=t.getTargetElement(),n=t.getOption("hints");if(n&&n.length>0)for(var o=0,a=n;o<a.length;o++){var l=i(a[o]);"string"==typeof l.element&&(l.element=r(l.element)),l.hintPosition=l.hintPosition||t.getOption("hintPosition"),l.hintAnimation=l.hintAnimation||t.getOption("hintAnimation"),null!==l.element&&t.addHint(l);}else {var c=Array.from(s("*[".concat("data-hint","]"),e));if(!c||!c.length)return !1;for(var u=0,p=c;u<p.length;u++){var h=p[u],d=h.getAttribute("data-hint-position"),f=t.getOption("hintAnimation");d&&(f="true"===d),t.addHint({element:h,hint:h.getAttribute("data-hint")||"",hintPosition:h.getAttribute("data-hint-position")||t.getOption("hintPosition"),hintAnimation:f,tooltipClass:h.getAttribute("data-tooltip-class")||void 0,position:h.getAttribute("data-position")||t.getOption("tooltipPosition")});}}}(this),[4,F(this)]):[2,this];case 1:return t.sent(),[2,this]}}))}))},t.prototype.addHints=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){return [2,this.render()]}))}))},t.prototype.hideHint=function(t){return e(this,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return [4,E(this,t)];case 1:return e.sent(),[2,this]}}))}))},t.prototype.hideHints=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return [4,T(this)];case 1:return t.sent(),[2,this]}}))}))},t.prototype.showHint=function(t){return V(t),this},t.prototype.showHints=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return [4,J(this)];case 1:return t.sent(),[2,this]}}))}))},t.prototype.destroy=function(){return function(t){for(var e=x(),n=0,o=Array.from(e);n<o.length;n++){var i=o[n].getAttribute("data-step");null!==i&&G(parseInt(i,10));}t.disableHintAutoRefresh();}(this),this},t.prototype.removeHints=function(){return this.destroy(),this},t.prototype.removeHint=function(t){return G(t),this},t.prototype.showHintDialog=function(t){return e(this,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return [4,D(this,t)];case 1:return e.sent(),[2,this]}}))}))},t.prototype.enableHintAutoRefresh=function(){var t,e,n,o=this,i=this.getOption("hintAutoRefreshInterval");return i>=0&&(this._hintsAutoRefreshFunction=(t=function(){return function(t){for(var e=0,n=t.getHints();e<n.length;e++){var o=n[e],i=o.hintTargetElement,r=o.hintPosition,s=o.element;v(r,s,i);}}(o)},e=i,function(){for(var o=[],i=0;i<arguments.length;i++)o[i]=arguments[i];window.clearTimeout(n),n=window.setTimeout((function(){t(o);}),e);}),b.on(window,"scroll",this._hintsAutoRefreshFunction,!0),b.on(window,"resize",this._hintsAutoRefreshFunction,!0)),this},t.prototype.disableHintAutoRefresh=function(){return this._hintsAutoRefreshFunction&&(b.off(window,"scroll",this._hintsAutoRefreshFunction,!0),b.on(window,"resize",this._hintsAutoRefreshFunction,!0),this._hintsAutoRefreshFunction=void 0),this},t.prototype.getOption=function(t){return this._options[t]},t.prototype.setOptions=function(t){return this._options=p(this._options,t),this},t.prototype.setOption=function(t,e){return this._options=u(this._options,t,e),this},t.prototype.clone=function(){return new t(this._targetElement,this._options)},t.prototype.isActive=function(){return this.getOption("isActive")},t.prototype.onHintsAdded=function(t){if(!h(t))throw new Error("Provided callback for onhintsadded was not a function.");return this.callbacks.hintsAdded=t,this},t.prototype.onhintsadded=function(t){this.onHintsAdded(t);},t.prototype.onHintClick=function(t){if(!h(t))throw new Error("Provided callback for onhintclick was not a function.");return this.callbacks.hintClick=t,this},t.prototype.onhintclick=function(t){this.onHintClick(t);},t.prototype.onHintClose=function(t){if(!h(t))throw new Error("Provided callback for onhintclose was not a function.");return this.callbacks.hintClose=t,this},t.prototype.onhintclose=function(t){this.onHintClose(t);},t}();function K(t,e){if(t){var n=function(t){var e=window.getComputedStyle(t),n="absolute"===e.position,o=/(auto|scroll)/;if("fixed"===e.position)return document.body;for(var i=t;i=i.parentElement;)if(e=window.getComputedStyle(i),(!n||"static"!==e.position)&&o.test(e.overflow+e.overflowY+e.overflowX))return i;return document.body}(e);n!==document.body&&(n.scrollTop=e.offsetTop-n.offsetTop);}}function W(t,e,n,o,i){var r;if("off"!==e&&(t&&(r="tooltip"===e?i.getBoundingClientRect():o.getBoundingClientRect(),!function(t){var e=t.getBoundingClientRect();return e.top>=0&&e.left>=0&&e.bottom+80<=window.innerHeight&&e.right<=window.innerWidth}(o)))){var s=H().height;r.bottom-(r.bottom-r.top)<0||o.clientHeight>s?window.scrollBy(0,r.top-(s/2-r.height/2)-n):window.scrollBy(0,r.top-(s/2-r.height/2)+n);}}function Q(){for(var t=0,e=Array.from(l("introjs-showElement"));t<e.length;t++){var n=e[t];j(n,/introjs-[a-zA-Z]+/g);}}function X(t,e,n){if(void 0===n&&(n=!1),n){var o=e.style.opacity||"1";y(e,{opacity:"0"}),window.setTimeout((function(){y(e,{opacity:o});}),10);}t.appendChild(e);}var Y,U=function(t,e,n,o){_(t,e,n.element,"floating"===n.position?0:o);},Z=function(t,e){return (t+1)/e*100};function $(t,e){var n=w("div",{className:"introjs-bullets"});!1===t.getOption("showBullets")&&(n.style.display="none");var o=w("ul");o.setAttribute("role","tablist");for(var i=function(){var e=this.getAttribute("data-step-number");null!=e&&t.goToStep(parseInt(e,10));},r=t.getSteps(),s=0;s<r.length;s++){var a=r[s].step,l=w("li"),c=w("a");l.setAttribute("role","presentation"),c.setAttribute("role","tab"),c.onclick=i,s===e.step-1&&O(c,"active"),C(c),c.innerHTML="&nbsp;",c.setAttribute("data-step-number",a.toString()),l.appendChild(c),o.appendChild(l);}return n.appendChild(o),n}function tt(t,e,n){var o=r(".".concat("introjs-progress"," .").concat("introjs-progressbar"),t);if(o){var i=Z(e,n);o.style.cssText="width:".concat(i,"%;"),o.setAttribute("aria-valuenow",i.toString());}}function et(t,o){var i,s,l;return e(this,void 0,void 0,(function(){var u,p,h,f,g,v,b,m,j,k,x,A,E,T,_,H,N,L,P,R,B,M,D,z,F,J=this;return n(this,(function(V){switch(V.label){case 0:return null===(i=t.callback("change"))||void 0===i||i.call(t,o.element),u=a("introjs-helperLayer"),p=a("introjs-tooltipReferenceLayer"),h="introjs-helperLayer","string"==typeof o.highlightClass&&(h+=" ".concat(o.highlightClass)),"string"==typeof t.getOption("highlightClass")&&(h+=" ".concat(t.getOption("highlightClass"))),null!==u&&null!==p?(b=c("introjs-tooltiptext",p),m=c("introjs-tooltip-title",p),j=c("introjs-arrow",p),k=c("introjs-tooltip",p),v=c("introjs-skipbutton",p),g=c("introjs-prevbutton",p),f=c("introjs-nextbutton",p),O(u,h),k.style.opacity="0",k.style.display="none",K(t.getOption("scrollToElement"),o.element),R=t.getOption("helperElementPadding"),U(t.getTargetElement(),u,o,R),U(t.getTargetElement(),p,o,R),Q(),Y&&window.clearTimeout(Y),x=a("introjs-helperNumberLayer",p),Y=window.setTimeout((function(){var e;null!==x&&(x.innerHTML="".concat(o.step," ").concat(t.getOption("stepNumbersOfLabel")," ").concat(t.getSteps().length)),b.innerHTML=o.intro||"",m.innerHTML=o.title||"",k.style.display="block",I(k,j,o.element,o.position,t.getOption("positionPrecedence"),t.getOption("showStepNumbers"),t.getOption("autoPosition"),null!==(e=o.tooltipClass)&&void 0!==e?e:t.getOption("tooltipClass")),function(t,e,n){if(t){var o=r(".".concat("introjs-bullets"," li > a.").concat("active"),e),i=r(".".concat("introjs-bullets"," li > a[").concat("data-step-number",'="').concat(n.step,'"]'),e);o&&i&&(o.className="",O(i,"active"));}}(t.getOption("showBullets"),p,o),tt(p,t.getCurrentStep(),t.getSteps().length),k.style.opacity="1",(f&&new RegExp("introjs-donebutton","gi").test(f.className)||f)&&f.focus(),W(t.getOption("scrollToElement"),o.scrollTo,t.getOption("scrollPadding"),o.element,b);}),350)):(A=w("div",{className:h}),E=w("div",{className:"introjs-tooltipReferenceLayer"}),T=w("div",{className:"introjs-arrow"}),_=w("div",{className:"introjs-tooltip"}),H=w("div",{className:"introjs-tooltiptext"}),N=w("div",{className:"introjs-tooltip-header"}),L=w("h1",{className:"introjs-tooltip-title"}),P=w("div"),y(A,{"box-shadow":"0 0 1px 2px rgba(33, 33, 33, 0.8), rgba(33, 33, 33, ".concat(t.getOption("overlayOpacity").toString(),") 0 0 0 5000px")}),K(t.getOption("scrollToElement"),o.element),R=t.getOption("helperElementPadding"),U(t.getTargetElement(),A,o,R),U(t.getTargetElement(),E,o,R),X(t.getTargetElement(),A,!0),X(t.getTargetElement(),E),H.innerHTML=o.intro,L.innerHTML=o.title,O(P,"introjs-tooltipbuttons"),!1===t.getOption("showButtons")&&(P.style.display="none"),N.appendChild(L),_.appendChild(N),_.appendChild(H),t.getOption("dontShowAgain")&&(B=w("div",{className:"introjs-dontShowAgain"}),(M=w("input",{type:"checkbox",id:"introjs-dontShowAgain",name:"introjs-dontShowAgain"})).onchange=function(e){t.setDontShowAgain(e.target.checked);},(D=w("label",{htmlFor:"introjs-dontShowAgain"})).innerText=t.getOption("dontShowAgainLabel"),B.appendChild(M),B.appendChild(D),_.appendChild(B)),_.appendChild($(t,o)),_.appendChild(function(t){var e=w("div");O(e,"introjs-progress"),!1===t.getOption("showProgress")&&(e.style.display="none");var n=w("div",{className:"introjs-progressbar"});t.getOption("progressBarAdditionalClass")&&S(n,t.getOption("progressBarAdditionalClass"));var o=Z(t.getCurrentStep(),t.getSteps().length);return n.setAttribute("role","progress"),n.setAttribute("aria-valuemin","0"),n.setAttribute("aria-valuemax","100"),n.setAttribute("aria-valuenow",o.toString()),n.style.cssText="width:".concat(o,"%;"),e.appendChild(n),e}(t)),z=w("div"),!0===t.getOption("showStepNumbers")&&(O(z,"introjs-helperNumberLayer"),z.innerHTML="".concat(o.step," ").concat(t.getOption("stepNumbersOfLabel")," ").concat(t.getSteps().length),_.appendChild(z)),_.appendChild(T),E.appendChild(_),(f=w("a")).onclick=function(){return e(J,void 0,void 0,(function(){var e;return n(this,(function(n){switch(n.label){case 0:return t.isLastStep()?[3,2]:[4,nt(t)];case 1:return n.sent(),[3,5];case 2:return new RegExp("introjs-donebutton","gi").test(f.className)?[4,null===(e=t.callback("complete"))||void 0===e?void 0:e.call(t,t.getCurrentStep(),"done")]:[3,5];case 3:return n.sent(),[4,t.exit()];case 4:n.sent(),n.label=5;case 5:return [2]}}))}))},C(f),f.innerHTML=t.getOption("nextLabel"),(g=w("a")).onclick=function(){return e(J,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return t.getCurrentStep()>0?[4,ot(t)]:[3,2];case 1:e.sent(),e.label=2;case 2:return [2]}}))}))},C(g),g.innerHTML=t.getOption("prevLabel"),C(v=w("a",{className:"introjs-skipbutton"})),v.innerHTML=t.getOption("skipLabel"),v.onclick=function(){return e(J,void 0,void 0,(function(){var e,o;return n(this,(function(n){switch(n.label){case 0:return t.isLastStep()?[4,null===(e=t.callback("complete"))||void 0===e?void 0:e.call(t,t.getCurrentStep(),"skip")]:[3,2];case 1:n.sent(),n.label=2;case 2:return [4,null===(o=t.callback("skip"))||void 0===o?void 0:o.call(t,t.getCurrentStep())];case 3:return n.sent(),[4,t.exit()];case 4:return n.sent(),[2]}}))}))},N.appendChild(v),t.getSteps().length>1&&P.appendChild(g),P.appendChild(f),_.appendChild(P),I(_,T,o.element,o.position,t.getOption("positionPrecedence"),t.getOption("showStepNumbers"),t.getOption("autoPosition"),null!==(s=o.tooltipClass)&&void 0!==s?s:t.getOption("tooltipClass")),W(t.getOption("scrollToElement"),o.scrollTo,t.getOption("scrollPadding"),o.element,_)),(F=a("introjs-disableInteraction",t.getTargetElement()))&&F.parentNode&&F.parentNode.removeChild(F),o.disableInteraction&&function(t,e){var n=a("introjs-disableInteraction");null===n&&(n=w("div",{className:"introjs-disableInteraction"}),t.getTargetElement().appendChild(n)),U(t.getTargetElement(),n,e,t.getOption("helperElementPadding"));}(t,o),0===t.getCurrentStep()&&t.getSteps().length>1?(f&&(O(f,t.getOption("buttonClass"),"introjs-nextbutton"),f.innerHTML=t.getOption("nextLabel")),!0===t.getOption("hidePrev")?(g&&O(g,t.getOption("buttonClass"),"introjs-prevbutton","introjs-hidden"),f&&S(f,"introjs-fullbutton")):g&&O(g,t.getOption("buttonClass"),"introjs-prevbutton","introjs-disabled")):t.isLastStep()||1===t.getSteps().length?(g&&O(g,t.getOption("buttonClass"),"introjs-prevbutton"),!0===t.getOption("hideNext")?(f&&O(f,t.getOption("buttonClass"),"introjs-nextbutton","introjs-hidden"),g&&S(g,"introjs-fullbutton")):f&&(!0===t.getOption("nextToDone")?(f.innerHTML=t.getOption("doneLabel"),S(f,t.getOption("buttonClass"),"introjs-nextbutton","introjs-donebutton")):O(f,t.getOption("buttonClass"),"introjs-nextbutton","introjs-disabled"))):(g&&O(g,t.getOption("buttonClass"),"introjs-prevbutton"),f&&(O(f,t.getOption("buttonClass"),"introjs-nextbutton"),f.innerHTML=t.getOption("nextLabel"))),g&&g.setAttribute("role","button"),f&&f.setAttribute("role","button"),v&&v.setAttribute("role","button"),f&&f.focus(),function(t){S(t,"introjs-showElement");var e=d(t,"position");"absolute"!==e&&"relative"!==e&&"sticky"!==e&&"fixed"!==e&&S(t,"introjs-relativePosition");}(o.element),[4,null===(l=t.callback("afterChange"))||void 0===l?void 0:l.call(t,o.element)];case 1:return V.sent(),[2]}}))}))}function nt(t){var o,i;return e(this,void 0,void 0,(function(){var e;return n(this,(function(n){switch(n.label){case 0:return t.incrementCurrentStep(),e=t.getStep(t.getCurrentStep()),[4,null===(o=t.callback("beforeChange"))||void 0===o?void 0:o.call(t,e&&e.element,t.getCurrentStep(),t.getDirection())];case 1:return !1===n.sent()?(t.decrementCurrentStep(),[2,!1]):t.isEnd()?[4,null===(i=t.callback("complete"))||void 0===i?void 0:i.call(t,t.getCurrentStep(),"end")]:[3,4];case 2:return n.sent(),[4,t.exit()];case 3:return n.sent(),[2,!1];case 4:return [4,et(t,e)];case 5:return n.sent(),[2,!0]}}))}))}function ot(t){var o;return e(this,void 0,void 0,(function(){var e;return n(this,(function(n){switch(n.label){case 0:return t.getCurrentStep()<=0?[2,!1]:(t.decrementCurrentStep(),e=t.getStep(t.getCurrentStep()),[4,null===(o=t.callback("beforeChange"))||void 0===o?void 0:o.call(t,e&&e.element,t.getCurrentStep(),t.getDirection())]);case 1:return !1===n.sent()?(t.incrementCurrentStep(),[2,!1]):[4,et(t,e)];case 2:return n.sent(),[2,!0]}}))}))}var it=function(t){var e,n=[];if(null===(e=t.getOption("steps"))||void 0===e?void 0:e.length)for(var o=0,l=t.getOption("steps");o<l.length;o++){var c=i(l[o]);if(c.step=n.length+1,c.title=c.title||"","string"==typeof c.element&&(c.element=r(c.element)||void 0),!c.element){var u=a("introjsFloatingElement");u||(u=w("div",{className:"introjsFloatingElement"}),document.body.appendChild(u)),c.element=u,c.position="floating";}c.position=c.position||t.getOption("tooltipPosition"),c.scrollTo=c.scrollTo||t.getOption("scrollTo"),void 0===c.disableInteraction&&(c.disableInteraction=t.getOption("disableInteraction")),null!==c.element&&n.push(c);}else {var p=Array.from(s("*[".concat("data-intro","]"),t.getTargetElement()));if(p.length<1)return [];for(var h=[],d=0,f=p;d<f.length;d++){var g=f[d];if((!t.getOption("group")||g.getAttribute("data-intro-group")===t.getOption("group"))&&"none"!==g.style.display){var v=parseInt(g.getAttribute("data-step")||"0",10),b=t.getOption("disableInteraction");g.hasAttribute("data-disable-interaction")&&(b=!!g.getAttribute("data-disable-interaction"));var m={step:v,element:g,title:g.getAttribute("data-title")||"",intro:g.getAttribute("data-intro")||"",tooltipClass:g.getAttribute("data-tooltip-class")||void 0,highlightClass:g.getAttribute("data-highlight-class")||void 0,position:g.getAttribute("data-position")||t.getOption("tooltipPosition"),scrollTo:g.getAttribute("data-scroll-to")||t.getOption("scrollTo"),disableInteraction:b};v>0?n[v-1]=m:h.push(m);}}for(var y=0;h.length>0;y++)if(void 0===n[y]){var C=h.shift();if(!C)break;C.step=y+1,n[y]=C;}}return (n=n.filter((function(t){return t}))).sort((function(t,e){return t.step-e.step})),n};var rt=function(t){return e(void 0,void 0,void 0,(function(){var o,i;return n(this,(function(r){switch(r.label){case 0:return t.isActive()?t.hasStarted()?[2,!1]:[4,null===(i=t.callback("start"))||void 0===i?void 0:i.call(t,t.getTargetElement())]:[2,!1];case 1:return r.sent(),0===(o=it(t)).length?[2,!1]:(t.setSteps(o),function(t){var o=this,i=w("div",{className:"introjs-overlay"});y(i,{top:0,bottom:0,left:0,right:0,position:"fixed"}),t.getTargetElement().appendChild(i),!0===t.getOption("exitOnOverlayClick")&&(y(i,{cursor:"pointer"}),i.onclick=function(){return e(o,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return [4,t.exit()];case 1:return e.sent(),[2]}}))}))});}(t),[4,nt(t)]);case 2:return r.sent(),[2,!0];case 3:return [2,!1]}}))}))},st=function(t){t&&t.parentElement&&t.parentElement.removeChild(t);};function at(t,o){var i,r;return void 0===o&&(o=!1),e(this,void 0,void 0,(function(){var s,c,u,p,h,d,f,g,v,b;return n(this,(function(m){switch(m.label){case 0:return s=t.getTargetElement(),c=!0,[4,null===(i=t.callback("beforeExit"))||void 0===i?void 0:i.call(t,s)];case 1:if(c=m.sent(),!o&&!1===c)return [2,!1];if((u=Array.from(l("introjs-overlay",s)))&&u.length)for(p=0,h=u;p<h.length;p++)d=h[p],st(d);return f=a("introjs-tooltipReferenceLayer",s),st(f),g=a("introjs-disableInteraction",s),st(g),v=a("introjsFloatingElement",s),st(v),Q(),b=a("introjs-helperLayer",s),[4,(w=b,e(void 0,void 0,void 0,(function(){return n(this,(function(t){return w?(y(w,{opacity:"0"}),[2,new Promise((function(t){setTimeout((function(){try{st(w);}catch(t){}finally{t();}}),500);}))]):[2]}))})))];case 2:return m.sent(),[4,null===(r=t.callback("exit"))||void 0===r?void 0:r.call(t)];case 3:return m.sent(),t.setCurrentStep(-1),[2,!0]}var w;}))}))}function lt(t,e,n){var o,i=((o={})[t]=e,o.path="/",o.expires=void 0,o);if(n){var r=new Date;r.setTime(r.getTime()+24*n*60*60*1e3),i.expires=r.toUTCString();}var s=[];for(var a in i)s.push("".concat(a,"=").concat(i[a]));return document.cookie=s.join("; "),ct(t)}function ct(t){return (e={},document.cookie.split(";").forEach((function(t){var n=t.split("="),o=n[0],i=n[1];e[o.trim()]=i;})),e)[t];var e;}function ut(t,e,n){t?lt(e,"true",n):lt(e,"",-1);}function pt(t,e){var n,o=t.getCurrentStep();if(null!=o&&-1!=o){var i=t.getStep(o),r=c("introjs-tooltipReferenceLayer"),s=c("introjs-helperLayer"),l=a("introjs-disableInteraction"),u=t.getTargetElement(),p=t.getOption("helperElementPadding");U(u,s,i,p),U(u,r,i,p),l&&U(u,l,i,p),e&&(t.setSteps(it(t)),function(t,e){if(t.getOption("showBullets")){var n=a("introjs-bullets");n&&n.parentNode&&n.parentNode.replaceChild($(t,e),n);}}(t,i),tt(r,o,t.getSteps().length));var h=document.querySelector(".introjs-arrow"),d=document.querySelector(".introjs-tooltip");return d&&h&&I(d,h,i.element,i.position,t.getOption("positionPrecedence"),t.getOption("showStepNumbers"),t.getOption("autoPosition"),null!==(n=i.tooltipClass)&&void 0!==n?n:t.getOption("tooltipClass")),t}}var ht=function(){function t(t,e){this._steps=[],this._currentStep=-1,this.callbacks={},this._targetElement=m(t),this._options=e?p(this._options,e):{steps:[],isActive:!0,nextLabel:"Next",prevLabel:"Back",skipLabel:"Ã",doneLabel:"Done",hidePrev:!1,hideNext:!1,nextToDone:!0,tooltipPosition:"bottom",tooltipClass:"",group:"",highlightClass:"",exitOnEsc:!0,exitOnOverlayClick:!0,showStepNumbers:!1,stepNumbersOfLabel:"of",keyboardNavigation:!0,showButtons:!0,showBullets:!0,showProgress:!1,scrollToElement:!0,scrollTo:"element",scrollPadding:30,overlayOpacity:.5,autoPosition:!0,positionPrecedence:["bottom","top","right","left"],disableInteraction:!1,dontShowAgain:!1,dontShowAgainLabel:"Don't show this again",dontShowAgainCookie:"introjs-dontShowAgain",dontShowAgainCookieDays:365,helperElementPadding:10,buttonClass:"introjs-button",progressBarAdditionalClass:""};}return t.prototype.callback=function(t){var e=this.callbacks[t];if(h(e))return e},t.prototype.goToStep=function(t){return e(this,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return this.setCurrentStep(t-2),[4,nt(this)];case 1:return e.sent(),[2,this]}}))}))},t.prototype.goToStepNumber=function(t){return e(this,void 0,void 0,(function(){var e;return n(this,(function(n){switch(n.label){case 0:for(e=0;e<this._steps.length;e++)if(this._steps[e].step===t){this.setCurrentStep(e-1);break}return [4,nt(this)];case 1:return n.sent(),[2,this]}}))}))},t.prototype.addStep=function(t){return this._options.steps||(this._options.steps=[]),this._options.steps.push(t),this},t.prototype.addSteps=function(t){if(!t.length)return this;for(var e=0,n=t;e<n.length;e++){var o=n[e];this.addStep(o);}return this},t.prototype.setSteps=function(t){return this._steps=t,this},t.prototype.getSteps=function(){return this._steps},t.prototype.getStep=function(t){return this._steps[t]},t.prototype.getCurrentStep=function(){return this._currentStep},t.prototype.currentStep=function(){return this._currentStep},t.prototype.setCurrentStep=function(t){return t>=this._currentStep?this._direction="forward":this._direction="backward",this._currentStep=t,this},t.prototype.incrementCurrentStep=function(){return -1===this.getCurrentStep()?this.setCurrentStep(0):this.setCurrentStep(this.getCurrentStep()+1),this},t.prototype.decrementCurrentStep=function(){return this.getCurrentStep()>0&&this.setCurrentStep(this._currentStep-1),this},t.prototype.getDirection=function(){return this._direction},t.prototype.nextStep=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return [4,nt(this)];case 1:return t.sent(),[2,this]}}))}))},t.prototype.previousStep=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return [4,ot(this)];case 1:return t.sent(),[2,this]}}))}))},t.prototype.isEnd=function(){return this.getCurrentStep()>=this._steps.length},t.prototype.isLastStep=function(){return this.getCurrentStep()===this._steps.length-1},t.prototype.getTargetElement=function(){return this._targetElement},t.prototype.setOptions=function(t){return this._options=p(this._options,t),this},t.prototype.setOption=function(t,e){return this._options=u(this._options,t,e),this},t.prototype.getOption=function(t){return this._options[t]},t.prototype.clone=function(){return new t(this._targetElement,this._options)},t.prototype.isActive=function(){return (!this.getOption("dontShowAgain")||(t=this.getOption("dontShowAgainCookie"),""===(e=ct(t))||"true"!==e))&&this.getOption("isActive");var t,e;},t.prototype.hasStarted=function(){return this.getCurrentStep()>-1},t.prototype.setDontShowAgain=function(t){return ut(t,this.getOption("dontShowAgainCookie"),this.getOption("dontShowAgainCookieDays")),this},t.prototype.enableKeyboardNavigation=function(){var t=this;return this.getOption("keyboardNavigation")&&(this._keyboardNavigationHandler=function(o){return function(t,o){var i;return e(this,void 0,void 0,(function(){var e,r;return n(this,(function(n){switch(n.label){case 0:return null===(e=void 0===o.code?o.which:o.code)&&(e=null===o.charCode?o.keyCode:o.charCode),"Escape"!==e&&27!==e||!0!==t.getOption("exitOnEsc")?[3,2]:[4,t.exit()];case 1:return n.sent(),[3,16];case 2:return "ArrowLeft"!==e&&37!==e?[3,4]:[4,ot(t)];case 3:return n.sent(),[3,16];case 4:return "ArrowRight"!==e&&39!==e?[3,6]:[4,nt(t)];case 5:return n.sent(),[3,16];case 6:return "Enter"!==e&&"NumpadEnter"!==e&&13!==e?[3,16]:(r=o.target||o.srcElement)&&r.className.match("introjs-prevbutton")?[4,ot(t)]:[3,8];case 7:return n.sent(),[3,15];case 8:return r&&r.className.match("introjs-skipbutton")?t.isEnd()?[4,null===(i=t.callback("complete"))||void 0===i?void 0:i.call(t,t.getCurrentStep(),"skip")]:[3,10]:[3,12];case 9:n.sent(),n.label=10;case 10:return [4,t.exit()];case 11:return n.sent(),[3,15];case 12:return r&&r.getAttribute("data-step-number")?(r.click(),[3,15]):[3,13];case 13:return [4,nt(t)];case 14:n.sent(),n.label=15;case 15:o.preventDefault?o.preventDefault():o.returnValue=!1,n.label=16;case 16:return [2]}}))}))}(t,o)},b.on(window,"keydown",this._keyboardNavigationHandler,!0)),this},t.prototype.disableKeyboardNavigation=function(){return this._keyboardNavigationHandler&&(b.off(window,"keydown",this._keyboardNavigationHandler,!0),this._keyboardNavigationHandler=void 0),this},t.prototype.enableRefreshOnResize=function(){var t=this;this._refreshOnResizeHandler=function(e){pt(t);},b.on(window,"resize",this._refreshOnResizeHandler,!0);},t.prototype.disableRefreshOnResize=function(){this._refreshOnResizeHandler&&(b.off(window,"resize",this._refreshOnResizeHandler,!0),this._refreshOnResizeHandler=void 0);},t.prototype.start=function(){return e(this,void 0,void 0,(function(){return n(this,(function(t){switch(t.label){case 0:return [4,rt(this)];case 1:return t.sent()&&(this.enableKeyboardNavigation(),this.enableRefreshOnResize()),[2,this]}}))}))},t.prototype.exit=function(t){return e(this,void 0,void 0,(function(){return n(this,(function(e){switch(e.label){case 0:return [4,at(this,null!=t&&t)];case 1:return e.sent()&&(this.disableKeyboardNavigation(),this.disableRefreshOnResize()),[2,this]}}))}))},t.prototype.refresh=function(t){return pt(this,t),this},t.prototype.onbeforechange=function(t){return this.onBeforeChange(t)},t.prototype.onBeforeChange=function(t){if(!h(t))throw new Error("Provided callback for onBeforeChange was not a function");return this.callbacks.beforeChange=t,this},t.prototype.onchange=function(t){this.onChange(t);},t.prototype.onChange=function(t){if(!h(t))throw new Error("Provided callback for onChange was not a function.");return this.callbacks.change=t,this},t.prototype.onafterchange=function(t){this.onAfterChange(t);},t.prototype.onAfterChange=function(t){if(!h(t))throw new Error("Provided callback for onAfterChange was not a function");return this.callbacks.afterChange=t,this},t.prototype.oncomplete=function(t){return this.onComplete(t)},t.prototype.onComplete=function(t){if(!h(t))throw new Error("Provided callback for oncomplete was not a function.");return this.callbacks.complete=t,this},t.prototype.onstart=function(t){return this.onStart(t)},t.prototype.onStart=function(t){if(!h(t))throw new Error("Provided callback for onstart was not a function.");return this.callbacks.start=t,this},t.prototype.onexit=function(t){return this.onExit(t)},t.prototype.onExit=function(t){if(!h(t))throw new Error("Provided callback for onexit was not a function.");return this.callbacks.exit=t,this},t.prototype.onskip=function(t){return this.onSkip(t)},t.prototype.onSkip=function(t){if(!h(t))throw new Error("Provided callback for onskip was not a function.");return this.callbacks.skip=t,this},t.prototype.onbeforeexit=function(t){return this.onBeforeExit(t)},t.prototype.onBeforeExit=function(t){if(!h(t))throw new Error("Provided callback for onbeforeexit was not a function.");return this.callbacks.beforeExit=t,this},t}(),dt=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function o(){this.constructor=e;}t(e,n),e.prototype=null===n?Object.create(n):(o.prototype=n.prototype,new o);}(n,e),n.prototype.addHints=function(){console.error("introJs().addHints() is deprecated, please use introJs.hint.addHints() instead.");},n.prototype.addHint=function(){console.error("introJs().addHint() is deprecated, please use introJs.hint.addHint() instead.");},n.prototype.removeHints=function(){console.error("introJs().removeHints() is deprecated, please use introJs.hint.removeHints() instead.");},n}(ht),ft=function(t){return console.warn("introJs() is deprecated. Please use introJs.tour() or introJs.hint() instead."),new dt(t)};ft.tour=function(t){return new ht(t)},ft.hint=function(t){return new q(t)},ft.version="8.0.0-beta.1";

var Intro = function Intro(_ref) {
  var _ref$nextLabel = _ref.nextLabel,
      nextLabel = _ref$nextLabel === void 0 ? 'ä¸ä¸æ­¥' : _ref$nextLabel,
      _ref$prevLabel = _ref.prevLabel,
      prevLabel = _ref$prevLabel === void 0 ? 'ä¸ä¸æ­¥' : _ref$prevLabel,
      _ref$skipLabel = _ref.skipLabel,
      skipLabel = _ref$skipLabel === void 0 ? 'è·³è¿' : _ref$skipLabel,
      _ref$doneLabel = _ref.doneLabel,
      doneLabel = _ref$doneLabel === void 0 ? 'ç«å³ä½éª' : _ref$doneLabel,
      _ref$hidePrev = _ref.hidePrev,
      hidePrev = _ref$hidePrev === void 0 ? true : _ref$hidePrev,
      _ref$hideNext = _ref.hideNext,
      hideNext = _ref$hideNext === void 0 ? true : _ref$hideNext,
      _ref$exitOnOverlayCli = _ref.exitOnOverlayClick,
      exitOnOverlayClick = _ref$exitOnOverlayCli === void 0 ? false : _ref$exitOnOverlayCli,
      _ref$showStepNumbers = _ref.showStepNumbers,
      showStepNumbers = _ref$showStepNumbers === void 0 ? false : _ref$showStepNumbers,
      _ref$disableInteracti = _ref.disableInteraction,
      disableInteraction = _ref$disableInteracti === void 0 ? true : _ref$disableInteracti,
      _ref$showBullets = _ref.showBullets,
      showBullets = _ref$showBullets === void 0 ? false : _ref$showBullets;
  ft().setOptions({
    nextLabel: nextLabel,
    // ä¸ä¸ä¸ªæé®æå­
    prevLabel: prevLabel,
    // ä¸ä¸ä¸ªæé®æå­
    skipLabel: skipLabel,
    // è·³è¿æé®æå­
    doneLabel: doneLabel,
    // å®ææé®æå­
    hidePrev: hidePrev,
    // å¨ç¬¬ä¸æ­¥ä¸­æ¯å¦éèä¸ä¸ä¸ªæé®
    hideNext: hideNext,
    // å¨æåä¸æ­¥ä¸­æ¯å¦éèä¸ä¸ä¸ªæé®
    exitOnOverlayClick: exitOnOverlayClick,
    // ç¹å»å å å±æ¶æ¯å¦éåºä»ç»
    showStepNumbers: showStepNumbers,
    // æ¯å¦æ¾ç¤ºçº¢è²ååçæ­¥éª¤ç¼å·
    disableInteraction: disableInteraction,
    // æ¯å¦ç¦ç¨ä¸çªåºæ¾ç¤ºçæ¡åçåç´ çäº¤äºï¼å°±æ¯ç¦æ­¢ç¹å»
    showBullets: showBullets // æ¯å¦æ¾ç¤ºé¢æ¿æç¤ºç¹

  }).start();
};

Intro.install = function (Vue) {
  Vue.prototype.$Intro = Intro;
};

/**
 * éªè¯çµå­é®ç®±æ ¼å¼
 */
function email(value) {
  return /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/.test(value);
}
/**
 * éªè¯ææºæ ¼å¼
 */


function mobile(value) {
  return /^1[23456789]\d{9}$/.test(value);
}
/**
 * éªè¯URLæ ¼å¼
 */


function url(value) {
  return /^((https|http|ftp|rtsp|mms):\/\/)(([0-9a-zA-Z_!~*'().&=+$%-]+: )?[0-9a-zA-Z_!~*'().&=+$%-]+@)?(([0-9]{1,3}.){3}[0-9]{1,3}|([0-9a-zA-Z_!~*'()-]+.)*([0-9a-zA-Z][0-9a-zA-Z-]{0,61})?[0-9a-zA-Z].[a-zA-Z]{2,6})(:[0-9]{1,4})?((\/?)|(\/[0-9a-zA-Z_!~*'().;?:@&=+$,%#-]+)+\/?)$/.test(value);
}
/**
 * éªè¯æ¥ææ ¼å¼
 */


function date(value) {
  if (!value) return false; // å¤æ­æ¯å¦æ°å¼æèå­ç¬¦ä¸²æ°å¼(æå³çä¸ºæ¶é´æ³)ï¼è½¬ä¸ºæ°å¼ï¼å¦ånew Dateæ æ³è¯å«å­ç¬¦ä¸²æ¶é´æ³

  if (Number(value)) value = +value;
  return !/Invalid|NaN/.test(new Date(value).toString());
}
/**
 * éªè¯èº«ä»½è¯å·ç 
 */


function idCard(value) {
  return /^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/.test(value);
}
/**
 * éé¢,åªåè®¸2ä½å°æ°
 */


function amount(value) {
  // éé¢ï¼åªåè®¸ä¿çä¸¤ä½å°æ°
  return /^[1-9]\d*(,\d{3})*(\.\d{1,2})?$|^0\.\d{1,2}$/.test(value);
}
/**
 * ä¸­æ
 */


function chinese(value) {
  var reg = /^[\u4e00-\u9fa5]+$/gi;
  return reg.test(value);
}
/**
 * åªè½è¾å¥å­æ¯
 */


function letter(value) {
  return /^[a-zA-Z]*$/.test(value);
}
/**
 * åªè½æ¯å­æ¯æèæ°å­
 */


function enOrNum(value) {
  // è±ææèæ°å­
  var reg = /^[0-9a-zA-Z]*$/g;
  return reg.test(value);
}
/**
 * éªè¯æ¯å¦åå«æä¸ªå¼
 */


function contains(value, param) {
  return value.indexOf(param) >= 0;
}
/**
 * éªè¯ä¸ä¸ªå¼èå´[min, max]
 */


function range(value, param) {
  return value >= param[0] && value <= param[1];
}
/**
 * éªè¯ä¸ä¸ªé¿åº¦èå´[min, max]
 */


function rangeLength(value, param) {
  return value.length >= param[0] && value.length <= param[1];
}
/**
 * æ¯å¦jsonå­ç¬¦ä¸²
 */


function jsonString(value) {
  if (typeof value === 'string') {
    try {
      var obj = JSON.parse(value);

      if (_typeof_1(obj) === 'object' && obj) {
        return true;
      }

      return false;
    } catch (e) {
      return false;
    }
  }

  return false;
}
/**
 * å¤æ­æ¯å¦ä¸ºç©º
 */


function empty(value) {
  switch (_typeof_1(value)) {
    case 'undefined':
      return true;

    case 'string':
      if (value.replace(/(^[ \t\n\r]*)|([ \t\n\r]*$)/g, '').length == 0) return true;
      break;

    case 'boolean':
      if (!value) return true;
      break;

    case 'number':
      if (value === 0 || isNaN(value)) return true;
      break;

    case 'object':
      if (value === null || value.length === 0) return true;

      for (var i in value) {
        return false;
      }

      return true;
  }

  return false;
}
/**
 * æ¯å¦æ°ç»
 */


function array(value) {
  if (typeof Array.isArray === 'function') {
    return Array.isArray(value);
  }

  return Object.prototype.toString.call(value) === '[object Array]';
}
/**
 * æ¯å¦å¯¹è±¡
 */


function object(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
}
/**
 * æ¯å¦ç­ä¿¡éªè¯ç 
 */


function code(value) {
  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
  return new RegExp("^\\d{".concat(len, "}$")).test(value);
}
/**
 * æ¯å¦å½æ°æ¹æ³
 * @param {Object} value
 */


function func(value) {
  return typeof value === 'function';
}
/**
 * æ¯å¦promiseå¯¹è±¡
 * @param {Object} value
 */


function promise(value) {
  return object(value) && func(value.then) && func(value.catch);
}
/** æ¯å¦å¾çæ ¼å¼
 * @param {Object} value
 */


function image(value) {
  var IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
  return IMAGE_REGEXP.test(value);
}
/**
 * æ¯å¦è§é¢æ ¼å¼
 * @param {Object} value
 */


function video(value) {
  var VIDEO_REGEXP = /\.(mp4|mpg|mpeg|dat|asf|avi|rm|rmvb|mov|wmv|flv|mkv)/i;
  return VIDEO_REGEXP.test(value);
}

var rule = {
  email: email,
  mobile: mobile,
  url: url,
  date: date,
  idCard: idCard,
  amount: amount,
  chinese: chinese,
  letter: letter,
  enOrNum: enOrNum,
  contains: contains,
  range: range,
  rangeLength: rangeLength,
  jsonString: jsonString,
  isEmpty: empty,
  array: array,
  object: object,
  code: code,
  func: func,
  promise: promise,
  image: image,
  video: video
};

// 20.1.2.4 Number.isNaN(number)


_export(_export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

var jszip_min = createCommonjsModule(function (module, exports) {
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/

!function(e){module.exports=e();}(function(){return function s(a,o,h){function u(r,e){if(!o[r]){if(!a[r]){var t="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&t)return t(r,!0);if(l)return l(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return u(t||e)},i,i.exports,s,a,o,h);}return o[r].exports}for(var l="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<h.length;e++)u(h[e]);return u}({1:[function(e,t,r){var d=e("./utils"),c=e("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,n,i,s,a,o,h=[],u=0,l=e.length,f=l,c="string"!==d.getTypeOf(e);u<e.length;)f=l-u,n=c?(t=e[u++],r=u<l?e[u++]:0,u<l?e[u++]:0):(t=e.charCodeAt(u++),r=u<l?e.charCodeAt(u++):0,u<l?e.charCodeAt(u++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<f?(15&r)<<2|n>>6:64,o=2<f?63&n:64,h.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(e){var t,r,n,i,s,a,o=0,h=0,u="data:";if(e.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=c.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),l[h++]=t,64!==s&&(l[h++]=r),64!==a&&(l[h++]=n);return l};},{"./support":30,"./utils":32}],2:[function(e,t,r){var n=e("./external"),i=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),a=e("./stream/DataLengthProbe");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i;}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",t)},t.exports=o;},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,r){var n=e("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(){return new n("STORE compression")},uncompressWorker:function(){return new n("STORE decompression")}},r.DEFLATE=e("./flate");},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,r){var n=e("./utils");var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==n.getTypeOf(e)?function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e}(0|t,e,e.length,0):function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t.charCodeAt(a))];return -1^e}(0|t,e,e.length,0):0};},{"./utils":32}],5:[function(e,t,r){r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null;},{}],6:[function(e,t,r){var n=null;n="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:n};},{lie:37}],7:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=e("pako"),s=e("./utils"),a=e("./stream/GenericWorker"),o=n?"uint8array":"array";function h(e,t){a.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={};}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1);},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0);},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null;},h.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta});};},r.compressWorker=function(e){return new h("Deflate",e)},r.uncompressWorker=function(){return new h("Inflate",{})};},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,r){function A(e,t){var r,n="";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function n(e,t,r,n,i,s){var a,o,h=e.file,u=e.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),c=I.transformTo("string",O.utf8encode(h.name)),d=h.comment,p=I.transformTo("string",s(d)),m=I.transformTo("string",O.utf8encode(d)),_=c.length!==h.name.length,g=m.length!==d.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===i?(C=798,z|=function(e,t){var r=e;return e||(r=t?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(e){return 63&(e||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+c,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(n,4)+f+b+p}}var I=e("../utils"),i=e("../stream/GenericWorker"),O=e("../utf8"),B=e("../crc32"),R=e("../signature");function s(e,t,r,n){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[];}I.inherits(s,i),s.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}));},s.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=n(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}});}else this.accumulate=!0;},s.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,r=n(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),t)this.push({data:function(e){return R.DATA_DESCRIPTOR+A(e.crc32,4)+A(e.compressedSize,4)+A(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null;},s.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r=this.bytesWritten-e,n=function(e,t,r,n,i){var s=I.transformTo("string",i(n));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(e,2)+A(e,2)+A(t,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,e,this.zipComment,this.encodeFileName);this.push({data:n,meta:{percent:100}});},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume();},s.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end();}),e.on("error",function(e){t.error(e);}),this},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return !1;for(var r=0;r<t.length;r++)try{t[r].error(e);}catch(e){}return !0},s.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock();},t.exports=s;},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,r){var u=e("../compressions"),n=e("./ZipFileWorker");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),h=0;try{e.forEach(function(e,t){h++;var r=function(e,t){var r=e||t,n=u[r];if(!n)throw new Error(r+" is not a valid compression method !");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo("file",{name:e,dir:i,date:s,comment:t.comment||"",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o);}),o.entriesCount=h;}catch(e){o.error(e);}return o};},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,r){function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var e=new n;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e};}(n.prototype=e("./object")).loadAsync=e("./load"),n.support=e("./support"),n.defaults=e("./defaults"),n.version="3.10.1",n.loadAsync=function(e,t){return (new n).loadAsync(e,t)},n.external=e("./external"),t.exports=n;},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,r){var u=e("./utils"),i=e("./external"),n=e("./utf8"),s=e("./zipEntries"),a=e("./stream/Crc32Probe"),l=e("./nodejsUtils");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new a);r.on("error",function(e){t(e);}).on("end",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error("Corrupted zip : CRC32 mismatch")):e();}).resume();})}t.exports=function(e,o){var h=this;return o=u.extend(o||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:n.utf8decode}),l.isNode&&l.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):u.prepareContent("the loaded zip file",e,!0,o.optimizedBinaryString,o.base64).then(function(e){var t=new s(o);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(o.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n],s=i.fileNameStr,a=u.resolve(i.fileNameStr);h.file(a,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:o.createFolders}),i.dir||(h.file(a).unsafeOriginalName=s);}return t.zipComment.length&&(h.comment=t.zipComment),h})};},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,r){var n=e("../utils"),i=e("../stream/GenericWorker");function s(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t);}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}});}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e);}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end();});},s.prototype.pause=function(){return !!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s;},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,r){var i=e("readable-stream").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on("data",function(e,t){n.push(e)||n._helper.pause(),r&&r(t);}).on("error",function(e){n.emit("error",e);}).on("end",function(){n.push(null);});}e("../utils").inherits(n,i),n.prototype._read=function(){this._helper.resume();},t.exports=n;},{"../utils":32,"readable-stream":16}],14:[function(e,t,r){t.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}};},{}],15:[function(e,t,r){function s(e,t,r){var n,i=u.getTypeOf(t),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=g(e)),s.createFolders&&(n=_(e))&&b.call(this,n,!0);var a="string"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t="",s.compression="STORE",i="string");var o=null;o=t instanceof c||t instanceof l?t:p.isNode&&p.isStream(t)?new m(e,t):u.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var h=new d(e,o,s);this.files[e]=h;}var i=e("./utf8"),u=e("./utils"),l=e("./stream/GenericWorker"),a=e("./stream/StreamHelper"),f=e("./defaults"),c=e("./compressedObject"),d=e("./zipObject"),o=e("./generate"),p=e("./nodejsUtils"),m=e("./nodejs/NodejsStreamInputAdapter"),_=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""},g=function(e){return "/"!==e.slice(-1)&&(e+="/"),e},b=function(e,t){return t=void 0!==t?t:f.createFolders,e=g(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function h(e){return "[object RegExp]"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,r,n;for(t in this.files)n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n);},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t);}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(h(e)){var n=e;return this.filter(function(e,t){return !t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=b.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||("/"!==r.slice(-1)&&(r+="/"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,r={};try{if((r=u.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var n=r.comment||this.comment||"";t=o.generateWorker(this,r,n);}catch(e){(t=new l("error")).error(e);}return new a(t,r.type||"string",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return (e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n;},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,r){t.exports=e("stream");},{stream:void 0}],17:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t];}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return -1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return [];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],18:[function(e,t,r){var n=e("../utils");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0;}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e);},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e;},skip:function(e){this.setIndex(this.index+e);},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i;},{"../utils":32}],19:[function(e,t,r){var n=e("./Uint8ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],21:[function(e,t,r){var n=e("./ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,r){var n=e("../utils"),i=e("../support"),s=e("./ArrayReader"),a=e("./StringReader"),o=e("./NodeBufferReader"),h=e("./Uint8ArrayReader");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new o(e):i.uint8array?new h(n.transformTo("uint8array",e)):new s(n.transformTo("array",e)):new a(e)};},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,r){r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b";},{}],24:[function(e,t,r){var n=e("./GenericWorker"),i=e("../utils");function s(e){n.call(this,"ConvertWorker to "+e),this.destType=e;}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta});},t.exports=s;},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,r){var n=e("./GenericWorker"),i=e("../crc32");function s(){n.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0);}e("../utils").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e);},t.exports=s;},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0);}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length;}i.prototype.processChunk.call(this,e);},t.exports=s;},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat();},function(e){t.error(e);});}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null;},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0));},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return !1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t);}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s;},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,r){function n(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null;}n.prototype={push:function(e){this.emit("data",e);},end:function(){if(this.isFinished)return !1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0;}catch(e){this.emit("error",e);}return !0},error:function(e){return !this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[];},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t);},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.end();}),e.on("error",function(e){t.error(e);}),this},pause:function(){return !this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return !1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e);},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e]);},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock();},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=n;},{}],29:[function(e,t,r){var h=e("../utils"),i=e("./ConvertWorker"),s=e("./GenericWorker"),u=e("../base64"),n=e("../support"),a=e("../external"),o=null;if(n.nodestream)try{o=e("../nodejs/NodejsStreamOutputAdapter");}catch(e){}function l(e,o){return new a.Promise(function(t,r){var n=[],i=e._internalType,s=e._outputType,a=e._mimeType;e.on("data",function(e,t){n.push(e),o&&o(t);}).on("error",function(e){n=[],r(e);}).on("end",function(){try{var e=function(e,t,r){switch(e){case"blob":return h.newBlob(h.transformTo("arraybuffer",t),r);case"base64":return u.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case"string":return t.join("");case"array":return Array.prototype.concat.apply([],t);case"uint8array":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case"nodebuffer":return Buffer.concat(t);default:throw new Error("concat : unsupported type '"+e+"'")}}(i,n),a);t(e);}catch(e){r(e);}n=[];}).resume();})}function f(e,t,r){var n=t;switch(t){case"blob":case"arraybuffer":n="uint8array";break;case"base64":n="string";}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock();}catch(e){this._worker=new s("error"),this._worker.error(e);}}f.prototype={accumulate:function(e){return l(this,e)},on:function(e,t){var r=this;return "data"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta);}):this._worker.on(e,function(){h.delay(t,arguments,r);}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},e)}},t.exports=f;},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,t,r){if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else {var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:"application/zip"}).size;}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob("application/zip").size;}catch(e){r.blob=!1;}}}try{r.nodestream=!!e("readable-stream").Readable;}catch(e){r.nodestream=!1;}},{"readable-stream":16}],31:[function(e,t,s){for(var o=e("./utils"),h=e("./support"),r=e("./nodejsUtils"),n=e("./stream/GenericWorker"),u=new Array(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;u[254]=u[254]=1;function a(){n.call(this,"utf-8 decode"),this.leftOver=null;}function l(){n.call(this,"utf-8 encode");}s.utf8encode=function(e){return h.nodebuffer?r.newBufferFrom(e,"utf-8"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=h.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return h.nodebuffer?o.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=u[n]))a[r++]=65533,t+=i-1;else {for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n);}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(h.uint8array?"uint8array":"array",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(h.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length);}else t=this.leftOver.concat(t);this.leftOver=null;}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}(t),i=t;n!==t.length&&(h.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta});},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null);},s.Utf8DecodeWorker=a,o.inherits(l,n),l.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta});},s.Utf8EncodeWorker=l;},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,a){var o=e("./support"),h=e("./base64"),r=e("./nodejsUtils"),u=e("./external");function n(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}e("setimmediate"),a.newBlob=function(t,r){a.checkSupport("blob");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var i={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)"array"===t||"nodebuffer"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join("")},stringifyByChar:function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return !1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return !1}}()}};function s(e){var t=65536,r=a.getTypeOf(e),n=!0;if("uint8array"===r?n=i.applyCanBeUsed.uint8array:"nodebuffer"===r&&(n=i.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return i.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2);}return i.stringifyByChar(e)}function f(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}a.applyFromCharCode=s;var c={};c.string={string:n,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:s,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return s(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:n},a.transformTo=function(e,t){if(t=t||"",!e)return t;a.checkSupport(e);var r=a.getTypeOf(t);return c[r][e](t)},a.resolve=function(e){for(var t=e.split("/"),r=[],n=0;n<t.length;n++){var i=t[n];"."===i||""===i&&0!==n&&n!==t.length-1||(".."===i?r.pop():r.push(i));}return r.join("/")},a.getTypeOf=function(e){return "string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":o.nodebuffer&&r.isBuffer(e)?"nodebuffer":o.uint8array&&e instanceof Uint8Array?"uint8array":o.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(e){if(!o[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+((t=e.charCodeAt(r))<16?"0":"")+t.toString(16).toUpperCase();return n},a.delay=function(e,t,r){setImmediate(function(){e.apply(r||null,t||[]);});},a.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r;},a.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},a.prepareContent=function(r,e,n,i,s){return u.Promise.resolve(e).then(function(n){return o.blob&&(n instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(n)))&&"undefined"!=typeof FileReader?new u.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result);},e.onerror=function(e){r(e.target.error);},e.readAsArrayBuffer(n);}):n}).then(function(e){var t=a.getTypeOf(e);return t?("arraybuffer"===t?e=a.transformTo("uint8array",e):"string"===t&&(s?e=h.decode(e):n&&!0!==i&&(e=function(e){return l(e,o.uint8array?new Uint8Array(e.length):new Array(e.length))}(e))),e):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})};},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(e,t,r){var n=e("./reader/readerFor"),i=e("./utils"),s=e("./signature"),a=e("./zipEntry"),o=e("./support");function h(e){this.files=[],this.loadOptions=e;}h.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r);},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r};},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes();},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw !this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral();}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error("Corrupted zip: missing "+Math.abs(n)+" bytes.")},prepareReader:function(e){this.reader=n(e);},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles();}},t.exports=h;},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(e,t,r){var n=e("./reader/readerFor"),s=e("./utils"),i=e("./compressedObject"),a=e("./crc32"),o=e("./utf8"),h=e("./compressions"),u=e("./support");function l(e,t){this.options=e,this.loadOptions=t;}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in h)if(Object.prototype.hasOwnProperty.call(h,t)&&h[t].magic===e)return h[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize));},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength);},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0);},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4));}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i);},handleUTF8:function(){var e=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else {var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else {var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r);}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else {var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i);}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=l;},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,r){function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions};}var s=e("./stream/StreamHelper"),i=e("./stream/DataWorker"),a=e("./utf8"),o=e("./compressedObject"),h=e("./stream/GenericWorker");n.prototype={internalStream:function(e){var t=null,r="string";try{if(!e)throw new Error("No output type specified.");var n="string"===(r=e.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker));}catch(e){(t=new h("error")).error(e);}return new s(t,r,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new i(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)n.prototype[u[f]]=l;t.exports=n;},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,l,t){(function(t){var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(u),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2;};}else if(t.setImmediate||void 0===t.MessageChannel)r="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){u(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null;},t.document.documentElement.appendChild(e);}:function(){setTimeout(u,0);};else {var o=new t.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0);};}var h=[];function u(){var e,t;n=!0;for(var r=h.length;r;){for(t=h,h=[],e=-1;++e<r;)t[e]();r=h.length;}n=!1;}l.exports=function(e){1!==h.push(e)||n||r();};}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}],37:[function(e,t,r){var i=e("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],n=["PENDING"];function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=n,this.queue=[],this.outcome=void 0,e!==u&&d(this,e);}function h(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected);}function f(t,r,n){i(function(){var e;try{e=r(n);}catch(e){return l.reject(t,e)}e===t?l.reject(t,new TypeError("Cannot resolve promise with itself")):l.resolve(t,e);});}function c(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments);}}function d(t,e){var r=!1;function n(e){r||(r=!0,l.reject(t,e));}function i(e){r||(r=!0,l.resolve(t,e));}var s=p(function(){e(i,n);});"error"===s.status&&n(s.value);}function p(e,t){var r={};try{r.value=e(t),r.status="success";}catch(e){r.status="error",r.value=e;}return r}(t.exports=o).prototype.finally=function(t){if("function"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var r=new this.constructor(u);this.state!==n?f(r,this.state===a?e:t,this.outcome):this.queue.push(new h(r,e,t));return r},h.prototype.callFulfilled=function(e){l.resolve(this.promise,e);},h.prototype.otherCallFulfilled=function(e){f(this.promise,this.onFulfilled,e);},h.prototype.callRejected=function(e){l.reject(this.promise,e);},h.prototype.otherCallRejected=function(e){f(this.promise,this.onRejected,e);},l.resolve=function(e,t){var r=p(c,t);if("error"===r.status)return l.reject(e,r.value);var n=r.value;if(n)d(e,n);else {e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t);}return e},l.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){if(e instanceof this)return e;return l.resolve(new this(u),e)},o.reject=function(e){var t=new this(u);return l.reject(t,e)},o.all=function(e){var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,i=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,t=-1,o=new this(u);for(;++t<n;)h(e[t],t);return o;function h(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,l.resolve(o,s));},function(e){i||(i=!0,l.reject(o,e));});}},o.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,n=!1;if(!r)return this.resolve([]);var i=-1,s=new this(u);for(;++i<r;)a=e[i],t.resolve(a).then(function(e){n||(n=!0,l.resolve(s,e));},function(e){n||(n=!0,l.reject(s,e));});var a;return s};},{immediate:36}],38:[function(e,t,r){var n={};(0, e("./lib/utils/common").assign)(n,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=n;},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,r){var a=e("./zlib/deflate"),o=e("./utils/common"),h=e("./utils/strings"),i=e("./zlib/messages"),s=e("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,c=0,d=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:f,method:d,chunkSize:16384,windowBits:15,memLevel:8,strategy:c,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==l)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n="string"==typeof t.dictionary?h.string2buf(t.dictionary):"[object ArrayBuffer]"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==l)throw new Error(i[r]);this._dict_set=!0;}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return !1;n=t===~~t?t:!0===t?4:0,"string"==typeof e?i.input=h.string2buf(e):"[object ArrayBuffer]"===u.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)));}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==n||(this.onEnd(l),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e);},p.prototype.onEnd=function(e){e===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return (t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return (t=t||{}).gzip=!0,n(e,t)};},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,r){var c=e("./zlib/inflate"),d=e("./utils/common"),p=e("./utils/strings"),m=e("./zlib/constants"),n=e("./zlib/messages"),i=e("./zlib/zstream"),s=e("./zlib/gzheader"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=d.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=c.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,c.inflateGetHeader(this.strm,this.header);}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return !1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof e?h.input=p.binstring2buf(e):"[object ArrayBuffer]"===_.call(e)?h.input=new Uint8Array(e):h.input=e,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new d.Buf8(u),h.next_out=0,h.avail_out=u),(r=c.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=c.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(i=p.utf8border(h.output,h.next_out),s=h.next_out-i,a=p.buf2string(h.output,i),h.next_out=s,h.avail_out=u-s,s&&d.arraySet(h.output,h.output,i,s,0),this.onData(a)):this.onData(d.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0);}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=c.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e);},a.prototype.onEnd=function(e){e===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return (t=t||{}).raw=!0,o(e,t)},r.ungzip=o;},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){return [].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s));},r.setTyped(n);},{}],42:[function(e,t,r){var h=e("./common"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0]);}catch(e){i=!1;}try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){s=!1;}for(var u=new h.Buf8(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function l(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,h.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}u[254]=u[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new h.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return l(e,e.length)},r.binstring2buf=function(e){for(var t=new h.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=u[i]))o[n++]=65533,r+=s-1;else {for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i);}return l(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t};},{"./common":41}],43:[function(e,t,r){t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521;}return i|s<<16|0};},{}],44:[function(e,t,r){t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};},{}],45:[function(e,t,r){var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e};},{}],46:[function(e,t,r){var h,c=e("../utils/common"),u=e("./trees"),d=e("./adler32"),p=e("./crc32"),n=e("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,i=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(e,t){return e.msg=n[t],t}function T(e){return (e<<1)-(4<e?9:0)}function D(e){for(var t=e.length;0<=--t;)e[t]=0;}function F(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(c.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0));}function N(e,t){u._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,F(e.strm);}function U(e,t){e.pending_buf[e.pending++]=t;}function P(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;}function L(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,h=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,u=e.window,l=e.w_mask,f=e.prev,c=e.strstart+S,d=u[s+a-1],p=u[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(u[(r=t)+a]===p&&u[r+a-1]===d&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<c);if(n=S-(c-s),s=c-S,a<n){if(e.match_start=t,o<=(a=n))break;d=u[s+a-1],p=u[s+a];}}}while((t=f[t&l])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function j(e){var t,r,n,i,s,a,o,h,u,l,f=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=f+(f-z)){for(c.arraySet(e.window,e.window,f,f,0),e.match_start-=f,e.strstart-=f,e.block_start-=f,t=r=e.hash_size;n=e.head[--t],e.head[t]=f<=n?n-f:0,--r;);for(t=r=f;n=e.prev[--t],e.prev[t]=f<=n?n-f:0,--r;);i+=f;}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,h=e.strstart+e.lookahead,u=i,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,c.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=d(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),e.lookahead+=r,e.lookahead+e.insert>=x)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+x-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<x)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function Z(e,t){for(var r,n;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r)),e.match_length>=x)if(n=u._tr_tally(e,e.strstart-e.match_start,e.match_length-x),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=x){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function W(e,t){for(var r,n,i;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=x-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===x&&4096<e.strstart-e.match_start)&&(e.match_length=x-1)),e.prev_length>=x&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-x,n=u._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-x),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=x-1,e.strstart++,n&&(N(e,!1),0===e.strm.avail_out))return A}else if(e.match_available){if((n=u._tr_tally(e,0,e.window[e.strstart-1]))&&N(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return A}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(n=u._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function M(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i;}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new c.Buf16(2*w),this.dyn_dtree=new c.Buf16(2*(2*a+1)),this.bl_tree=new c.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new c.Buf16(k+1),this.heap=new c.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new c.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}function G(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?C:E,e.adler=2===t.wrap?0:1,t.last_flush=l,u._tr_init(t),m):R(e,_)}function K(e){var t=G(e);return t===m&&function(e){e.window_size=2*e.w_size,D(e.head),e.max_lazy_match=h[e.level].max_lazy,e.good_match=h[e.level].good_length,e.nice_match=h[e.level].nice_length,e.max_chain_length=h[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=x-1,e.match_available=0,e.ins_h=0;}(e.state),t}function Y(e,t,r,n,i,s){if(!e)return _;var a=1;if(t===g&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||y<i||r!==v||n<8||15<n||t<0||9<t||s<0||b<s)return R(e,_);8===n&&(n=9);var o=new H;return (e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new c.Buf8(2*o.w_size),o.head=new c.Buf16(o.hash_size),o.prev=new c.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new c.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,K(e)}h=[new M(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(j(e),0===e.lookahead&&t===l)return A;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,N(e,!1),0===e.strm.avail_out))return A;if(e.strstart-e.block_start>=e.w_size-z&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):(e.strstart>e.block_start&&(N(e,!1),e.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(e,t){return Y(e,t,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?_:(e.state.gzhead=t,m):_},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?R(e,_):_;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&t!==f)return R(e,0===e.avail_out?-5:_);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===C)if(2===n.wrap)e.adler=0,U(n,31),U(n,139),U(n,8),n.gzhead?(U(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),U(n,255&n.gzhead.time),U(n,n.gzhead.time>>8&255),U(n,n.gzhead.time>>16&255),U(n,n.gzhead.time>>24&255),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(U(n,255&n.gzhead.extra.length),U(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(U(n,0),U(n,0),U(n,0),U(n,0),U(n,0),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,3),n.status=E);else {var a=v+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=E,P(n,a),0!==n.strstart&&(P(n,e.adler>>>16),P(n,65535&e.adler)),e.adler=1;}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending!==n.pending_buf_size));)U(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73);}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91);}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103);}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&F(e),n.pending+2<=n.pending_buf_size&&(U(n,255&e.adler),U(n,e.adler>>8&255),e.adler=0,n.status=E)):n.status=E),0!==n.pending){if(F(e),0===e.avail_out)return n.last_flush=-1,m}else if(0===e.avail_in&&T(t)<=T(r)&&t!==f)return R(e,-5);if(666===n.status&&0!==e.avail_in)return R(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==l&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(j(e),0===e.lookahead)){if(t===l)return A;break}if(e.match_length=0,r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=S){if(j(e),e.lookahead<=S&&t===l)return A;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=x&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+S;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=S-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=x?(r=u._tr_tally(e,1,e.match_length-x),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):h[n.level].func(n,t);if(o!==O&&o!==B||(n.status=666),o===A||o===O)return 0===e.avail_out&&(n.last_flush=-1),m;if(o===I&&(1===t?u._tr_align(n):5!==t&&(u._tr_stored_block(n,0,0,!1),3===t&&(D(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),F(e),0===e.avail_out))return n.last_flush=-1,m}return t!==f?m:n.wrap<=0?1:(2===n.wrap?(U(n,255&e.adler),U(n,e.adler>>8&255),U(n,e.adler>>16&255),U(n,e.adler>>24&255),U(n,255&e.total_in),U(n,e.total_in>>8&255),U(n,e.total_in>>16&255),U(n,e.total_in>>24&255)):(P(n,e.adler>>>16),P(n,65535&e.adler)),F(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?m:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==C&&69!==t&&73!==t&&91!==t&&103!==t&&t!==E&&666!==t?R(e,_):(e.state=null,t===E?R(e,-3):m):_},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,h,u,l=t.length;if(!e||!e.state)return _;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(e.adler=d(e.adler,t,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new c.Buf8(r.w_size),c.arraySet(u,t,l-r.w_size,r.w_size,0),t=u,l=r.w_size),a=e.avail_in,o=e.next_in,h=e.input,e.avail_in=l,e.next_in=0,e.input=t,j(r);r.lookahead>=x;){for(n=r.strstart,i=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+x-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=x-1,j(r);}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,e.next_in=o,e.input=h,e.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,r){t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};},{}],48:[function(e,t,r){t.exports=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=m[d&g];t:for(;;){if(d>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else {if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&v,(y&=15)&&(p<y&&(d+=z[n++]<<p,p+=8),w+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=_[d&b];r:for(;;){if(d>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(k=65535&v,p<(y&=15)&&(d+=z[n++]<<p,(p+=8)<y&&(d+=z[n++]<<p,p+=8)),h<(k+=d&(1<<y)-1)){e.msg="invalid distance too far back",r.mode=30;break e}if(d>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(S=c,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=c[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=c[x++],--y;);x=s-k,S=C;}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]));}else {for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]));}break}}break}}while(n<i&&s<o);n-=w=p>>3,d&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=d,r.bits=p;};},{}],49:[function(e,t,r){var I=e("../utils/common"),O=e("./adler32"),B=e("./crc32"),R=e("./inffast"),T=e("./inftrees"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return (e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function h(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function u(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=h(e,t))!==N&&(e.state=null),r):U}var l,f,c=!0;function j(e){if(c){var t;for(l=new I.Buf32(512),f=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,l,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,f,0,e.work,{bits:5}),c=!1;}e.lencode=l,e.lenbits=9,e.distcode=f,e.distbits=5;}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(e){return u(e,15)},r.inflateInit2=u,r.inflate=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,f=o,c=h,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){e.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.flags=u,8!=(255&r.flags)){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0;}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(d=r.length)&&(d=o),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,d,k)),512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=u=0;}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}e.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;u>>>=2,l-=2;break e;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30;}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if((65535&u)!=(u>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(d=r.length){if(o<d&&(d=o),h<d&&(d=h),0===d)break e;I.arraySet(i,n,s,d,a),o-=d,s+=d,h-=d,a+=d,r.length-=d;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3;}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else {if(16===b){for(z=_+2;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u>>>=_,l-=_,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],d=3+(3&u),u>>>=2,l-=2;}else if(17===b){for(z=_+3;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=3+(7&(u>>>=_)),u>>>=3,l-=3;}else {for(z=_+7;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=11+(127&(u>>>=_)),u>>>=7,l-=7;}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=k;}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=h){e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,R(e,c),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,64&g){e.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break e;if(d=c-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}p=d>r.wnext?(d-=r.wnext,r.wsize-d):r.wnext-d,d>r.length&&(d=r.length),m=r.window;}else m=i,p=a-r.offset,d=r.length;for(h<d&&(d=h),h-=d,r.length-=d;i[a++]=m[p++],--d;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break e;i[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break e;o--,u|=n[s++]<<l,l+=8;}if(c-=h,e.total_out+=c,r.total+=c,c&&(e.adler=r.check=r.flags?B(r.check,i,c,a-c):O(r.check,i,c,a-c)),c=h,(r.flags?u:L(u))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=u=0;}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=u=0;}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return -4;case 32:default:return U}return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,(r.wsize||c!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,c-e.avail_out)?(r.mode=31,-4):(f-=e.avail_in,c-=e.avail_out,e.total_in+=f,e.total_out+=c,r.total+=c,r.wrap&&c&&(e.adler=r.check=r.flags?B(r.check,i,c,e.next_out-c):O(r.check,i,c,e.next_out-c)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===c||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,r){var D=e("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var h,u,l,f,c,d,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<n;v++)O[t[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return -1;if(0<z&&(0===e||1!==w))return -1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<n;v++)0!==t[r+v]&&(a[B[t[r+v]]++]=v);if(d=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,c=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<d?(m=0,a[v]):a[v]>d?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;i[c+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=t[r+a[v]];}if(k<b&&(E&f)!==l){for(0===S&&(S=k),c+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[l=E&f]=k<<24|x<<16|c-s|0;}}return 0!==E&&(i[c+E]=b-S<<24|64<<16|0),o.bits=k,0};},{"../utils/common":41}],51:[function(e,t,r){t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};},{}],52:[function(e,t,r){var i=e("../utils/common"),o=0,h=1;function n(e){for(var t=e.length;0<=--t;)e[t]=0;}var s=0,a=29,u=256,l=u+1+a,f=30,c=19,_=2*l+1,g=15,d=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));n(z);var C=new Array(2*f);n(C);var E=new Array(512);n(E);var A=new Array(256);n(A);var I=new Array(a);n(I);var O,B,R,T=new Array(f);function D(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length;}function F(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}function N(e){return e<256?E[e]:E[256+(e>>>7)]}function U(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;}function P(e,t,r){e.bi_valid>d-r?(e.bi_buf|=t<<e.bi_valid&65535,U(e,e.bi_buf),e.bi_buf=t>>d-e.bi_valid,e.bi_valid+=r-d):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r);}function L(e,t,r){P(e,r[2*t],r[2*t+1]);}function j(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function Z(e,t,r){var n,i,s=new Array(g+1),a=0;for(n=1;n<=g;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=j(s[o]++,o));}}function W(e){var t;for(t=0;t<l;t++)e.dyn_ltree[2*t]=0;for(t=0;t<f;t++)e.dyn_dtree[2*t]=0;for(t=0;t<c;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*m]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0;}function M(e){8<e.bi_valid?U(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;}function H(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function G(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&H(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!H(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n;}function K(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?L(e,i,t):(L(e,(s=A[i])+u+1,t),0!==(a=w[s])&&P(e,i-=I[s],a),L(e,s=N(--n),r),0!==(a=k[s])&&P(e,n-=T[s],a)),o<e.last_lit;);L(e,m,t);}function Y(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,h=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(e.heap[++e.heap_len]=u=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=u,r=e.heap_len>>1;1<=r;r--)G(e,s,r);for(i=h;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],G(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,G(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,h=t.dyn_tree,u=t.max_code,l=t.stat_desc.static_tree,f=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=g;s++)e.bl_count[s]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)p<(s=h[2*h[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),h[2*n+1]=s,u<n||(e.bl_count[s]++,a=0,d<=n&&(a=c[n-d]),o=h[2*n],e.opt_len+=o*(s+a),f&&(e.static_len+=o*(l[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2;}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)u<(i=e.heap[--r])||(h[2*i+1]!==s&&(e.opt_len+=(s-h[2*i+1])*h[2*i],h[2*i+1]=s),n--);}}(e,t),Z(s,u,e.bl_count);}function X(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<h&&i===a||(o<u?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[2*b]++):o<=10?e.bl_tree[2*v]++:e.bl_tree[2*y]++,s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4));}function V(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<h&&i===a)){if(o<u)for(;L(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(L(e,i,e.bl_tree),o--),L(e,b,e.bl_tree),P(e,o-3,2)):o<=10?(L(e,v,e.bl_tree),P(e,o-3,3)):(L(e,y,e.bl_tree),P(e,o-11,7));s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4);}}n(T);var q=!1;function J(e,t,r,n){P(e,(s<<1)+(n?1:0),3),function(e,t,r,n){M(e),n&&(U(e,r),U(e,~r)),i.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r;}(e,t,r,!0);}r._tr_init=function(e){q||(function(){var e,t,r,n,i,s=new Array(g+1);for(n=r=0;n<a-1;n++)for(I[n]=r,e=0;e<1<<w[n];e++)A[r++]=n;for(A[r-1]=n,n=i=0;n<16;n++)for(T[n]=i,e=0;e<1<<k[n];e++)E[i++]=n;for(i>>=7;n<f;n++)for(T[n]=i<<7,e=0;e<1<<k[n]-7;e++)E[256+i++]=n;for(t=0;t<=g;t++)s[t]=0;for(e=0;e<=143;)z[2*e+1]=8,e++,s[8]++;for(;e<=255;)z[2*e+1]=9,e++,s[9]++;for(;e<=279;)z[2*e+1]=7,e++,s[7]++;for(;e<=287;)z[2*e+1]=8,e++,s[8]++;for(Z(z,l+1,s),e=0;e<f;e++)C[2*e+1]=5,C[2*e]=j(e,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,c,p);}(),q=!0),e.l_desc=new F(e.dyn_ltree,O),e.d_desc=new F(e.dyn_dtree,B),e.bl_desc=new F(e.bl_tree,R),e.bi_buf=0,e.bi_valid=0,W(e);},r._tr_stored_block=J,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return h;for(t=32;t<u;t++)if(0!==e.dyn_ltree[2*t])return h;return o}(e)),Y(e,e.l_desc),Y(e,e.d_desc),a=function(e){var t;for(X(e,e.dyn_ltree,e.l_desc.max_code),X(e,e.dyn_dtree,e.d_desc.max_code),Y(e,e.bl_desc),t=c-1;3<=t&&0===e.bl_tree[2*S[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?J(e,t,r,n):4===e.strategy||s===i?(P(e,2+(n?1:0),3),K(e,z,C)):(P(e,4+(n?1:0),3),function(e,t,r,n){var i;for(P(e,t-257,5),P(e,r-1,5),P(e,n-4,4),i=0;i<n;i++)P(e,e.bl_tree[2*S[i]+1],3);V(e,e.dyn_ltree,t-1),V(e,e.dyn_dtree,r-1);}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),K(e,e.dyn_ltree,e.dyn_dtree)),W(e),n&&M(e);},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(A[r]+u+1)]++,e.dyn_dtree[2*N(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){P(e,2,3),L(e,m,z),function(e){16===e.bi_valid?(U(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8);}(e);};},{"../utils/common":41}],53:[function(e,t,r){t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};},{}],54:[function(e,t,r){(function(e){!function(r,n){if(!r.setImmediate){var i,s,t,a,o=1,h={},u=!1,l=r.document,e=Object.getPrototypeOf&&Object.getPrototypeOf(r);e=e&&e.setTimeout?e:r,i="[object process]"==={}.toString.call(r.process)?function(e){process.nextTick(function(){c(e);});}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1;},r.postMessage("","*"),r.onmessage=t,e}}()?(a="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",d,!1):r.attachEvent("onmessage",d),function(e){r.postMessage(a+e,"*");}):r.MessageChannel?((t=new MessageChannel).port1.onmessage=function(e){c(e.data);},function(e){t.port2.postMessage(e);}):l&&"onreadystatechange"in l.createElement("script")?(s=l.documentElement,function(e){var t=l.createElement("script");t.onreadystatechange=function(){c(e),t.onreadystatechange=null,s.removeChild(t),t=null;},s.appendChild(t);}):function(e){setTimeout(c,0,e);},e.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var n={callback:e,args:t};return h[o]=n,i(o),o++},e.clearImmediate=f;}function f(e){delete h[e];}function c(e){if(u)setTimeout(c,0,e);else {var t=h[e];if(t){u=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r);}}(t);}finally{f(e),u=!1;}}}}function d(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(a)&&c(+e.data.slice(a.length));}}("undefined"==typeof self?void 0===e?this:e:self);}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[10])(10)});
});

var FileSaver_min = createCommonjsModule(function (module, exports) {
(function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


});

var domToImage = createCommonjsModule(function (module) {
(function (global) {

    var util = newUtil();
    var inliner = newInliner();
    var fontFaces = newFontFaces();
    var images = newImages();

    // Default impl options
    var defaultOptions = {
        // Default is to fail on error, no placeholder
        imagePlaceholder: undefined,
        // Default cache bust is false, it will use the cache
        cacheBust: false
    };

    var domtoimage = {
        toSvg: toSvg,
        toPng: toPng,
        toJpeg: toJpeg,
        toBlob: toBlob,
        toPixelData: toPixelData,
        impl: {
            fontFaces: fontFaces,
            images: images,
            util: util,
            inliner: inliner,
            options: {}
        }
    };

    module.exports = domtoimage;


    /**
     * @param {Node} node - The DOM Node object to render
     * @param {Object} options - Rendering options
     * @param {Function} options.filter - Should return true if passed node should be included in the output
     *          (excluding node means excluding it's children as well). Not called on the root node.
     * @param {String} options.bgcolor - color for the background, any valid CSS color value.
     * @param {Number} options.width - width to be applied to node before rendering.
     * @param {Number} options.height - height to be applied to node before rendering.
     * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.
     * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),
                defaults to 1.0.
     * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch
     * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url
     * @return {Promise} - A promise that is fulfilled with a SVG image data URL
     * */
    function toSvg(node, options) {
        options = options || {};
        copyOptions(options);
        return Promise.resolve(node)
            .then(function (node) {
                return cloneNode(node, options.filter, true);
            })
            .then(embedFonts)
            .then(inlineImages)
            .then(applyOptions)
            .then(function (clone) {
                return makeSvgDataUri(clone,
                    options.width || util.width(node),
                    options.height || util.height(node)
                );
            });

        function applyOptions(clone) {
            if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;

            if (options.width) clone.style.width = options.width + 'px';
            if (options.height) clone.style.height = options.height + 'px';

            if (options.style)
                Object.keys(options.style).forEach(function (property) {
                    clone.style[property] = options.style[property];
                });

            return clone;
        }
    }

    /**
     * @param {Node} node - The DOM Node object to render
     * @param {Object} options - Rendering options, @see {@link toSvg}
     * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.
     * */
    function toPixelData(node, options) {
        return draw(node, options || {})
            .then(function (canvas) {
                return canvas.getContext('2d').getImageData(
                    0,
                    0,
                    util.width(node),
                    util.height(node)
                ).data;
            });
    }

    /**
     * @param {Node} node - The DOM Node object to render
     * @param {Object} options - Rendering options, @see {@link toSvg}
     * @return {Promise} - A promise that is fulfilled with a PNG image data URL
     * */
    function toPng(node, options) {
        return draw(node, options || {})
            .then(function (canvas) {
                return canvas.toDataURL();
            });
    }

    /**
     * @param {Node} node - The DOM Node object to render
     * @param {Object} options - Rendering options, @see {@link toSvg}
     * @return {Promise} - A promise that is fulfilled with a JPEG image data URL
     * */
    function toJpeg(node, options) {
        options = options || {};
        return draw(node, options)
            .then(function (canvas) {
                return canvas.toDataURL('image/jpeg', options.quality || 1.0);
            });
    }

    /**
     * @param {Node} node - The DOM Node object to render
     * @param {Object} options - Rendering options, @see {@link toSvg}
     * @return {Promise} - A promise that is fulfilled with a PNG image blob
     * */
    function toBlob(node, options) {
        return draw(node, options || {})
            .then(util.canvasToBlob);
    }

    function copyOptions(options) {
        // Copy options to impl options for use in impl
        if(typeof(options.imagePlaceholder) === 'undefined') {
            domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
        } else {
            domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
        }

        if(typeof(options.cacheBust) === 'undefined') {
            domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
        } else {
            domtoimage.impl.options.cacheBust = options.cacheBust;
        }
    }

    function draw(domNode, options) {
        return toSvg(domNode, options)
            .then(util.makeImage)
            .then(util.delay(100))
            .then(function (image) {
                var canvas = newCanvas(domNode);
                canvas.getContext('2d').drawImage(image, 0, 0);
                return canvas;
            });

        function newCanvas(domNode) {
            var canvas = document.createElement('canvas');
            canvas.width = options.width || util.width(domNode);
            canvas.height = options.height || util.height(domNode);

            if (options.bgcolor) {
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = options.bgcolor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            return canvas;
        }
    }

    function cloneNode(node, filter, root) {
        if (!root && filter && !filter(node)) return Promise.resolve();

        return Promise.resolve(node)
            .then(makeNodeCopy)
            .then(function (clone) {
                return cloneChildren(node, clone, filter);
            })
            .then(function (clone) {
                return processClone(node, clone);
            });

        function makeNodeCopy(node) {
            if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL());
            return node.cloneNode(false);
        }

        function cloneChildren(original, clone, filter) {
            var children = original.childNodes;
            if (children.length === 0) return Promise.resolve(clone);

            return cloneChildrenInOrder(clone, util.asArray(children), filter)
                .then(function () {
                    return clone;
                });

            function cloneChildrenInOrder(parent, children, filter) {
                var done = Promise.resolve();
                children.forEach(function (child) {
                    done = done
                        .then(function () {
                            return cloneNode(child, filter);
                        })
                        .then(function (childClone) {
                            if (childClone) parent.appendChild(childClone);
                        });
                });
                return done;
            }
        }

        function processClone(original, clone) {
            if (!(clone instanceof Element)) return clone;

            return Promise.resolve()
                .then(cloneStyle)
                .then(clonePseudoElements)
                .then(copyUserInput)
                .then(fixSvg)
                .then(function () {
                    return clone;
                });

            function cloneStyle() {
                copyStyle(window.getComputedStyle(original), clone.style);

                function copyStyle(source, target) {
                    if (source.cssText) target.cssText = source.cssText;
                    else copyProperties(source, target);

                    function copyProperties(source, target) {
                        util.asArray(source).forEach(function (name) {
                            target.setProperty(
                                name,
                                source.getPropertyValue(name),
                                source.getPropertyPriority(name)
                            );
                        });
                    }
                }
            }

            function clonePseudoElements() {
                [':before', ':after'].forEach(function (element) {
                    clonePseudoElement(element);
                });

                function clonePseudoElement(element) {
                    var style = window.getComputedStyle(original, element);
                    var content = style.getPropertyValue('content');

                    if (content === '' || content === 'none') return;

                    var className = util.uid();
                    clone.className = clone.className + ' ' + className;
                    var styleElement = document.createElement('style');
                    styleElement.appendChild(formatPseudoElementStyle(className, element, style));
                    clone.appendChild(styleElement);

                    function formatPseudoElementStyle(className, element, style) {
                        var selector = '.' + className + ':' + element;
                        var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style);
                        return document.createTextNode(selector + '{' + cssText + '}');

                        function formatCssText(style) {
                            var content = style.getPropertyValue('content');
                            return style.cssText + ' content: ' + content + ';';
                        }

                        function formatCssProperties(style) {

                            return util.asArray(style)
                                .map(formatProperty)
                                .join('; ') + ';';

                            function formatProperty(name) {
                                return name + ': ' +
                                    style.getPropertyValue(name) +
                                    (style.getPropertyPriority(name) ? ' !important' : '');
                            }
                        }
                    }
                }
            }

            function copyUserInput() {
                if (original instanceof HTMLTextAreaElement) clone.innerHTML = original.value;
                if (original instanceof HTMLInputElement) clone.setAttribute("value", original.value);
            }

            function fixSvg() {
                if (!(clone instanceof SVGElement)) return;
                clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

                if (!(clone instanceof SVGRectElement)) return;
                ['width', 'height'].forEach(function (attribute) {
                    var value = clone.getAttribute(attribute);
                    if (!value) return;

                    clone.style.setProperty(attribute, value);
                });
            }
        }
    }

    function embedFonts(node) {
        return fontFaces.resolveAll()
            .then(function (cssText) {
                var styleNode = document.createElement('style');
                node.appendChild(styleNode);
                styleNode.appendChild(document.createTextNode(cssText));
                return node;
            });
    }

    function inlineImages(node) {
        return images.inlineAll(node)
            .then(function () {
                return node;
            });
    }

    function makeSvgDataUri(node, width, height) {
        return Promise.resolve(node)
            .then(function (node) {
                node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                return new XMLSerializer().serializeToString(node);
            })
            .then(util.escapeXhtml)
            .then(function (xhtml) {
                return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + '</foreignObject>';
            })
            .then(function (foreignObject) {
                return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                    foreignObject + '</svg>';
            })
            .then(function (svg) {
                return 'data:image/svg+xml;charset=utf-8,' + svg;
            });
    }

    function newUtil() {
        return {
            escape: escape,
            parseExtension: parseExtension,
            mimeType: mimeType,
            dataAsUrl: dataAsUrl,
            isDataUrl: isDataUrl,
            canvasToBlob: canvasToBlob,
            resolveUrl: resolveUrl,
            getAndEncode: getAndEncode,
            uid: uid(),
            delay: delay,
            asArray: asArray,
            escapeXhtml: escapeXhtml,
            makeImage: makeImage,
            width: width,
            height: height
        };

        function mimes() {
            /*
             * Only WOFF and EOT mime types for fonts are 'real'
             * see http://www.iana.org/assignments/media-types/media-types.xhtml
             */
            var WOFF = 'application/font-woff';
            var JPEG = 'image/jpeg';

            return {
                'woff': WOFF,
                'woff2': WOFF,
                'ttf': 'application/font-truetype',
                'eot': 'application/vnd.ms-fontobject',
                'png': 'image/png',
                'jpg': JPEG,
                'jpeg': JPEG,
                'gif': 'image/gif',
                'tiff': 'image/tiff',
                'svg': 'image/svg+xml'
            };
        }

        function parseExtension(url) {
            var match = /\.([^\.\/]*?)$/g.exec(url);
            if (match) return match[1];
            else return '';
        }

        function mimeType(url) {
            var extension = parseExtension(url).toLowerCase();
            return mimes()[extension] || '';
        }

        function isDataUrl(url) {
            return url.search(/^(data:)/) !== -1;
        }

        function toBlob(canvas) {
            return new Promise(function (resolve) {
                var binaryString = window.atob(canvas.toDataURL().split(',')[1]);
                var length = binaryString.length;
                var binaryArray = new Uint8Array(length);

                for (var i = 0; i < length; i++)
                    binaryArray[i] = binaryString.charCodeAt(i);

                resolve(new Blob([binaryArray], {
                    type: 'image/png'
                }));
            });
        }

        function canvasToBlob(canvas) {
            if (canvas.toBlob)
                return new Promise(function (resolve) {
                    canvas.toBlob(resolve);
                });

            return toBlob(canvas);
        }

        function resolveUrl(url, baseUrl) {
            var doc = document.implementation.createHTMLDocument();
            var base = doc.createElement('base');
            doc.head.appendChild(base);
            var a = doc.createElement('a');
            doc.body.appendChild(a);
            base.href = baseUrl;
            a.href = url;
            return a.href;
        }

        function uid() {
            var index = 0;

            return function () {
                return 'u' + fourRandomChars() + index++;

                function fourRandomChars() {
                    /* see http://stackoverflow.com/a/6248722/2519373 */
                    return ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
                }
            };
        }

        function makeImage(uri) {
            return new Promise(function (resolve, reject) {
                var image = new Image();
                image.onload = function () {
                    resolve(image);
                };
                image.onerror = reject;
                image.src = uri;
            });
        }

        function getAndEncode(url) {
            var TIMEOUT = 30000;
            if(domtoimage.impl.options.cacheBust) {
                // Cache bypass so we dont have CORS issues with cached images
                // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
                url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();
            }

            return new Promise(function (resolve) {
                var request = new XMLHttpRequest();

                request.onreadystatechange = done;
                request.ontimeout = timeout;
                request.responseType = 'blob';
                request.timeout = TIMEOUT;
                request.open('GET', url, true);
                request.send();

                var placeholder;
                if(domtoimage.impl.options.imagePlaceholder) {
                    var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
                    if(split && split[1]) {
                        placeholder = split[1];
                    }
                }

                function done() {
                    if (request.readyState !== 4) return;

                    if (request.status !== 200) {
                        if(placeholder) {
                            resolve(placeholder);
                        } else {
                            fail('cannot fetch resource: ' + url + ', status: ' + request.status);
                        }

                        return;
                    }

                    var encoder = new FileReader();
                    encoder.onloadend = function () {
                        var content = encoder.result.split(/,/)[1];
                        resolve(content);
                    };
                    encoder.readAsDataURL(request.response);
                }

                function timeout() {
                    if(placeholder) {
                        resolve(placeholder);
                    } else {
                        fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url);
                    }
                }

                function fail(message) {
                    console.error(message);
                    resolve('');
                }
            });
        }

        function dataAsUrl(content, type) {
            return 'data:' + type + ';base64,' + content;
        }

        function escape(string) {
            return string.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
        }

        function delay(ms) {
            return function (arg) {
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        resolve(arg);
                    }, ms);
                });
            };
        }

        function asArray(arrayLike) {
            var array = [];
            var length = arrayLike.length;
            for (var i = 0; i < length; i++) array.push(arrayLike[i]);
            return array;
        }

        function escapeXhtml(string) {
            return string.replace(/#/g, '%23').replace(/\n/g, '%0A');
        }

        function width(node) {
            var leftBorder = px(node, 'border-left-width');
            var rightBorder = px(node, 'border-right-width');
            return node.scrollWidth + leftBorder + rightBorder;
        }

        function height(node) {
            var topBorder = px(node, 'border-top-width');
            var bottomBorder = px(node, 'border-bottom-width');
            return node.scrollHeight + topBorder + bottomBorder;
        }

        function px(node, styleProperty) {
            var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
            return parseFloat(value.replace('px', ''));
        }
    }

    function newInliner() {
        var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;

        return {
            inlineAll: inlineAll,
            shouldProcess: shouldProcess,
            impl: {
                readUrls: readUrls,
                inline: inline
            }
        };

        function shouldProcess(string) {
            return string.search(URL_REGEX) !== -1;
        }

        function readUrls(string) {
            var result = [];
            var match;
            while ((match = URL_REGEX.exec(string)) !== null) {
                result.push(match[1]);
            }
            return result.filter(function (url) {
                return !util.isDataUrl(url);
            });
        }

        function inline(string, url, baseUrl, get) {
            return Promise.resolve(url)
                .then(function (url) {
                    return baseUrl ? util.resolveUrl(url, baseUrl) : url;
                })
                .then(get || util.getAndEncode)
                .then(function (data) {
                    return util.dataAsUrl(data, util.mimeType(url));
                })
                .then(function (dataUrl) {
                    return string.replace(urlAsRegex(url), '$1' + dataUrl + '$3');
                });

            function urlAsRegex(url) {
                return new RegExp('(url\\([\'"]?)(' + util.escape(url) + ')([\'"]?\\))', 'g');
            }
        }

        function inlineAll(string, baseUrl, get) {
            if (nothingToInline()) return Promise.resolve(string);

            return Promise.resolve(string)
                .then(readUrls)
                .then(function (urls) {
                    var done = Promise.resolve(string);
                    urls.forEach(function (url) {
                        done = done.then(function (string) {
                            return inline(string, url, baseUrl, get);
                        });
                    });
                    return done;
                });

            function nothingToInline() {
                return !shouldProcess(string);
            }
        }
    }

    function newFontFaces() {
        return {
            resolveAll: resolveAll,
            impl: {
                readAll: readAll
            }
        };

        function resolveAll() {
            return readAll()
                .then(function (webFonts) {
                    return Promise.all(
                        webFonts.map(function (webFont) {
                            return webFont.resolve();
                        })
                    );
                })
                .then(function (cssStrings) {
                    return cssStrings.join('\n');
                });
        }

        function readAll() {
            return Promise.resolve(util.asArray(document.styleSheets))
                .then(getCssRules)
                .then(selectWebFontRules)
                .then(function (rules) {
                    return rules.map(newWebFont);
                });

            function selectWebFontRules(cssRules) {
                return cssRules
                    .filter(function (rule) {
                        return rule.type === CSSRule.FONT_FACE_RULE;
                    })
                    .filter(function (rule) {
                        return inliner.shouldProcess(rule.style.getPropertyValue('src'));
                    });
            }

            function getCssRules(styleSheets) {
                var cssRules = [];
                styleSheets.forEach(function (sheet) {
                    try {
                        util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
                    } catch (e) {
                    }
                });
                return cssRules;
            }

            function newWebFont(webFontRule) {
                return {
                    resolve: function resolve() {
                        var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                        return inliner.inlineAll(webFontRule.cssText, baseUrl);
                    },
                    src: function () {
                        return webFontRule.style.getPropertyValue('src');
                    }
                };
            }
        }
    }

    function newImages() {
        return {
            inlineAll: inlineAll,
            impl: {
                newImage: newImage
            }
        };

        function newImage(element) {
            return {
                inline: inline
            };

            function inline(get) {
                if (util.isDataUrl(element.src)) return Promise.resolve();

                return Promise.resolve(element.src)
                    .then(get || util.getAndEncode)
                    .then(function (data) {
                        return util.dataAsUrl(data, util.mimeType(element.src));
                    })
                    .then(function (dataUrl) {
                        return new Promise(function (resolve, reject) {
                            element.onload = resolve;
                            element.onerror = reject;
                            element.src = dataUrl;
                        });
                    });
            }
        }

        function inlineAll(node) {
            if (!(node instanceof Element)) return Promise.resolve(node);

            return inlineBackground(node)
                .then(function () {
                    if (node instanceof HTMLImageElement)
                        return newImage(node).inline();
                    else
                        return Promise.all(
                            util.asArray(node.childNodes).map(function (child) {
                                return inlineAll(child);
                            })
                        );
                });

            function inlineBackground(node) {
                var background = node.style.getPropertyValue('background');

                if (!background) return Promise.resolve(node);

                return inliner.inlineAll(background)
                    .then(function (inlined) {
                        node.style.setProperty(
                            'background',
                            inlined,
                            node.style.getPropertyPriority('background')
                        );
                    })
                    .then(function () {
                        return node;
                    });
            }
        }
    }
})();
});

function deepClone(obj) {
  // å¯¹å¸¸è§çâéâå¼ï¼ç´æ¥è¿ååæ¥å¼
  if ([null, undefined, NaN, false].includes(obj)) return obj;

  if (_typeof_1(obj) !== 'object' && typeof obj !== 'function') {
    // åå§ç±»åç´æ¥è¿å
    return obj;
  }

  var o = rule.array(obj) ? [] : {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = _typeof_1(obj[i]) === 'object' ? deepClone(obj[i]) : obj[i];
    }
  }

  return o;
} // JSå¯¹è±¡æ·±åº¦åå¹¶


function deepMerge() {
  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  target = deepClone(target);
  if (_typeof_1(target) !== 'object' || _typeof_1(source) !== 'object') return false;

  for (var prop in source) {
    if (!source.hasOwnProperty(prop)) continue;

    if (prop in target) {
      if (_typeof_1(target[prop]) !== 'object') {
        target[prop] = source[prop];
      } else if (_typeof_1(source[prop]) !== 'object') {
        target[prop] = source[prop];
      } else if (target[prop].concat && source[prop].concat) {
        target[prop] = target[prop].concat(source[prop]);
      } else {
        target[prop] = deepMerge(target[prop], source[prop]);
      }
    } else {
      target[prop] = source[prop];
    }
  }

  return target;
}
/**
 * å¯¹è±¡è½¬urlåæ°
 * @param {*} data,å¯¹è±¡
 * @param {*} isPrefix,æ¯å¦èªå¨å ä¸"?"
 */


function queryParams() {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var isPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var arrayFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'brackets';
  var prefix = isPrefix ? '?' : '';
  var _result = [];
  if (['indices', 'brackets', 'repeat', 'comma'].indexOf(arrayFormat) == -1) arrayFormat = 'brackets';

  var _loop = function _loop(key) {
    var value = data[key]; // å»æä¸ºç©ºçåæ°

    if (['', undefined, null].indexOf(value) >= 0) {
      return "continue";
    } // å¦æå¼ä¸ºæ°ç»ï¼å¦è¡å¤ç


    if (value.constructor === Array) {
      // e.g. {ids: [1, 2, 3]}
      switch (arrayFormat) {
        case 'indices':
          // ç»æ: ids[0]=1&ids[1]=2&ids[2]=3
          for (var i = 0; i < value.length; i++) {
            _result.push("".concat(key, "[").concat(i, "]=").concat(value[i]));
          }

          break;

        case 'brackets':
          // ç»æ: ids[]=1&ids[]=2&ids[]=3
          value.forEach(function (_value) {
            _result.push("".concat(key, "[]=").concat(_value));
          });
          break;

        case 'repeat':
          // ç»æ: ids=1&ids=2&ids=3
          value.forEach(function (_value) {
            _result.push("".concat(key, "=").concat(_value));
          });
          break;

        case 'comma':
          // ç»æ: ids=1,2,3
          var commaStr = '';
          value.forEach(function (_value) {
            commaStr += (commaStr ? ',' : '') + _value;
          });

          _result.push("".concat(key, "=").concat(commaStr));

          break;

        default:
          value.forEach(function (_value) {
            _result.push("".concat(key, "[]=").concat(_value));
          });
      }
    } else {
      _result.push("".concat(key, "=").concat(value));
    }
  };

  for (var key in data) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return _result.length ? prefix + _result.join('&') : '';
} // å¶ä»æ´å¤æ¯æ ¼å¼åæå¦ä¸:
// yyyy:mm:dd|yyyy:mm|yyyyå¹´mmæddæ¥|yyyyå¹´mmæddæ¥ hhæ¶MMåç­,å¯èªå®ä¹ç»å


function timeFormat() {
  var dateTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var fmt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-mm-dd';
  // å¦æä¸ºnull,åæ ¼å¼åå½åæ¶é´
  if (!dateTime) dateTime = Number(new Date()); // å¦ædateTimeé¿åº¦ä¸º10æè13ï¼åä¸ºç§åæ¯«ç§çæ¶é´æ³ï¼å¦æè¶è¿13ä½ï¼åä¸ºå¶ä»çæ¶é´æ ¼å¼

  if (dateTime.toString().length == 10) dateTime *= 1000;
  if (dateTime.toString().length == 13) dateTime = Number(dateTime);
  var date = new Date(dateTime);
  var ret;
  var opt = {
    'y+': date.getFullYear().toString(),
    // å¹´
    'm+': (date.getMonth() + 1).toString(),
    // æ
    'd+': date.getDate().toString(),
    // æ¥
    'h+': date.getHours().toString(),
    // æ¶
    'M+': date.getMinutes().toString(),
    // å
    's+': date.getSeconds().toString() // ç§
    // æå¶ä»æ ¼å¼åå­ç¬¦éæ±å¯ä»¥ç»§ç»­æ·»å ï¼å¿é¡»è½¬åæå­ç¬¦ä¸²

  };

  for (var k in opt) {
    ret = new RegExp("(".concat(k, ")")).exec(fmt);

    if (ret) {
      fmt = fmt.replace(ret[1], ret[1].length == 1 ? opt[k] : opt[k].padStart(ret[1].length, '0'));
    }
  }

  return fmt;
}
/**
 * æ¶é´æ³è½¬ä¸ºå¤ä¹ä¹å
 * @param String timestamp æ¶é´æ³
 * @param String | Boolean format å¦æä¸ºæ¶é´æ ¼å¼å­ç¬¦ä¸²ï¼è¶åºä¸å®æ¶é´èå´ï¼è¿ååºå®çæ¶é´æ ¼å¼ï¼
 * å¦æä¸ºå¸å°å¼falseï¼æ è®ºä»ä¹æ¶é´ï¼é½è¿åå¤ä¹ä»¥åçæ ¼å¼
 */


function timeFrom() {
  var timestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-mm-dd';
  if (timestamp == null) timestamp = Number(new Date());
  timestamp = parseInt(timestamp); // å¤æ­ç¨æ·è¾å¥çæ¶é´æ³æ¯ç§è¿æ¯æ¯«ç§,ä¸è¬åç«¯jsè·åçæ¶é´æ³æ¯æ¯«ç§(13ä½),åç«¯ä¼ è¿æ¥çä¸ºç§(10ä½)

  if (timestamp.toString().length == 10) timestamp *= 1000;
  var timer = new Date().getTime() - timestamp;
  timer = parseInt(timer / 1000); // å¦æå°äº5åé,åè¿å"åå",å¶ä»ä»¥æ­¤ç±»æ¨

  var tips = '';

  switch (true) {
    case timer < 300:
      tips = 'åå';
      break;

    case timer >= 300 && timer < 3600:
      tips = "".concat(parseInt(timer / 60), "\u5206\u949F\u524D");
      break;

    case timer >= 3600 && timer < 86400:
      tips = "".concat(parseInt(timer / 3600), "\u5C0F\u65F6\u524D");
      break;

    case timer >= 86400 && timer < 2592000:
      tips = "".concat(parseInt(timer / 86400), "\u5929\u524D");
      break;

    default:
      // å¦æformatä¸ºfalseï¼åæ è®ºä»ä¹æ¶é´æ³ï¼é½æ¾ç¤ºxxä¹å
      if (format === false) {
        if (timer >= 2592000 && timer < 365 * 86400) {
          tips = "".concat(parseInt(timer / (86400 * 30)), "\u4E2A\u6708\u524D");
        } else {
          tips = "".concat(parseInt(timer / (86400 * 365)), "\u5E74\u524D");
        }
      } else {
        tips = timeFormat(timestamp, format);
      }

  }

  return tips;
}
/**
 * æ¶é´å­ç¬¦ä¸²è½¬æ¶é´æ³
 * @param {*} date åæ³æ¶é´æ ¼å¼
 * @returns {Number} æ¶é´æ³
 */


var dateToStamp = function dateToStamp(date) {
  var isDateValid = !Number.isNaN(new Date(date).valueOf());

  if (isDateValid) {
    return new Date(date).getTime();
  } else {
    return 0;
  }
};
/**
 * æ°å­æ ¼å¼å
 * @param {Number} number è¦æ ¼å¼åçæ°å­
 * @param {Number} decimals ä¿çå ä½å°æ°
 * @param {String} dec_point å°æ°ç¹ç¬¦å·
 * @param {String} thousands_sep ååä½ç¬¦å·
 * @param {String} style è®¡ç®æ¹å¼; é»è®¤åèäºå¥ï¼round:åèäºå¥ï¼floorï¼ç´æ¥èå»ï¼ceilï¼ç´æ¥è¿ä½
 * @returns {Number}
 */


function numberFormat(number) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var dec_point = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  var thousands_sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ',';
  var style = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'round';
  number = (number + '').replace(/[^0-9+-Ee.]/g, '');

  var n = !isFinite(+number) ? 0 : +number,
      prec = !isFinite(+decimals) ? 0 : Math.abs(decimals),
      sep = typeof thousands_sep === 'undefined' ? ',' : thousands_sep,
      dec = typeof dec_point === 'undefined' ? '.' : dec_point,
      s = '',
      toFixedFix = function toFixedFix(n, prec) {
    var k = Math.pow(10, prec);
    var val = null;

    switch (style) {
      case 'round':
        val = Math.round(n * k) / k;
        break;

      case 'floor':
        val = Math.floor(n * k) / k;
        break;

      case 'ceil':
        val = Math.ceil(n * k) / k;
        break;
    }

    return '' + val;
  };

  s = (prec ? toFixedFix(n, prec) : style = '' + Math.floor(n) ).split('.');
  var re = /(-?\d+)(\d{3})/;

  while (re.test(s[0])) {
    s[0] = s[0].replace(re, '$1' + sep + '$2');
  }

  if ((s[1] || '').length < prec) {
    s[1] = s[1] || '';
    s[1] += new Array(prec - s[1].length + 1).join('0');
  }

  return s.join(dec);
} //éè¿urlè·åæä»¶ä¿¡æ¯


function getFileInfoByUrl(url) {
  return new Promise(function (resolve) {
    var xhr = new XMLHttpRequest();
    xhr.open('HEAD', url, true);

    xhr.onload = function () {
      if (xhr.status >= 200 && xhr.status < 300) {
        var fileSize = xhr.getResponseHeader('Content-Length') || 'æªç¥å¤§å°';
        var fileType = xhr.getResponseHeader('Content-Type') || 'æªç¥ç±»å';
        var fileName = url.split('?')[0].split('/').pop() || 'æªç¥åç§°';
        resolve({
          code: 0,
          data: {
            file_size: fileSize,
            file_type: fileType,
            file_name: fileName
          },
          msg: 'æä»¶ä¿¡æ¯è·åæå'
        });
      } else {
        resolve({
          code: 1,
          data: {},
          msg: 'æ æ³è·åæä»¶ä¿¡æ¯'
        });
      }
    };

    xhr.onerror = function () {
      resolve({
        code: 2,
        data: {},
        msg: 'è¯·æ±å¤±è´¥'
      });
    };

    xhr.send();
  });
}

var getNow = function getNow() {
  var date = new Date();

  var gs = function gs(n) {
    return ('00' + n).substr(-2);
  };

  return "".concat(date.getFullYear()).concat(gs(date.getMonth() + 1)).concat(gs(date.getDate())).concat(gs(date.getHours())).concat(gs(date.getMinutes())).concat(gs(date.getSeconds()));
};
/**
 * æ¹éä¸è½½æä»¶å¹¶æåæzip
 * @param {Array} data - è¦ä¸è½½çæ°æ®æ°ç»
 * @param {Function} fn - åè°å½æ°ï¼ç¨äºéç¥ä¸è½½ç¶æåè¿åº¦
 * @param {String} urlKey - æ°æ®å¯¹è±¡ä¸­URLçé®å
 * @param {String} nameKey - æ°æ®å¯¹è±¡ä¸­æä»¶åçé®åï¼é»è®¤ä¸º'file'
 * @param {Object} options - éç½®éé¡¹
 * @param {Number} options.concurrency - å¹¶åä¸è½½æ°éï¼é»è®¤ä¸º2
 * @param {Number} options.retries - å¤±è´¥éè¯æ¬¡æ°ï¼é»è®¤ä¸º3
 * @param {Number} options.retryDelay - éè¯å»¶è¿æ¶é´(ms)ï¼é»è®¤ä¸º2000
 * @param {Number} options.timeout - è¯·æ±è¶æ¶æ¶é´(ms)ï¼é»è®¤ä¸º60000
 */


var batchDownload = /*#__PURE__*/function () {
  var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(data, fn) {
    var urlKey,
        nameKey,
        options,
        config,
        zip,
        folder,
        totalFiles,
        completedFiles,
        failList,
        taskIndex,
        progressLock,
        updateProgress,
        downloadFile,
        getFileNameFromUrl,
        getNextTaskIndex,
        worker,
        workers,
        successCount,
        zipBlob,
        _args5 = arguments;
    return regenerator.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            urlKey = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : '';
            nameKey = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : 'file';
            options = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
            // é»è®¤éç½®
            config = {
              concurrency: options.concurrency || 2,
              // éä½å¹¶åæ°
              retries: options.retries || 3,
              // å¢å éè¯æ¬¡æ°
              retryDelay: options.retryDelay || 2000,
              // å¢å éè¯å»¶è¿
              timeout: options.timeout || 60000 // å¢å è¶æ¶æ¶é´

            }; // æ°æ®éªè¯

            if (!(!data || !Array.isArray(data) || !data.length)) {
              _context5.next = 8;
              break;
            }
            fn && fn({
              code: -2,
              msg: 'æ°æ®ä¸ºç©ºï¼æ éä¸è½½'
            });
            return _context5.abrupt("return");

          case 8:
            fn && fn({
              code: 2,
              msg: 'ä¸è½½ä¸­'
            });
            zip = new jszip_min();
            folder = zip.folder(getNow());
            totalFiles = data.length;
            completedFiles = 0;
            failList = []; // ä½¿ç¨åå­ç´¢å¼æ¿ä»£éåæä½ï¼é¿åç«äºæ¡ä»¶

            taskIndex = 0;
            progressLock = {
              locked: false
            }; // çº¿ç¨å®å¨çè¿åº¦æ´æ°å½æ°

            updateProgress = /*#__PURE__*/function () {
              var _ref3 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
                var currentCompleted, currentFailed;
                return regenerator.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!progressLock.locked) {
                          _context2.next = 2;
                          break;
                        }

                        return _context2.abrupt("return");

                      case 2:
                        progressLock.locked = true;

                        try {
                          currentCompleted = completedFiles;
                          currentFailed = failList.length;
                          fn && fn({
                            code: 3,
                            msg: 'ä¸è½½è¿åº¦æ´æ°',
                            progress: {
                              total: totalFiles,
                              completed: currentCompleted,
                              success: currentCompleted - currentFailed,
                              failed: currentFailed,
                              percent: Math.round(currentCompleted / totalFiles * 100)
                            }
                          });
                        } finally {
                          progressLock.locked = false;
                        }

                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function updateProgress() {
                return _ref3.apply(this, arguments);
              };
            }(); // ä¼åçä¸è½½å½æ°


            downloadFile = /*#__PURE__*/function () {
              var _ref4 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(fileUrl) {
                var retryCount,
                    cleanUrl,
                    controller,
                    timeoutId,
                    response,
                    blob,
                    delay,
                    _args3 = arguments;
                return regenerator.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        retryCount = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : config.retries;
                        _context3.prev = 1;
                        // æ¸çURL
                        cleanUrl = fileUrl.trim().replace(/[`\s]/g, ''); // åå»ºAbortControllerç¨äºè¶æ¶æ§å¶

                        controller = new AbortController();
                        timeoutId = setTimeout(function () {
                          controller.abort();
                        }, config.timeout);
                        _context3.next = 7;
                        return fetch(cleanUrl);

                      case 7:
                        response = _context3.sent;

                        if (response.ok) {
                          _context3.next = 10;
                          break;
                        }

                        throw new Error("Failed to fetch ".concat(cleanUrl));

                      case 10:
                        clearTimeout(timeoutId); // è·åblobæ°æ®

                        _context3.next = 13;
                        return response.blob();

                      case 13:
                        blob = _context3.sent;

                        if (!(blob.size === 0)) {
                          _context3.next = 16;
                          break;
                        }

                        throw new Error('ä¸è½½çæä»¶ä¸ºç©º');

                      case 16:
                        return _context3.abrupt("return", blob);

                      case 19:
                        _context3.prev = 19;
                        _context3.t0 = _context3["catch"](1);
                        console.error("\u4E0B\u8F7D\u5931\u8D25 (\u5C1D\u8BD5 ".concat(config.retries - retryCount + 1, "/").concat(config.retries, "): ").concat(fileUrl), _context3.t0.message);

                        if (!(retryCount > 0)) {
                          _context3.next = 27;
                          break;
                        }

                        // ææ°éé¿éè¯
                        delay = config.retryDelay * (config.retries - retryCount + 1);
                        _context3.next = 26;
                        return new Promise(function (resolve) {
                          return setTimeout(resolve, delay);
                        });

                      case 26:
                        return _context3.abrupt("return", downloadFile(fileUrl, retryCount - 1));

                      case 27:
                        throw _context3.t0;

                      case 28:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, null, [[1, 19]]);
              }));

              return function downloadFile(_x5) {
                return _ref4.apply(this, arguments);
              };
            }(); // æ¹è¿çæä»¶åæåå½æ°


            getFileNameFromUrl = function getFileNameFromUrl(url) {
              if (!url) return 'file';

              try {
                var cleanUrl = url.replace(/[\s`]/g, '');
                var urlObj = new URL(cleanUrl);
                var pathname = urlObj.pathname; // ç§»é¤æ¥è¯¢åæ°

                pathname = pathname.split('?')[0];
                var segments = pathname.split('/');
                var filename = segments[segments.length - 1]; // è§£ç URLç¼ç çæä»¶å

                filename = decodeURIComponent(filename); // å¦ææä»¶åä¸ºç©ºææ æï¼çæé»è®¤åç§°

                if (!filename || filename === '/' || filename.length === 0) {
                  return "file_".concat(Date.now());
                }

                return filename;
              } catch (e) {
                console.warn('URLè§£æå¤±è´¥:', url, e);
                return "file_".concat(Date.now());
              }
            }; // åå­æä½è·åä¸ä¸ä¸ªä»»å¡ç´¢å¼


            getNextTaskIndex = function getNextTaskIndex() {
              var current = taskIndex;
              taskIndex++;
              return current;
            }; // å·¥ä½åå - ä¿®å¤ç«äºæ¡ä»¶


            worker = /*#__PURE__*/function () {
              var _ref5 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
                var currentIndex, item, fileUrl, customFileName, blob, fileName, timestamp, mimeToExt, ext;
                return regenerator.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:

                        currentIndex = getNextTaskIndex(); // æ£æ¥æ¯å¦è¶åºèå´

                        if (!(currentIndex >= data.length)) {
                          _context4.next = 4;
                          break;
                        }

                        return _context4.abrupt("break", 45);

                      case 4:
                        item = data[currentIndex];
                        fileUrl = void 0;
                        customFileName = void 0;
                        _context4.prev = 8;

                        if (!(typeof item === 'string')) {
                          _context4.next = 13;
                          break;
                        }

                        fileUrl = item.trim().replace(/[`\s]/g, '');
                        _context4.next = 19;
                        break;

                      case 13:
                        if (!(_typeof_1(item) === 'object' && item !== null)) {
                          _context4.next = 18;
                          break;
                        }

                        fileUrl = urlKey && item[urlKey] ? item[urlKey].trim().replace(/[`\s]/g, '') : '';
                        customFileName = nameKey && item[nameKey] ? item[nameKey] : '';
                        _context4.next = 19;
                        break;

                      case 18:
                        throw new Error('æ æçæ°æ®é¡¹');

                      case 19:
                        if (fileUrl) {
                          _context4.next = 21;
                          break;
                        }

                        throw new Error('URLä¸ºç©º');

                      case 21:
                        // éªè¯URLæ ¼å¼
                        new URL(fileUrl); // ä¸è½½æä»¶

                        _context4.next = 24;
                        return downloadFile(fileUrl);

                      case 24:
                        blob = _context4.sent;
                        fileName = customFileName || getFileNameFromUrl(fileUrl); // ç¡®ä¿æä»¶åå¯ä¸æ§

                        timestamp = Date.now();

                        if (!fileName || fileName === 'undefined') {
                          fileName = "file_".concat(timestamp, "_").concat(currentIndex);
                        } // æ·»å æ©å±å


                        if (!fileName.includes('.') && blob.type) {
                          mimeToExt = {
                            'image/jpeg': 'jpg',
                            'image/png': 'png',
                            'image/gif': 'gif',
                            'image/webp': 'webp',
                            'application/pdf': 'pdf',
                            'text/plain': 'txt',
                            'application/json': 'json'
                          };
                          ext = mimeToExt[blob.type] || blob.type.split('/')[1];

                          if (ext) {
                            fileName += ".".concat(ext);
                          }
                        } // æ¸çæä»¶åä¸­çéæ³å­ç¬¦


                        fileName = fileName.replace(/[<>:"/\\|?*]/g, '_');
                        folder.file(fileName, blob, {
                          binary: true
                        });
                        _context4.next = 38;
                        break;

                      case 34:
                        _context4.prev = 34;
                        _context4.t0 = _context4["catch"](8);
                        console.error("\u4EFB\u52A1 ".concat(currentIndex + 1, " \u4E0B\u8F7D\u5931\u8D25: ").concat(fileUrl || 'unknown'), _context4.t0);
                        failList.push({
                          url: fileUrl || 'unknown',
                          reason: _context4.t0.message || 'ä¸è½½å¤±è´¥',
                          error: _context4.t0.name,
                          index: currentIndex
                        });

                      case 38:
                        _context4.prev = 38;
                        // åå­æä½æ´æ°å®æè®¡æ°
                        completedFiles++;

                        setTimeout(function () {
                          return updateProgress();
                        }, 0);
                        return _context4.finish(38);

                      case 43:
                        _context4.next = 0;
                        break;

                      case 45:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4, null, [[8, 34, 38, 43]]);
              }));

              return function worker() {
                return _ref5.apply(this, arguments);
              };
            }(); // åå»ºå·¥ä½åå


            workers = Array(config.concurrency).fill(null).map(function () {
              return worker();
            }); // ç­å¾ææä»»å¡å®æ

            _context5.next = 24;
            return Promise.all(workers);

          case 24:
            _context5.next = 26;
            return updateProgress();

          case 26:
            _context5.prev = 26;
            successCount = completedFiles - failList.length;

            if (!(successCount > 0)) {
              _context5.next = 37;
              break;
            }
            _context5.next = 32;
            return zip.generateAsync({
              type: 'blob',
              compression: 'DEFLATE',
              compressionOptions: {
                level: 6
              }
            });

          case 32:
            zipBlob = _context5.sent;
            FileSaver_min.saveAs(zipBlob, "".concat(getNow(), ".zip"));

            if (failList.length > 0) {
              fn && fn({
                code: 1,
                msg: "\u90E8\u5206\u4E0B\u8F7D\u5931\u8D25\uFF0C\u6210\u529F ".concat(successCount, "/").concat(totalFiles),
                failList: failList,
                successCount: successCount
              });
            } else {
              fn && fn({
                code: 0,
                msg: 'å¨é¨ä¸è½½å®æ',
                successCount: successCount
              });
            }

            _context5.next = 38;
            break;

          case 37:
            fn && fn({
              code: -1,
              msg: 'æææä»¶ä¸è½½å¤±è´¥',
              failList: failList
            });

          case 38:
            _context5.next = 44;
            break;

          case 40:
            _context5.prev = 40;
            _context5.t0 = _context5["catch"](26);
            console.error('çæZIPæä»¶æ¶åºé:', _context5.t0);
            fn && fn({
              code: -1,
              msg: 'çæZIPå¤±è´¥: ' + _context5.t0.message,
              failList: failList
            });

          case 44:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[26, 40]]);
  }));

  return function batchDownload(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * @description: æªé¿å¾å¹¶ä¸è½½
 * @param {HTMLDivElement} container
 */


var captureContainerScreenshot = /*#__PURE__*/function () {
  var _ref6 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(container, fn) {
    var isDownload,
        fileName,
        originalStyle,
        _args6 = arguments;
    return regenerator.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            isDownload = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : true;
            fileName = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : 'screenshot';
            // ææ¶è°æ´æ ·å¼ï¼ç¡®ä¿å®æ´æ¸²æ
            originalStyle = container.style.cssText;
            container.style.overflow = 'visible'; // ç¡®ä¿åå®¹å¯è§

            container.style.height = 'auto'; // ç¡®ä¿åå®¹å®æ´æ¾ç¤º

            NUI.$toast({
              message: 'æ­£å¨çæå¾ç...'
            });
            _context6.next = 8;
            return domToImage.toPng(container).then(function (dataUrl) {
              fn && fn({
                code: 0,
                url: dataUrl,
                msg: 'çæå¾çæå'
              });
              NUI.$toast({
                message: 'çæå¾çæå',
                type: 'success'
              }); // æ¢å¤åæ ·å¼

              // æ¢å¤åæ ·å¼
              container.style.cssText = originalStyle;
              if (!isDownload) return; // åå»ºä¸ä¸ª <a> åç´ ä¸è½½å¾ç

              // åå»ºä¸ä¸ª <a> åç´ ä¸è½½å¾ç
              var link = document.createElement('a');
              link.href = dataUrl;
              link.download = "".concat(fileName, ".png");
              link.click();
            }).catch(function (error) {
              NUI.$toast({
                message: 'çæå¾çå¤±è´¥',
                type: 'error'
              });
              fn && fn({
                code: 1,
                msg: 'çæå¾çå¤±è´¥'
              });
              console.error('çæå¾çå¤±è´¥:', error); // æ¢å¤åæ ·å¼

              // æ¢å¤åæ ·å¼
              container.style.cssText = originalStyle;
            });

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function captureContainerScreenshot(_x6, _x7) {
    return _ref6.apply(this, arguments);
  };
}();

var index = {
  deepClone: deepClone,
  deepMerge: deepMerge,
  queryParams: queryParams,
  timeFormat: timeFormat,
  timeFrom: timeFrom,
  dateToStamp: dateToStamp,
  numberFormat: numberFormat,
  getFileInfoByUrl: getFileInfoByUrl,
  batchDownload: batchDownload,
  captureContainerScreenshot: captureContainerScreenshot
};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var UI = {
  UiAside: __vue_component__$1C,
  UiAlert: __vue_component__$1y,
  UiBadge: __vue_component__$1x,
  UiButton: __vue_component__$1v,
  UiCascader: __vue_component__$1k,
  UiCascaderPanel: __vue_component__$1l,
  UiCheckbox: __vue_component__$1p,
  UiCheckboxGroup: __vue_component__$1h,
  UiCloseButton: __vue_component__$1z,
  UiCollapsible: __vue_component__$1g,
  UiConfirm: __vue_component__$1d,
  UiContaniner: __vue_component__$1c,
  UiDateTimePicker: __vue_component__$18,
  UiDraggable: __vue_component__$17,
  UiDrawer: __vue_component__$16,
  UiDropdown: __vue_component__$15,
  UiFileupload: __vue_component__$13,
  UiFooter: __vue_component__$12,
  UiForm: __vue_component__$11,
  UiFormItem: __vue_component__$10,
  UiFormItemGroup: __vue_component__$$,
  UiHeader: __vue_component__$_,
  UiIcon: __vue_component__$1B,
  UiInputNumber: __vue_component__$Z,
  UiMain: __vue_component__$Y,
  UiMedia: __vue_component__$X,
  UiMenu: __vue_component__$W,
  UiMenuItem: __vue_component__$V,
  UiModal: __vue_component__$1e,
  UiPagination: __vue_component__$U,
  UiProgressCircular: __vue_component__$1w,
  UiProgressLinear: __vue_component__$T,
  UiRadio: __vue_component__$1o,
  UiRadioGroup: __vue_component__$S,
  UiRippleInk: __vue_component__$1A,
  UiSelect: __vue_component__$Q,
  UiSlider: __vue_component__$P,
  UiStep: __vue_component__$N,
  UiSteps: __vue_component__$M,
  UiSubmenu: __vue_component__$L,
  UiSwiper: __vue_component__$K,
  UiSwiperItem: __vue_component__$J,
  UiSwitch: __vue_component__$I,
  UiTable: __vue_component__$D,
  UiTabs: __vue_component__$C,
  UiTag: __vue_component__$1q,
  UiTextbox: __vue_component__$1r,
  UiTextboxSuggestion: __vue_component__$1s,
  UiTimeline: __vue_component__$B,
  UiTimelineItem: __vue_component__$A,
  UiToolbar: __vue_component__$z,
  UiTransfer: __vue_component__$x,
  UiTree: __vue_component__$v,
  UiUpload: __vue_component__$u,
  UiVirtualList: __vue_component__$s,
  UiCard: __vue_component__$r,
  UiDataMapper: __vue_component__$p,
  UiCountTo: __vue_component__$o,
  UiCircle: __vue_component__$n,
  UiBreadCrumb: __vue_component__$m,
  UiBreadCrumbItem: __vue_component__$l,
  UiWaterMark: __vue_component__$k,
  UiBackTop: __vue_component__$j,
  UiCountDown: __vue_component__$i,
  UiTextEllipsis: __vue_component__$h,
  UiChunkUpload: __vue_component__$g,
  UiSidemenu: __vue_component__$f,
  UiBatchMaterial: __vue_component__$e,
  UiTimePeriod: __vue_component__$d,
  UiRate: __vue_component__$c,
  UiCarousel: __vue_component__$b,
  UiCarouselItem: __vue_component__$a,
  UiTagInput: __vue_component__$8,
  UiAssetLib: __vue_component__$7,
  UiDynamicTabs: __vue_component__$6,
  UiCreativeMaterial: __vue_component__$5,
  UiTextboxGroup: __vue_component__$4,
  UiTtCascade: __vue_component__$1i,
  UiMediaCarousel: __vue_component__$3,
  UiMediaGroup: __vue_component__$2
};

UI.install = function (Vue) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Configure the component props
  Object.keys(config).forEach(function (key) {
    if (startsWith(key, 'Ui')) {
      if (UI[key] === undefined) {
        return;
      }

      var Component = UI[key];
      var props = config[key];
      configure(Component, props);
    }
  }); // Install the components

  Object.keys(UI).forEach(function (key) {
    if (startsWith(key, 'Ui')) {
      var Component = UI[key];
      Vue.component(Component.name, Component);
    }
  });
  Vue.directive('autofocus', DAutofocus);
  Vue.directive('drag', DDrag);
  Vue.directive('form', DForm);
  Vue.directive('loading', DLoading);
  Vue.use(plugin$3);
  Vue.use(plugin);
  Vue.use(Message);
  Vue.use(Toast);
  Vue.use(Clipboard);
  Vue.use(ScrollIntoView);
  Vue.use(Intro);
  Vue.component('ui-tooltip', _Tooltip); // æ¶é´æ ¼å¼åï¼åæ¶ä¸¤ä¸ªåç§°ï¼dateåtimeFormat

  Vue.filter('timeFormat', function (timestamp, format) {
    return index.timeFormat(timestamp, format);
  });
  Vue.filter('date', function (timestamp, format) {
    return index.timeFormat(timestamp, format);
  }); // å°å¤ä¹ä»¥åçæ¹æ³ï¼æ³¨å¥å°å¨å±è¿æ»¤å¨

  Vue.filter('timeFrom', function (timestamp, format) {
    return index.timeFrom(timestamp, format);
  }); //æè½½ååï¼è¿æ ·templateæå¯ä»¥ç´æ¥ä½¿ç¨

  Vue.prototype.$tools = $tools;
}; // Automatically install Keen UI if Vue is available globally


if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(UI, window.KeenUiConfig);
}
var $tools = _objectSpread$1({
  rule: rule
}, index);

var _excluded = ["el"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
Vue.use(UI);
Vue.use(VueAwesomeSwiper);
window.Vue = Vue;
/** vue å®ä¾æ¹æ³ */

var APP = function APP() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var opts = 'function' === typeof options ? options() : options;
  return new Vue(_objectSpread(_objectSpread({}, opts), {}, {
    data: 'function' === typeof opts.data ? opts.data : function () {
      return _objectSpread({}, opts.data);
    }
  }));
};
/**
 * NUIæ¹æ³
 * @param { VueOptions | Function:() => VueOptions } options ä¼ éä¸ä¸ªvueéç½®åæ°ï¼æèæ¯ä¸ä¸ªè¿åvueéç½®åæ°çæ¹æ³
 * @return { Vue } è¿åä¸ä¸ªvmå®ä¾
 * @deprecated vmä¹å°æè½½å° NUI.__app__ å¦æå¤æ¬¡æè½½ï¼åä¼æ¥éï¼å¦éè¦å®ä¾å¤ä¸ªï¼è¯·ä½¿ç¨NUI.Vue
 */


var NUI$1 = function NUI() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (NUI.__app__) throw new Error('The NUI is a Singleton, U can use NUI.Vue');

  var _options$el = options.el,
      el = _options$el === void 0 ? '#app' : _options$el,
      opt = objectWithoutProperties(options, _excluded);

  NUI.__app__ = APP(opt);

  NUI.__app__.$mount(el); // è¿ééè¦æå¼æ¥ï¼å¦åmountedåè·åå°ç NUI.__app__ ä¸ºç©º


  NUI.__app__.$el.setAttribute('ready', ''); // å·²å è½½å®æ


  EventHub.$emit('nui:mounted', NUI.__app__); // å¹¿æ­å®ä¾å®æäºä»¶
  // æ¥æ¶ç»ä»¶åå³äºNUIçå¹¿æ­äºä»¶ï½

  EventHub.$on('nui:fullMask', function (data) {
    if (data) NUI.postMessage({
      type: 'openMask'
    });else NUI.postMessage({
      type: 'closeMask'
    });
  }); // éæ¯å¹¿æ­äºä»¶

  NUI.__app__.$once('hook:beforeDestroy', function () {
    EventHub.$off('nui:fullMask');
  }); // å·æ°é¡µé¢æ¶ï¼ä¹è¦éæ¯äºä»¶


  window.addEventListener('beforeunload', function () {
    EventHub.$off('nui:fullMask');
  });
  return NUI.__app__;
}; // å®ä¾åè®¸å¤ä¸ªVue


NUI$1.APP = APP; // æè½½Vue

NUI$1.Vue = Vue; // æè½½Vueéè®¯

NUI$1.EventHub = EventHub; //æè½½å·¥å·åº

NUI$1.$tools = $tools;
/** è®¾ç½®åºç¡éç½®ï¼å°Vue.configæè½½å°NUI.configä¸ */

Object.assign(Vue.config, {
  silent: false,
  devtools: true,
  productionTip: false,
  errorHandler: function errorHandler(err) {
    return console.error(err);
  },
  warnHandler: function warnHandler(err) {
    return console.warn(err);
  }
});
Object.defineProperty(NUI$1, 'config', {
  get: function get() {
    return Vue.config || {};
  }
}) // å°VUEä¸æ¹æ³æè½½å°NUIä¸ï¼å¦set, delete, nextTick, use, mixin, extend, component, directive, filter, observableç­
;
['set', 'delete', 'nextTick', 'use', 'mixin', 'extend', 'component', 'directive', 'filter', 'observable'].forEach(function (k) {
  if (Vue[k]) NUI$1[k] = Vue[k].bind(Vue);
}); // å°VUEååé¾ä¸å¸¦$çæ¹æ³æè½½å°NUIä¸ï¼å¦$emit, $setç­

Object.keys(Vue.prototype).forEach(function (k) {
  if (/^\$/.test(k)) NUI$1[k] = Vue.prototype[k];
}); // å¦æNUIå®ä¾äºï¼åå°vm.dataæè½½å°NUIä¸ï¼æ¹ä¾¿æµè§å¨ç¯å¢ä½¿ç¨ï¼(ä¸å­å¨ç®­å¤´å½æ°ï¼å®¹ææä½ç¨åçé®é¢)

Object.defineProperty(NUI$1, 'data', {
  get: function get() {
    return NUI$1.__app__ ? NUI$1.__app__.$data : {};
  }
}); //////////// è¿åº¦æ¡ /////////////////////

nprogress.configure({
  easing: 'ease',
  // å¨ç»æ¹å¼
  speed: 500,
  // éå¢è¿åº¦æ¡çéåº¦
  showSpinner: false,
  // æ¯å¦æ¾ç¤ºå è½½ico
  trickleSpeed: 200,
  // èªå¨éå¢é´é
  minimum: 0.3 // åå§åæ¶çæå°ç¾åæ¯

});
NUI$1.NProgress = nprogress; ////////// è¿åº¦æ¡-end /////////////////////
//////////// iframeéä¿¡-postMessage /////////////////////

NUI$1.listenMessage = function (fn) {
  window.addEventListener('message', fn);
};

NUI$1.postMessage = function (data, target) {
  if (window.self === window.top || target === 'iframe') {
    // console.log('To child data:', data)
    // ä¼åææå­iframeåéæ¶æ¯
    Array.from(document.getElementsByTagName('iframe') || []).forEach(function (item) {
      item && item.contentWindow.postMessage(data, '*');
    });
  } else {
    // console.log('To parent data:', data)
    window.parent.postMessage(data, '*');
  }
}; //////////// iframeéä¿¡-end /////////////////////
//////////// æ³¨å¥åè½ /////////////////////


NUI$1.inject = function (tag) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var container = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'head';
  var elem = document.createElement(tag);
  var head = document.getElementsByTagName(container)[0];
  Object.assign(elem, attrs);
  head.appendChild(elem);
}; // NUIçæ¬


NUI$1.version = "1.9.75";
window.NUI = NUI$1;

export default NUI$1;
