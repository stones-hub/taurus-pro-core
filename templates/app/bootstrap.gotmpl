package app

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/http"
	_ "net/http/pprof" // å¯¼å…¥ pprof
	"os"
	"os/signal" // å¯¼å…¥ sync åŒ…
	"strings"
	"syscall"
	"time"

	"{{.ProjectName}}/app/command"
	"{{.ProjectName}}/app/crontab"
	"{{.ProjectName}}/app/hooks"
	"{{.ProjectName}}/internal/taurus"
)

// ANSI escape sequences define colors
const (
	Reset  = "\033[0m"
	Red    = "\033[31m"
	Green  = "\033[32m"
	Yellow = "\033[33m"
	Blue   = "\033[34m"
	Cyan   = "\033[36m"
)

// DefaultHost and DefaultPort are the default server address and port
var (
	env        = ".env.local"
	configPath = "./config"
	scriptMode = false
	Core       *Injector
	cleanups   []func()
)

func runCommand() {
	// åˆ¤æ–­å‘½ä»¤è¡Œæ˜¯å¦æ˜¯è„šæœ¬å‘½ä»¤ï¼Œ å¦‚æœæ˜¯åˆ™å¯åŠ¨è„šæœ¬å‘½ä»¤
	// å¦‚æœæ˜¯è„šæœ¬å‘½ä»¤ï¼Œå¿…é¡»ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•° --script æŒ‡å®šè„šæœ¬å‘½ä»¤
	// å¦‚æœå‘½ä»¤è¡Œå‚æ•° --script ä¸å­˜åœ¨ï¼Œåˆ™å¯åŠ¨httpæœåŠ¡
	if scriptMode {
		// è¿‡æ»¤æ‰åº”ç”¨çº§åˆ«çš„å‚æ•°ï¼Œåªä¼ é€’çœŸæ­£çš„å‘½ä»¤å‚æ•°ç»™å‘½ä»¤ç®¡ç†å™¨
		args := os.Args[1:] // è·³è¿‡ç¨‹åºå
		filteredArgs := make([]string, 0)

		for i := 0; i < len(args); i++ {
			arg := args[i]

			// è·³è¿‡åº”ç”¨çº§åˆ«çš„å‚æ•°
			switch arg {
			case "--script", "-script":
				continue
			case "--env", "-e":
				// è·³è¿‡ --env å‚æ•°åŠå…¶å€¼
				if i+1 < len(args) && !strings.HasPrefix(args[i+1], "-") {
					i++ // è·³è¿‡ä¸‹ä¸€ä¸ªå‚æ•°ï¼ˆenvçš„å€¼ï¼‰
				}
				continue
			case "--config", "-c":
				// è·³è¿‡ --config å‚æ•°åŠå…¶å€¼
				if i+1 < len(args) && !strings.HasPrefix(args[i+1], "-") {
					i++ // è·³è¿‡ä¸‹ä¸€ä¸ªå‚æ•°ï¼ˆconfigçš„å€¼ï¼‰
				}
				continue
			}

			filteredArgs = append(filteredArgs, arg)
		}

		// é‡æ–°è®¾ç½® os.Argsï¼ŒåªåŒ…å«è¿‡æ»¤åçš„å‚æ•°
		os.Args = append([]string{os.Args[0]}, filteredArgs...)

		err := taurus.Container.Command.Run()
		if err != nil {
			fmt.Printf("%sCommand run failed: %v %s\n", Red, err, Reset)
			os.Exit(1)
		}

		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		gracefulCleanup(ctx)
		os.Exit(0)
	}
}

func Run() {

	// å¯åŠ¨è„šæœ¬å‘½ä»¤
	runCommand()

	// å¯åŠ¨ pprof æœåŠ¡
	runPprofServer()

	// use errChan to receive http server startup error
	errChan := make(chan error, 1)
	taurus.Container.Http.Start(errChan)

	// Block until a signal is received or an error is returned.
	// If an error is returned, it is a fatal error and the program will exit.
	if err := signalWaiter(errChan); err != nil {
		log.Fatalf("%sServer startup failed: %v %s\n", Red, err, Reset)
	}

	// If signalWaiter returns nil, it means the server is running. But received a signal, so we need to shutdown the server.
	// Create a deadline to wait for, 5 seconds or cancel() are all called ctx.Done()
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Attempt graceful shutdown
	if err := taurus.Container.Http.Shutdown(ctx); err != nil {
		log.Printf("%sServer forced to shutdown: %v %s\n", Red, err, Reset)
	}

	log.Printf("%sğŸ”— -> Server shutdown successfully. %s\n", Green, Reset)
	gracefulCleanup(ctx)
}

// signalWaiter waits for a signal or an error, then return
func signalWaiter(errCh chan error) error {
	signalToNotify := []os.Signal{syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM}
	if signal.Ignored(syscall.SIGHUP) {
		signalToNotify = []os.Signal{syscall.SIGINT, syscall.SIGTERM}
	}

	signals := make(chan os.Signal, 1)
	signal.Notify(signals, signalToNotify...)

	log.Printf("%sğŸ”— -> Waiting for signals: %v %s\n", Yellow, signalToNotify, Reset)

	// Block until a signal is received or an error is returned
	select {
	case sig := <-signals:
		switch sig {
		case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM:
			log.Printf("%sğŸ”— -> Received signal: %s, starting graceful shutdown... %s\n", Yellow, sig, Reset)
			signal.Stop(signals) // åœæ­¢æ¥æ”¶æ–°çš„ä¿¡å·
			return nil
		}
	case err := <-errCh:
		log.Printf("%sğŸ”— -> Received error: %v, starting shutdown... %s\n", Red, err, Reset)
		return err
	}

	return nil
}

// gracefulCleanup is called when the server is shutting down. we can do some cleanup work here.
func gracefulCleanup(ctx context.Context) {

	log.Printf("%sğŸ”— -> Waiting for all requests to be processed... %s\n", Yellow, Reset)
	done := make(chan struct{})

	go func() {
		log.Printf("%sğŸ”— -> Running cleanup functions... %s\n", Yellow, Reset)
		for _, cleanup := range cleanups {
			cleanup()
		}
		log.Printf("%sğŸ”— -> All cleanup functions completed %s\n", Green, Reset)
		close(done)
	}()

	select {
	case <-done:
		log.Printf("%sğŸ”— -> Cleanup completed successfully. %s\n", Green, Reset)
	case <-ctx.Done():
		// If context timeout has passed and the server has not stopped
		log.Printf("%sğŸ”— -> Cleanup timeout reached, forcing stop. %s\n", Red, Reset)
	}
}

// init is automatically called before the main function
// --env .env.local --config ./config
func init() {
	// custom usage
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "\n%s\n", Cyan+"==================== Usage ===================="+Reset)
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  %s-e, --env <file>%s      Specify the environment file (default \".env.local\")\n", Green, Reset)
		fmt.Fprintf(os.Stderr, "  %s-c, --config <path>%s   Specify the configuration file or directory (default \"config\")\n", Green, Reset)
		fmt.Fprintf(os.Stderr, "  %s--script%s          	Run in script mode\n", Green, Reset)
		fmt.Fprintf(os.Stderr, "  %s-h, --help%s            Show this help message\n", Green, Reset)
		fmt.Fprintf(os.Stderr, "%s\n", Cyan+"==============================================="+Reset)
	}

	// set command line arguments and their aliases
	flag.StringVar(&env, "env", ".env.local", "Environment file")
	flag.StringVar(&env, "e", ".env.local", "Environment file (alias)")
	flag.StringVar(&configPath, "config", "config", "Path to the configuration file or directory")
	flag.StringVar(&configPath, "c", "config", "Path to the configuration file or directory (alias)")

	// æ·»åŠ è„šæœ¬æ¨¡å¼å‚æ•°
	flag.BoolVar(&scriptMode, "script", false, "Run in script mode")

	// parse command line arguments
	flag.Parse()

	// initialize all modules.
	// the env file is not needed, because the makefile has already written the environment variables into the env file, but for the sake of rigor, we still pass the env file to the initialize function
	cleanup, err := taurus.BuildComponents(configPath, env)
	if err != nil {
		log.Fatal(err)
	}
	cleanups = append(cleanups, cleanup)

	// initialize project modules
	Core, cleanup, err = buildInjector()

	if err != nil {
		log.Fatal(err)
	}
	cleanups = append(cleanups, cleanup)

	// å¯åŠ¨ hooks
	if err := hooks.StartHook(); err != nil {
		log.Printf("%sğŸ”— -> Hooks start failed: %v %s\n", Red, err, Reset)
	}

	// å¯åŠ¨å®šæ—¶ä»»åŠ¡
	if err := crontab.StartTasks(); err != nil {
		log.Printf("%sğŸ”— -> Cron tasks start failed: %v %s\n", Red, err, Reset)
	}

	// å¯åŠ¨è„šæœ¬å‘½ä»¤
	command.StartCommand()
}

func runPprofServer() {
	// å¯åŠ¨ pprof æœåŠ¡
	if taurus.Container.Config.GetBool("pprof_enabled") {
		server := &http.Server{
			Addr:    "localhost:6060",
			Handler: nil,
		}

		go func() {
			log.Printf("%sğŸ”— -> Starting pprof server on :6060 %s\n", Yellow, Reset)
			if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Printf("%sğŸ”— -> pprof server error: %v %s\n", Red, err, Reset)
			}
		}()

		// æ·»åŠ pprofæœåŠ¡å™¨çš„æ¸…ç†å‡½æ•°
		cleanups = append(cleanups, func() {
			log.Printf("%sğŸ”— -> Shutting down pprof server... %s\n", Yellow, Reset)
			ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
			defer cancel()

			if err := server.Shutdown(ctx); err != nil {
				log.Printf("%sğŸ”— -> pprof server forced to shutdown: %v %s\n", Red, err, Reset)
			} else {
				log.Printf("%sğŸ”— -> pprof server shutdown successfully %s\n", Green, Reset)
			}
		})
	}

	/*
		===============================================================================
		ğŸ“Š PProf æ€§èƒ½åˆ†æè®¿é—®æŒ‡å—
		===============================================================================

		ğŸŒ åŸºç¡€è®¿é—®åœ°å€: http://localhost:6060/debug/pprof/

		ğŸ“ˆ å¸¸ç”¨æ€§èƒ½åˆ†æç«¯ç‚¹:

		1. ğŸ§  å†…å­˜åˆ†æ
		   - å †å†…å­˜ä½¿ç”¨: http://localhost:6060/debug/pprof/heap
		   - å†…å­˜åˆ†é…: http://localhost:6060/debug/pprof/allocs
		   - å†…å­˜åˆ†æ(å¸¦è°ƒè¯•): http://localhost:6060/debug/pprof/heap?debug=1

		2. âš¡ CPU åˆ†æ
		   - CPU Profile (30ç§’): http://localhost:6060/debug/pprof/profile
		   - CPU Profile (è‡ªå®šä¹‰æ—¶é•¿): http://localhost:6060/debug/pprof/profile?seconds=60

		3. ğŸ”„ Goroutine åˆ†æ
		   - Goroutine æ¦‚è§ˆ: http://localhost:6060/debug/pprof/goroutine
		   - å®Œæ•´å †æ ˆè½¬å‚¨: http://localhost:6060/debug/pprof/goroutine?debug=2
		   - Goroutine è°ƒè¯•ä¿¡æ¯: http://localhost:6060/debug/pprof/goroutine?debug=1

		4. ğŸ”’ é˜»å¡å’Œé”åˆ†æ
		   - é˜»å¡åˆ†æ: http://localhost:6060/debug/pprof/block
		   - äº’æ–¥é”åˆ†æ: http://localhost:6060/debug/pprof/mutex

		5. ğŸ§µ çº¿ç¨‹åˆ†æ
		   - çº¿ç¨‹åˆ›å»º: http://localhost:6060/debug/pprof/threadcreate

		6. ğŸ“Š è¿½è¸ªåˆ†æ
		   - æ‰§è¡Œè¿½è¸ª: http://localhost:6060/debug/pprof/trace

		7. ğŸ”§ è°ƒè¯•å·¥å…·
		   - å‘½ä»¤è¡Œå‚æ•°: http://localhost:6060/debug/pprof/cmdline
		   - ç¬¦å·è¡¨: http://localhost:6060/debug/pprof/symbol

		ğŸ’¡ ä½¿ç”¨æŠ€å·§:

		1. å†…å­˜æ³„æ¼æ£€æµ‹:
		   curl http://localhost:6060/debug/pprof/heap > heap.prof
		   go tool pprof heap.prof
		   (pprof) top
		   (pprof) list <function_name>

		2. CPU æ€§èƒ½åˆ†æ:
		   curl http://localhost:6060/debug/pprof/profile > cpu.prof
		   go tool pprof cpu.prof
		   (pprof) top
		   (pprof) web

		3. Goroutine æ³„æ¼æ£€æµ‹:
		   curl http://localhost:6060/debug/pprof/goroutine?debug=2 > goroutine.txt
		   # åˆ†æ goroutine æ•°é‡å’Œå †æ ˆ

		4. å®æ—¶ç›‘æ§:
		   watch -n 5 'curl -s http://localhost:6060/debug/pprof/ | grep -E "goroutine|heap"'

		5. ç”Ÿæˆç«ç„°å›¾:
		   go tool pprof -http=:8081 http://localhost:6060/debug/pprof/profile

		âš ï¸  æ³¨æ„äº‹é¡¹:
		- ç”Ÿäº§ç¯å¢ƒè°¨æ…ä½¿ç”¨ï¼Œå¯èƒ½å½±å“æ€§èƒ½
		- CPU profile ä¼šæš‚åœç¨‹åºæ‰§è¡Œ
		- å¤§é‡ goroutine æ—¶ debug=2 å¯èƒ½å¾ˆæ…¢
		- å»ºè®®åœ¨æµ‹è¯•ç¯å¢ƒè¿›è¡Œè¯¦ç»†åˆ†æ

		===============================================================================
	*/
}
