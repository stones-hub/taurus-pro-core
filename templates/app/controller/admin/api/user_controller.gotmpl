package api

import (
	"context"
	"encoding/json"
	"log"
	"math"
	"net/http"
	"strconv"
	"strings"
	"time"

	"{{.ProjectName}}/app/controller/admin/common"
	"{{.ProjectName}}/app/helper"
	"{{.ProjectName}}/app/helper/store"
	"{{.ProjectName}}/app/model/dto"
	"{{.ProjectName}}/app/service"
	mw "{{.ProjectName}}/pkg/middleware"

	"github.com/google/wire"
	"github.com/stones-hub/taurus-pro-common/pkg/co"
	"github.com/stones-hub/taurus-pro-common/pkg/util/tmap"
	"github.com/stones-hub/taurus-pro-common/pkg/util/tnet"
	"github.com/stones-hub/taurus-pro-common/pkg/util/tstruct"
	"github.com/stones-hub/taurus-pro-http/pkg/httpx"
)

// UserApiController 用户API控制器
// 负责登录入口与账户变更接口（绑定/解绑/设置/修改密码），聚焦参数校验、鉴权与CSRF防护，业务委派给 AdminAuthService。
type UserApiController struct {
	*common.BaseController
	AdminAuthService        *service.AdminAuthService
	RoleService             *service.AdminRoleService
	VerificationCodeManager *helper.VerificationCodeManager
	AuthRedisStore          *store.AuthRedisStore
}

var UserApiControllerSet = wire.NewSet(wire.Struct(new(UserApiController), "*"))

// Login 统一用户登录接口（支持传统登录和第三方登录）
func (c *UserApiController) Login(w http.ResponseWriter, r *http.Request) {
	var (
		err        error
		bodyParams map[string]interface{}
		login      dto.LoginRequest
		response   *dto.LoginResponse
	)
	// 1. 验证请求方法
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	// 2. 解析请求参数
	bodyParams, err = httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}

	// 3. 验证必填参数
	err = tstruct.MapToStructWithValidation(bodyParams, &login, "login_type")
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 3.5. 过滤字符串字段的前后空格
	login.LoginType = strings.TrimSpace(login.LoginType)
	login.LoginValue = strings.TrimSpace(login.LoginValue)
	login.Password = strings.TrimSpace(login.Password)
	login.Code = strings.TrimSpace(login.Code)

	// 4. 根据登录类型验证其他特定参数
	loginType := helper.LoginType(login.LoginType)
	if helper.IsPasswordLogin(loginType) {
		// 密码登录需要密码
		if login.Password == "" {
			c.ErrorResponse(w, helper.CodeInvalidParams, "密码不能为空")
			return
		}
	} else if helper.IsCodeLogin(loginType) {
		// 验证码登录需要验证码
		if login.Code == "" {
			c.ErrorResponse(w, helper.CodeInvalidParams, "验证码不能为空")
			return
		}
	} else if helper.IsThirdPartyLogin(loginType) {
		// 第三方登录需要第三方ID
		if login.Code == "" {
			c.ErrorResponse(w, helper.CodeInvalidParams, "第三方授权码不能为空")
			return
		}
	}

	// 5. 验证登录类型
	if !helper.ValidateLoginType(loginType) {
		c.ErrorResponse(w, helper.CodeInvalidParams, "不支持的登录类型")
		return
	}

	// 6. 获取客户端IP
	clientIP := tnet.GetRemoteIP(r)

	// 分发到新认证服务
	switch helper.LoginType(login.LoginType) {
	case helper.LoginTypeUsername:
		response, err = c.AdminAuthService.PasswordLogin(r.Context(), login.LoginValue, login.Password, clientIP, r.UserAgent())
	case helper.LoginTypeMobile:
		response, err = c.AdminAuthService.SmsLogin(r.Context(), login.LoginValue, login.Code, clientIP, r.UserAgent())
	default:
		// 第三方：login_type 作为 provider，code 为授权码；增强 state/nonce 防护
		state := ""
		if v, ok := bodyParams["state"].(string); ok {
			state = v
		}
		nonce := ""
		if v, ok := bodyParams["nonce"].(string); ok {
			nonce = v
		}
		if state == "" || nonce == "" || !c.AuthRedisStore.VerifyAndConsumeOAuthStateNonce(state, nonce) {
			c.ErrorResponse(w, helper.CodeUnauthorized, "非法授权请求或已过期")
			return
		}
		response, err = c.AdminAuthService.OauthLoginByCode(r.Context(), login.LoginType, login.Code, clientIP, r.UserAgent())
	}
	if err != nil {
		log.Printf("登录失败: %v", err)
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}

	// 处理响应
	if response.Status == "success" {
		// 登录成功，设置JWT Cookie
		if response.Token != "" {
			helper.SetJWTToken(w, response.Token)
		}
		// 登录成功，生成并设置CSRF Token Cookie
		csrfToken, err := helper.GenerateCSRFToken()
		if err != nil {
			log.Printf("生成CSRF Token失败: %v", err)
			// CSRF token生成失败不影响登录，但会影响后续需要CSRF保护的接口
		} else {
			helper.SetCSRFToken(w, csrfToken)
		}
		// 安全起见，异步更新用户最后登录时间和IP，避免阻塞主线程
		co.AsyncGoWithTimeout("UpdateUserLastLogin", 10*time.Second, func(ctx context.Context) {
			c.AdminAuthService.UpdateUserLastLogin(ctx, response.User.UserID, time.Now(), tnet.GetRemoteIP(r))
		})

		c.Response(w, helper.CodeSuccess, response.Message, response)
	} else {
		c.ErrorResponse(w, helper.CodeError, response.Message)
	}
}

type unbindMobileReq struct {
	Mobile string `json:"mobile"`
	Code   string `json:"code"`
}

// UnbindMobile 解绑当前用户手机号（需登录，需要验证码验证）
// CSRF保护由中间件自动处理
func (c *UserApiController) UnbindMobile(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权")
		return
	}
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	var req unbindMobileReq
	if err := tstruct.MapToStructWithValidation(body, &req, "mobile", "code"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	// 过滤字符串字段的前后空格
	req.Mobile = strings.TrimSpace(req.Mobile)
	req.Code = strings.TrimSpace(req.Code)
	if !helper.ValidateMobile(req.Mobile) {
		c.ErrorResponse(w, helper.CodeInvalidParams, "手机号格式不正确")
		return
	}
	if err := c.AdminAuthService.UnbindMobile(r.Context(), userID, req.Mobile, req.Code); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	c.Response(w, helper.CodeSuccess, "解绑成功", map[string]any{"status": "success"})
}

type updateCurrentUserProfileReq struct {
	Realname string `json:"realname"`
	Nickname string `json:"nickname"`
	Email    string `json:"email"`
	Gender   int    `json:"gender"`
	Birthday string `json:"birthday"`
}

// UnmarshalJSON 自定义JSON反序列化，支持gender字段可以是字符串或整数
func (u *updateCurrentUserProfileReq) UnmarshalJSON(data []byte) error {
	// 使用临时结构体来接收原始JSON
	var temp struct {
		Realname string      `json:"realname"`
		Nickname string      `json:"nickname"`
		Email    string      `json:"email"`
		Gender   interface{} `json:"gender"` // 使用interface{}来接受字符串或整数
		Birthday string      `json:"birthday"`
	}

	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	// 赋值基本字段
	u.Realname = temp.Realname
	u.Nickname = temp.Nickname
	u.Email = temp.Email
	u.Birthday = temp.Birthday

	// 处理Gender字段：支持字符串或整数
	switch v := temp.Gender.(type) {
	case string:
		// 如果是字符串，转换为int
		genderInt, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			// 解析失败，默认为0
			u.Gender = 0
		} else {
			u.Gender = int(genderInt)
		}
	case float64:
		// JSON数字默认解析为float64
		u.Gender = int(v)
	case int64:
		u.Gender = int(v)
	case int:
		u.Gender = v
	default:
		// 其他类型或nil，默认为0
		u.Gender = 0
	}

	return nil
}

// UpdateCurrentUserProfile 更新当前用户个人信息（需登录，不需要权限校验）
// CSRF保护由中间件自动处理
func (c *UserApiController) UpdateCurrentUserProfile(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权")
		return
	}
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	var req updateCurrentUserProfileReq
	if err := tstruct.MapToStruct(body, &req); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	// 过滤字符串字段的前后空格
	req.Realname = strings.TrimSpace(req.Realname)
	req.Nickname = strings.TrimSpace(req.Nickname)
	req.Email = strings.TrimSpace(req.Email)
	req.Birthday = strings.TrimSpace(req.Birthday)

	serviceReq := service.UpdateCurrentUserProfileReq{
		Realname: req.Realname,
		Nickname: req.Nickname,
		Email:    req.Email,
		Gender:   req.Gender,
		Birthday: req.Birthday,
	}
	if err := c.AdminAuthService.UpdateCurrentUserProfile(r.Context(), userID, serviceReq); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	c.Response(w, helper.CodeSuccess, "更新个人信息成功", map[string]any{"status": "success"})
}

type setPasswordReq struct {
	Password string `json:"password"`
}

// SetPassword 为当前用户设置/重置密码（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) SetPassword(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权")
		return
	}
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	var req setPasswordReq
	if err := tstruct.MapToStructWithValidation(body, &req, "password"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	// 过滤字符串字段的前后空格
	req.Password = strings.TrimSpace(req.Password)
	if err := helper.ValidatePassword(req.Password); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	token, err := c.AdminAuthService.SetPassword(r.Context(), userID, req.Password)
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	// 设置新的 JWT token
	helper.SetJWTToken(w, token)
	c.Response(w, helper.CodeSuccess, "密码设置成功", map[string]any{
		"status": "success",
		"token":  token,
	})
}

type changePasswordReq struct {
	OldPassword string `json:"old_password"`
	NewPassword string `json:"new_password"`
}

// ChangePassword 修改当前用户密码（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) ChangePassword(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权")
		return
	}
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	var req changePasswordReq
	if err := tstruct.MapToStructWithValidation(body, &req, "old_password", "new_password"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 过滤字符串字段的前后空格
	req.OldPassword = strings.TrimSpace(req.OldPassword)
	req.NewPassword = strings.TrimSpace(req.NewPassword)

	token, err := c.AdminAuthService.ChangePassword(r.Context(), userID, req.OldPassword, req.NewPassword)
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	// 设置新的 JWT token
	helper.SetJWTToken(w, token)
	c.Response(w, helper.CodeSuccess, "密码修改成功", map[string]any{
		"status": "success",
		"token":  token,
	})
}

type bindMobileReq struct {
	Mobile string `json:"mobile"`
	Code   string `json:"code"`
}

// BindMobile 绑定手机号（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) BindMobile(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权")
		return
	}
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	var req bindMobileReq
	if err := tstruct.MapToStructWithValidation(body, &req, "mobile", "code"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	// 过滤字符串字段的前后空格
	req.Mobile = strings.TrimSpace(req.Mobile)
	req.Code = strings.TrimSpace(req.Code)
	if !helper.ValidateMobile(req.Mobile) {
		c.ErrorResponse(w, helper.CodeInvalidParams, "手机号格式不正确")
		return
	}
	if err := c.AdminAuthService.BindMobile(r.Context(), userID, req.Mobile, req.Code); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	c.Response(w, helper.CodeSuccess, "绑定成功", map[string]any{"status": "success"})
}

// 从 JWT 中间件上下文获取用户ID
func currentUserIDFromJWT(r *http.Request) (uint64, bool) {
	uidStr := mw.GetUserID(r)
	if uidStr == "" {
		return 0, false
	}
	uid, err := strconv.ParseUint(uidStr, 10, 64)
	if err != nil {
		return 0, false
	}
	return uid, true
}

// SendCode 手机/邮箱发送验证码接口
func (c *UserApiController) SendCode(w http.ResponseWriter, r *http.Request) {
	var (
		err        error
		bodyParams map[string]interface{}
		req        dto.SendCodeRequest
	)

	// 1. 验证请求方法
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	// 2. 解析请求参数
	bodyParams, err = httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}

	// 3. 验证必填参数
	err = tstruct.MapToStructWithValidation(bodyParams, &req, "login_type", "login_value")
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 3.5. 过滤字符串字段的前后空格
	req.LoginType = strings.TrimSpace(req.LoginType)
	req.LoginValue = strings.TrimSpace(req.LoginValue)

	// 4. 验证登录类型（只支持mobile和email）
	t := helper.LoginType(req.LoginType)
	if !helper.IsCodeLogin(t) {
		c.ErrorResponse(w, helper.CodeInvalidParams, "登录类型必须是mobile或email")
		return
	}

	// 5-6. 验证格式并发送验证码
	var code string
	switch t {
	case helper.LoginTypeMobile:
		if !helper.ValidateMobile(req.LoginValue) {
			c.ErrorResponse(w, helper.CodeInvalidParams, "手机号格式不正确")
			return
		}
		code, err = c.VerificationCodeManager.SendSMSCode(req.LoginValue)
	default:
		c.ErrorResponse(w, helper.CodeInvalidParams, "不支持的登录类型")
		return
	}

	// 7. 处理响应
	if err != nil {
		log.Printf("发送验证码失败: %v", err)
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}

	log.Printf("发送验证码成功: %s, 验证码: %s", req.LoginValue, code)

	// 发送成功
	c.Response(w, helper.CodeSuccess, "验证码发送成功", dto.SendCodeResponse{
		Status:  "success",
		Message: "验证码已发送，请查收",
		Expires: 300, // 5分钟
	})
}

// OAuthInit 生成 OAuth state/nonce（建议前端在跳转第三方前先调用）
func (c *UserApiController) OAuthInit(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet && r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}
	state, nonce, err := c.AuthRedisStore.CreateOAuthStateNonce(0)
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, "生成凭证失败")
		return
	}
	c.Response(w, helper.CodeSuccess, "ok", map[string]any{
		"state": state,
		"nonce": nonce,
	})
}

// Logout 用户登出接口（需登录）
// 流程：验证用户身份 -> 调用服务层记录登出日志 -> 清除JWT Cookie -> 返回成功
func (c *UserApiController) Logout(w http.ResponseWriter, r *http.Request) {
	// 1. 验证请求方法
	// 2. 从JWT中间件设置的上下文中获取用户信息
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权访问")
		return
	}

	// 3. 获取客户端IP和User-Agent
	clientIP := tnet.GetRemoteIP(r)
	userAgent := r.UserAgent()

	// 4. 调用服务层登出方法（记录登出日志）
	if err := c.AdminAuthService.Logout(r.Context(), userID, clientIP, userAgent); err != nil {
		c.ErrorResponse(w, helper.CodeError, "登出失败: "+err.Error())
		return
	}

	// 5. 清除JWT Cookie
	helper.ClearJWTToken(w)

	// 6. 清除CSRF Token Cookie
	helper.ClearCSRFToken(w)

	// 7. 返回成功响应
	c.Response(w, helper.CodeSuccess, "登出成功", map[string]any{
		"status": "success",
	})
}

// GetCurrentUserInfo 获取当前用户信息接口（需登录）
func (c *UserApiController) GetCurrentUserInfo(w http.ResponseWriter, r *http.Request) {
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权访问")
		return
	}

	user, err := c.AdminAuthService.GetUserInfo(r.Context(), userID)
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, "获取用户信息失败: "+err.Error())
		return
	}

	c.Response(w, helper.CodeSuccess, "获取用户信息成功", user)
}

// GetUserInfo 获取用户信息接口（需登录）
func (c *UserApiController) GetUserInfo(w http.ResponseWriter, r *http.Request) {
	// 解析提交的表单
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	log.Printf("获取用户信息接口: %v, 请求参数: %v", r.URL.String(), body)
	uid := tmap.GetInt64(body, "user_id", 0)
	if uid == 0 {
		c.ErrorResponse(w, helper.CodeInvalidParams, "用户ID不能为空")
		return
	}

	user, err := c.AdminAuthService.GetUserInfo(r.Context(), uint64(uid))
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, "获取用户信息失败: "+err.Error())
		return
	}
	c.Response(w, helper.CodeSuccess, "获取用户信息成功", user)
}

// GetUserList 获取用户列表接口（需登录）
func (c *UserApiController) GetUserList(w http.ResponseWriter, r *http.Request) {
	// 1. 验证请求方法
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	// 2. 从JWT中间件设置的上下文中获取用户信息 (TODO: 校验权限是否足够)
	_, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeNotFound, "未解析到用户ID")
		return
	}

	// 3. 获取分页参数
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	no := tmap.GetInt(body, "page_no", 1)                                       // 当前页码
	size := tmap.GetInt(body, "page_size", 15)                                  // 每页条数
	ume := strings.TrimSpace(tmap.GetString(body, "username_mobile_email", "")) // 用户名、手机号、邮箱（过滤前后空格）
	status := tmap.GetInt(body, "status", -1)
	log.Printf("ume(用户名/手机号/邮箱): %s, status(状态): %d", ume, status)
	users, total, err := c.AdminAuthService.GetUserList(r.Context(), no, size, ume, status)
	if err != nil {
		c.ErrorResponse(w, helper.CodeError, "获取用户列表失败: "+err.Error())
		return
	}
	// 计算总页数
	totalPage := int(math.Ceil(float64(total) / float64(size)))
	c.Response(w, helper.CodeSuccess, "获取用户列表成功", dto.UserListResponse{
		PageNo:      no,
		PageSize:    size,
		ResultTotal: totalPage,
		Users:       users,
	})
}

type updateUserStatusReq struct {
	UserID uint64 `json:"user_id"`
	Status int    `json:"status"`
}

// UpdateUserStatus 更新用户状态接口（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) UpdateUserStatus(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}

	var req updateUserStatusReq
	if err := tstruct.MapToStructWithValidation(body, &req, "user_id", "status"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 验证状态值
	if req.Status != 0 && req.Status != 1 {
		c.ErrorResponse(w, helper.CodeInvalidParams, "状态值必须为0(禁用)或1(启用)")
		return
	}

	if err := c.AdminAuthService.UpdateUserStatus(r.Context(), req.UserID, req.Status); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}

	c.Response(w, helper.CodeSuccess, "状态更新成功", map[string]any{
		"status": "success",
		"value":  req.Status,
	})
}

// DeleteUser 删除用户接口（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) DeleteUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}
	uid := tmap.GetInt64(body, "user_id", 0)
	if uid == 0 {
		c.ErrorResponse(w, helper.CodeInvalidParams, "用户ID不能为空")
		return
	}

	// 账户删除即将用户状态设置为-1
	if err := c.AdminAuthService.UpdateUserStatus(r.Context(), uint64(uid), -1); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}
	c.Response(w, helper.CodeSuccess, "删除用户成功", map[string]any{
		"status": "success",
	})
}

// UpdateUser 更新用户接口（需登录）
// CSRF保护由中间件自动处理
func (c *UserApiController) UpdateUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}

	log.Printf("更新用户接口: %v, 请求参数: %v", r.URL.String(), body)

	var updateUser dto.UpdateUserRequest
	err = tstruct.MapToStruct(body, &updateUser)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 过滤字符串字段的前后空格
	updateUser.Realname = strings.TrimSpace(updateUser.Realname)
	updateUser.Nickname = strings.TrimSpace(updateUser.Nickname)
	updateUser.Email = strings.TrimSpace(updateUser.Email)
	updateUser.Birthday = strings.TrimSpace(updateUser.Birthday)

	// 过滤掉body中的role_ids字段的值为空/false的数据，并转换为uint64数组
	roleIDs := make([]uint64, 0)
	for _, roleID := range updateUser.RoleIDs {
		if roleID != nil && roleID != false {
			roleIDs = append(roleIDs, uint64(roleID.(float64)))
		}
	}

	// 更新用户基本信息
	if err := c.AdminAuthService.UpdateUser(r.Context(), updateUser); err != nil {
		c.ErrorResponse(w, helper.CodeError, err.Error())
		return
	}

	// 更新用户角色关联关系
	if err := c.RoleService.UpdateUserRoles(r.Context(), updateUser.UserID, roleIDs); err != nil {
		log.Printf("更新用户角色关联关系失败: %v", err)
		c.ErrorResponse(w, helper.CodeError, "更新用户角色关联关系失败: "+err.Error())
		return
	}

	c.Response(w, helper.CodeSuccess, "更新用户成功", map[string]any{
		"status": "success",
	})
}

// AddUser 新增用户接口（需登录）, 管理员才能新增用户
// CSRF保护由中间件自动处理
// 同时创建账密登录和手机号验证码登录两种方式
func (c *UserApiController) AddUser(w http.ResponseWriter, r *http.Request) {
	// 1. 验证请求方法
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	// 2. 从JWT中间件设置的上下文中获取用户信息 (TODO: 校验权限是否足够)
	_, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权访问")
		return
	}

	// 3. 解析请求参数
	body, err := httpx.ParseJson(r)
	if err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求参数格式错误")
		return
	}

	log.Printf("新增用户接口: %v, 请求参数: %v", r.URL.String(), body)

	// 4. 验证必填参数并转换为DTO
	var req dto.AddUserRequest
	if err := tstruct.MapToStructWithValidation(body, &req, "username", "password", "mobile"); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}

	// 4.5. 过滤字符串字段的前后空格
	req.Username = strings.TrimSpace(req.Username)
	req.Password = strings.TrimSpace(req.Password)
	req.Mobile = strings.TrimSpace(req.Mobile)
	req.Realname = strings.TrimSpace(req.Realname)
	req.Nickname = strings.TrimSpace(req.Nickname)
	req.Email = strings.TrimSpace(req.Email)
	req.Birthday = strings.TrimSpace(req.Birthday)
	req.Avatar = strings.TrimSpace(req.Avatar)

	// 过滤掉body中的role_ids字段的值为空/false的数据，并转换为uint64数组
	roleIDs := make([]uint64, 0)
	for _, roleID := range req.RoleIDs {
		if roleID != nil && roleID != false {
			roleIDs = append(roleIDs, uint64(roleID.(float64)))
		}
	}

	// 5. 参数校验
	// 校验用户名格式
	if len(req.Username) < 5 || len(req.Username) > 20 {
		c.ErrorResponse(w, helper.CodeInvalidParams, "用户名长度必须在5-20位之间")
		return
	}
	// 校验密码格式
	if err := helper.ValidatePassword(req.Password); err != nil {
		c.ErrorResponse(w, helper.CodeInvalidParams, err.Error())
		return
	}
	// 校验手机号格式
	if !helper.ValidateMobile(req.Mobile) {
		c.ErrorResponse(w, helper.CodeInvalidParams, "手机号格式不正确")
		return
	}

	// 6. 设置默认值
	if req.UserSource == 0 {
		req.UserSource = 3 // 默认为管理员创建
	}
	if req.Gender == 0 {
		req.Gender = 0 // 默认为未知
	}

	// 7. 调用服务层新增用户
	if err := c.AdminAuthService.AddUser(r.Context(), req); err != nil {
		log.Printf("新增用户失败: %v", err)
		c.ErrorResponse(w, helper.CodeError, "新增用户失败: "+err.Error())
		return
	}

	// 8. 批量创建用户角色关联关系，注意创建之前，需要检查角色ID是否存在， 用户是否存在
	if len(roleIDs) > 0 {
		// 调用服务层批量创建用户角色关联关系
		if err := c.RoleService.AddUserRoles(r.Context(), req.Username, roleIDs); err != nil {
			log.Printf("批量创建用户角色关联关系失败: %v", err)
			c.ErrorResponse(w, helper.CodeError, "批量创建用户角色关联关系失败: "+err.Error())
			return
		}
	}

	// 9. 返回成功响应
	c.Response(w, helper.CodeSuccess, "新增用户成功", map[string]any{
		"status": "success",
	})
}

// GetUserMenusAndButtons 获取用户菜单和按钮权限接口（需登录）
// 返回用户有权限的菜单树和按钮权限编码列表
func (c *UserApiController) GetUserMenusAndButtons(w http.ResponseWriter, r *http.Request) {
	// 1. 验证请求方法
	if r.Method != http.MethodPost {
		c.ErrorResponse(w, helper.CodeInvalidParams, "请求方法错误")
		return
	}

	// 2. 从JWT中间件设置的上下文中获取用户ID
	userID, ok := currentUserIDFromJWT(r)
	if !ok {
		c.ErrorResponse(w, helper.CodeUnauthorized, "未授权访问")
		return
	}

	// 3. 调用服务层获取用户菜单和按钮权限
	response, err := c.RoleService.GetUserMenusAndButtons(r.Context(), userID)
	if err != nil {
		log.Printf("获取用户菜单和按钮权限失败: %v", err)
		c.ErrorResponse(w, helper.CodeError, "获取用户菜单和按钮权限失败: "+err.Error())
		return
	}

	// 4. 返回成功响应
	c.Response(w, helper.CodeSuccess, "获取用户菜单和按钮权限成功", response)
}
