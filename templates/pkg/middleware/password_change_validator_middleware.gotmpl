package middleware

import (
	"fmt"
	"strconv"

	"{{.ProjectName}}/app/helper/store"
	"net/http"

	"github.com/stones-hub/taurus-pro-common/pkg/util/tcrypt"
	"github.com/stones-hub/taurus-pro-http/pkg/httpx"
)

// PasswordChangeValidatorMiddleware 密码修改时间戳验证中间件（切面）
// 用于验证 JWT token 是否在密码修改之后签发，确保密码修改后旧 token 失效
// 注意：此中间件必须在 JWTMiddleware 之后使用，因为它依赖于 JWT 中间件设置的 context
func PasswordChangeValidatorMiddleware() func(next http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// 从 context 中获取 JWT claims（由 JWT 中间件设置）
			claims := GetJWTClaims(r)
			if claims == nil {
				// 如果没有 claims，说明 JWT 中间件未执行或验证失败，跳过此验证
				// 让后续中间件或路由处理
				next.ServeHTTP(w, r)
				return
			}

			// 获取 JWT token
			token := GetJWTToken(r)
			if token == "" {
				// 如果没有 token，跳过验证
				next.ServeHTTP(w, r)
				return
			}

			// 解析 token 获取完整的 tcrypt.Claims（包含 IssuedAt）
			_, tcryptClaims, err := ValidateJWTToken(token)
			if err != nil {
				// 解析失败，跳过验证（JWT 中间件应该已经处理了）
				next.ServeHTTP(w, r)
				return
			}

			// 验证密码修改时间戳（所有逻辑都在这里，避免循环导入）
			if err := validateTokenAgainstPasswordChange(claims.UID, tcryptClaims); err != nil {
				httpx.SendResponse(w, http.StatusUnauthorized, err.Error(), nil)
				return
			}

			// 验证通过，继续处理请求
			next.ServeHTTP(w, r)
		})
	}
}

// validateTokenAgainstPasswordChange 验证 JWT token 是否在密码修改之后签发（内部函数）
// 用于确保密码修改后，所有修改前签发的 token 自动失效
func validateTokenAgainstPasswordChange(userID string, claims *tcrypt.Claims) error {
	// 如果 claims 为空或 IssuedAt 无效，跳过验证（可能是首次登录，从未修改过密码）
	if claims == nil || claims.IssuedAt <= 0 {
		return nil
	}

	// 解析用户ID
	uid, err := strconv.ParseUint(userID, 10, 64)
	if err != nil {
		// 如果无法解析用户ID，跳过验证（避免因格式问题导致误判）
		return nil
	}

	// 从 Redis 获取最近一次密码修改时间戳
	authStore := store.NewAuthRedisStore()
	lastPwChange, err := authStore.GetLastPasswordChangeAt(uid)
	if err != nil {
		// Redis 查询失败，跳过验证（避免因 Redis 故障导致所有请求被拒绝）
		// 在生产环境中，可以考虑记录日志
		return nil
	}

	// 如果从未修改过密码（lastPwChange == 0），则 token 始终有效
	if lastPwChange == 0 {
		return nil
	}

	// 比较 token 签发时间和密码修改时间
	// 注意：需要确保时间单位一致（都是秒级或都是毫秒级）
	// tcrypt.Claims.IssuedAt 通常是秒级时间戳，与 Redis 存储的时间戳一致
	tokenIssuedAt := claims.IssuedAt
	if tokenIssuedAt < lastPwChange {
		return fmt.Errorf("JWT令牌已失效，密码已在 %d 时修改，请重新登录", lastPwChange)
	}

	return nil
}
