package middleware

import (
	"context"
	"net/http"
	"time"

	"{{.ProjectName}}/internal/taurus"

	"github.com/stones-hub/taurus-pro-common/pkg/util/tcrypt"
	"github.com/stones-hub/taurus-pro-http/pkg/httpx"
)

// contextKey 用于 context 的类型安全 key
type contextKey string

// JWTTokenKey 负责从请求中提取JWT令牌, 优先从Cookie中获取, 然后从请求头中获取
const JWTTokenKey = "jwt_token"

// JWTTokenClaimsKey 负责将JWT声明对象添加到请求上下文，方便后端使用
const JWTTokenClaimsKey contextKey = "jwt_claims"

// JWTClaims JWT声明结构
type JWTClaims struct {
	UID      string `json:"uid"`      // 用户ID
	Username string `json:"username"` // 用户名
}

// JWTMiddleware JWT中间件
func JWTMiddleware() func(next http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// 检查JWT是否启用
			if !taurus.Container.Config.GetBool("http.jwt.enabled") {
				next.ServeHTTP(w, r)
				return
			}

			// 获取JWT令牌
			token := GetJWTToken(r)
			if token == "" {
				httpx.SendResponse(w, http.StatusUnauthorized, "缺少JWT令牌", nil)
				return
			}

			// 验证JWT令牌
			claims, _, err := ValidateJWTToken(token)
			if err != nil {
				httpx.SendResponse(w, http.StatusUnauthorized, "JWT令牌无效: "+err.Error(), nil)
				return
			}

			// 构建JWT声明对象
			jwtClaims := JWTClaims{
				UID:      claims.UID,
				Username: claims.Username,
			}

			// 将用户信息添加到请求上下文
			ctx := context.WithValue(r.Context(), JWTTokenClaimsKey, jwtClaims)
			r = r.WithContext(ctx)
			next.ServeHTTP(w, r)
		})
	}
}

// GetJWTToken 从请求中提取JWT令牌, 优先从Cookie中获取, 然后从请求头中获取
func GetJWTToken(r *http.Request) string {
	// 从Cookie中获取JWT令牌
	if cookie, err := r.Cookie(JWTTokenKey); err == nil {
		return cookie.Value
	}

	// 从请求头中获取JWT令牌
	if token := r.Header.Get(JWTTokenKey); token != "" {
		return token
	}
	return ""
}

// GenerateJWTToken 生成JWT令牌（用于登录等场景）
func GenerateJWTToken(uid string, username string) (string, error) {
	// 获取配置的过期时间
	expireHours := taurus.Container.Config.GetInt("http.jwt.expire_hours")
	if expireHours <= 0 {
		expireHours = 24 // 默认24小时
	}

	// 使用tcrypt包生成JWT令牌
	return tcrypt.GenerateTokenWithExpiration(
		uid,
		username,
		taurus.Container.Config.GetString("http.jwt.issuer"), // JWT签发者
		taurus.Container.Config.GetString("http.jwt.secret"), // JWT密钥
		time.Duration(expireHours)*time.Hour,                 // JWT过期时间(小时)
	)
}

// ValidateJWTToken 验证JWT令牌，返回内部 Claims 和完整的 tcrypt Claims
func ValidateJWTToken(token string) (*JWTClaims, *tcrypt.Claims, error) {
	// 使用tcrypt包解析JWT令牌
	tcryptClaims, err := tcrypt.ParseTokenWithSecret(token, taurus.Container.Config.GetString("http.jwt.secret"))
	if err != nil {
		return nil, nil, err
	}

	// 转换为内部Claims结构
	return &JWTClaims{
		UID:      tcryptClaims.Uid,
		Username: tcryptClaims.Username,
	}, tcryptClaims, nil
}

// RefreshJWTToken 刷新JWT令牌
func RefreshJWTToken(w http.ResponseWriter, token string) (string, error) {
	var err error
	var newToken string
	var claims *tcrypt.Claims
	// 解析现有令牌
	claims, err = tcrypt.ParseTokenWithSecret(token, taurus.Container.Config.GetString("http.jwt.secret"))
	if err != nil {
		return "", err
	}

	// 生成新的令牌
	newToken, err = GenerateJWTToken(claims.Uid, claims.Username)
	if err != nil {
		return "", err
	}

	// 设置新的令牌到响应头和 Cookie
	SetJWTToken(w, newToken)
	return newToken, nil // 修复：返回新token而不是旧token
}

// SetJWTToken 设置JWT令牌到响应头（header）和Cookie，供前端使用
func SetJWTToken(w http.ResponseWriter, token string) {
	// 获取配置的过期时间（只读取一次）
	expireHours := taurus.Container.Config.GetInt("http.jwt.expire_hours")
	if expireHours <= 0 {
		expireHours = 24 // 默认24小时
	}
	expiresAt := time.Now().Add(time.Duration(expireHours) * time.Hour)

	// 设置响应头，前端可以通过 JavaScript 读取
	w.Header().Set(JWTTokenKey, token)
	// 设置Cookie，浏览器会自动保存并在后续请求中发送
	http.SetCookie(w, &http.Cookie{
		Name:     JWTTokenKey,
		Value:    token,
		Expires:  expiresAt,
		Path:     "/",
		HttpOnly: true,
		Secure:   taurus.Container.Config.GetBool("http.jwt.secure"), // 根据配置或环境决定
		SameSite: http.SameSiteLaxMode,
	})
}

// GetJWTClaims 从请求上下文中获取JWT声明
func GetJWTClaims(r *http.Request) *JWTClaims {
	if claims, ok := r.Context().Value(JWTTokenClaimsKey).(JWTClaims); ok {
		return &claims
	}
	return nil
}

// GetUserID 从请求上下文中获取用户ID
func GetUserID(r *http.Request) string {
	claims := GetJWTClaims(r)
	if claims != nil {
		return claims.UID
	}
	return ""
}

// GetUsername 从请求上下文中获取用户名
func GetUsername(r *http.Request) string {
	claims := GetJWTClaims(r)
	if claims != nil {
		return claims.Username
	}
	return ""
}

// ClearJWTToken 清除JWT令牌
func ClearJWTToken(w http.ResponseWriter) {
	// 删除响应头中的JWT Token
	w.Header().Del(JWTTokenKey)

	// 清除JWT Token Cookie（设置过期时间为过去，立即失效）
	http.SetCookie(w, &http.Cookie{
		Name:     JWTTokenKey,
		Value:    "",
		Expires:  time.Now().Add(-1 * time.Hour),
		Path:     "/",
		HttpOnly: true,
		Secure:   taurus.Container.Config.GetBool("http.jwt.secure"), // 与SetJWTToken保持一致
		SameSite: http.SameSiteLaxMode,
	})
}
